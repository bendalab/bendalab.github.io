<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>thunderfish.eodexplorer API documentation</title>
<meta name="description" content="View and explore properties of EOD waveforms." />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS_CHTML" integrity="sha256-kZafAc6mZvK3W3v1pHOcUix30OHQN6pU/NO2oFkqZVw=" crossorigin></script>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>thunderfish.eodexplorer</code></h1>
</header>
<section id="section-intro">
<p>View and explore properties of EOD waveforms.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;View and explore properties of EOD waveforms.
&#34;&#34;&#34;

import os
import glob
import sys
import argparse
import numpy as np
import scipy.signal as sig
import matplotlib.pyplot as plt
import matplotlib.ticker as ticker
from multiprocessing import Pool, freeze_support, cpu_count
from .version import __version__, __year__
from .configfile import ConfigFile
from .tabledata import TableData, add_write_table_config, write_table_args
from .dataloader import load_data
from .multivariateexplorer import MultivariateExplorer
from .harmonics import add_harmonic_groups_config
from .eodanalysis import add_species_config
from .eodanalysis import wave_quality, wave_quality_args, add_eod_quality_config
from .eodanalysis import pulse_quality, pulse_quality_args
from .powerspectrum import decibel
from .bestwindow import analysis_window
from .thunderfish import configuration, detect_eods, plot_eods


basename = &#39;&#39;


class EODExplorer(MultivariateExplorer):
    &#34;&#34;&#34;Simple GUI for viewing and exploring properties of EOD waveforms.

    EODExplorer adapts a MultivariateExplorer to specific needs of EODs.

    Static members
    --------------
    - `groups`: names of groups of data columns that can be selected.
    - `select_EOD_properties()`: select data columns to be explored.
    - `select_color_property()`: select column from data table for colorizing the data.
    &#34;&#34;&#34;
    
    def __init__(self, data, data_cols, wave_fish, eod_data,
                 add_waveforms, loaded_spec, rawdata_path):
        &#34;&#34;&#34;
        Parameters
        ----------
        data: TableData
            Full table of EOD properties. Each row is a fish.
        data_cols: list of string or ints
            Names or indices of columns in `data` to be explored.
            You may use the static function `select_EOD_properties()`
            for assisting the selection of columns.
        wave_fish: boolean
            True if data are about wave-type weakly electric fish.
            False if data are about pulse-type weakly electric fish.
        eod_data: list of waveform data
            Either waveform data is only the EOD waveform,
            a ndarray of shape (time, [&#39;time&#39;, &#39;voltage&#39;]), or
            it is a list with the first element being the EOD waveform,
            and the second element being a 2D ndarray of spectral properties
            of the EOD waveform with first column being the frequency or harmonics.
        add_waveforms: list of string
            List of what should be shown as waveform. Elements can be
            &#39;first&#39;, &#39;second&#39;, &#39;ampl&#39;, &#39;power&#39;, or &#39;phase&#39;. For &#39;first&#39; and &#39;second&#39;
            the first and second derivatives of the supplied EOD waveform a computed and shown.
            &#39;ampl&#39;, &#39;power&#39;, and &#39;phase&#39; select properties of the provided spectral properties.
        loaded_spec: boolean
            Indicates whether eod_data contains spectral properties.
        rawdata_path: string
            Base path to the raw recording, needed to show thunderfish
            when double clicking on a single EOD.
        &#34;&#34;&#34;
        self.wave_fish = wave_fish
        self.eoddata = data
        self.path = rawdata_path
        MultivariateExplorer.__init__(self, data[:,data_cols],
                                      None, &#39;EODExplorer&#39;)
        tunit = &#39;ms&#39;
        dunit = &#39;1/ms&#39;
        if wave_fish:
            tunit = &#39;1/EODf&#39;        
            dunit = &#39;EODf&#39;
        wave_data = eod_data
        xlabels = [&#39;Time [%s]&#39; % tunit]
        ylabels = [&#39;Voltage&#39;]
        if &#39;first&#39; in add_waveforms:
            # first derivative:
            if loaded_spec:
                if hasattr(sig, &#39;savgol_filter&#39;):
                    derivative = lambda x: (np.column_stack((x[0], \
                        sig.savgol_filter(x[0][:,1], 5, 2, 1, x[0][1,0]-x[0][0,0]))), x[1])
                else:
                    derivative = lambda x: (np.column_stack((x[0][:-1,:], \
                        np.diff(x[0][:,1])/(x[0][1,0]-x[0][0,0]))), x[1])
            else:
                if hasattr(sig, &#39;savgol_filter&#39;):
                    derivative = lambda x: np.column_stack((x, \
                        sig.savgol_filter(x[:,1], 5, 2, 1, x[1,0]-x[0,0])))
                else:
                    derivative = lambda x: np.column_stack((x[:-1,:], \
                        np.diff(x[:,1])/(x[1,0]-x[0,0])))
            wave_data = list(map(derivative, wave_data))
            ylabels.append(&#39;dV/dt [%s]&#39; % dunit)
            if &#39;second&#39; in add_waveforms:
                # second derivative:
                if loaded_spec:
                    if hasattr(sig, &#39;savgol_filter&#39;):
                        derivative = lambda x: (np.column_stack((x[0], \
                            sig.savgol_filter(x[0][:,1], 5, 2, 2, x[0][1,0]-x[0][0,0]))), x[1])
                    else:
                        derivative = lambda x: (np.column_stack((x[0][:-1,:], \
                            np.diff(x[0][:,2])/(x[0][1,0]-x[0][0,0]))), x[1])
                else:
                    if hasattr(sig, &#39;savgol_filter&#39;):
                        derivative = lambda x: np.column_stack((x, \
                            sig.savgol_filter(x[:,1], 5, 2, 2, x[1,0]-x[0,0])))
                    else:
                        derivative = lambda x: np.column_stack((x[:-1,:], \
                            np.diff(x[:,2])/(x[1,0]-x[0,0])))
                wave_data = list(map(derivative, wave_data))
                ylabels.append(&#39;d^2V/dt^2 [%s^2]&#39; % dunit)
        if loaded_spec:
            if wave_fish:
                indices = [0]
                phase = False
                xlabels.append(&#39;Harmonics&#39;)
                if &#39;ampl&#39; in add_waveforms:
                    indices.append(3)
                    ylabels.append(&#39;Ampl [%]&#39;)
                if &#39;power&#39; in add_waveforms:
                    indices.append(4)
                    ylabels.append(&#39;Power [dB]&#39;)
                if &#39;phase&#39; in add_waveforms:
                    indices.append(5)
                    ylabels.append(&#39;Phase&#39;)
                    phase = True
                def get_spectra(x):
                    y = x[1][:,indices]
                    if phase:
                        y[y[:,-1]&lt;0.0,-1] += 2.0*np.pi 
                    return (x[0], y)
                wave_data = list(map(get_spectra, wave_data))
            else:
                xlabels.append(&#39;Frequency [Hz]&#39;)
                ylabels.append(&#39;Power [dB]&#39;)
                def get_spectra(x):
                    y = x[1]
                    y[:,1] = decibel(y[:,1], None)
                    return (x[0], y)
                wave_data = list(map(get_spectra, wave_data))
        self.set_wave_data(wave_data, xlabels, ylabels, True)

        
    def fix_scatter_plot(self, ax, data, label, axis):
        &#34;&#34;&#34;Customize an axes of a scatter plot.

        - Limits for amplitude and time like quantities start at zero.
        - Phases a labeled with multuples of pi.
        - Species labels are rotated.
        &#34;&#34;&#34;
        if any(l in label for l in [&#39;ampl&#39;, &#39;power&#39;, &#39;width&#39;,
                                    &#39;time&#39;, &#39;tau&#39;, &#39;P2-P1-dist&#39;,
                                    &#39;var&#39;, &#39;peak&#39;, &#39;trough&#39;,
                                    &#39;dist&#39;, &#39;rms&#39;, &#39;noise&#39;]):
            if np.all(data[np.isfinite(data)] &gt;= 0.0):
                if axis == &#39;x&#39;:
                    ax.set_xlim(0.0, None)
                elif axis == &#39;y&#39;:
                    ax.set_ylim(0.0, None)
                elif axis == &#39;c&#39;:
                    return 0.0, np.max(data), None
            else:
                if axis == &#39;x&#39;:
                    ax.set_xlim(None, 0.0)
                elif axis == &#39;y&#39;:
                    ax.set_ylim(None, 0.0)
                elif axis == &#39;c&#39;:
                    return np.min(data), 0.0, None
        elif &#39;phase&#39; in label:
            if axis == &#39;x&#39;:
                ax.set_xlim(-np.pi, np.pi)
                ax.set_xticks(np.arange(-np.pi, 1.5*np.pi, 0.5*np.pi))
                ax.set_xticklabels([u&#39;-\u03c0&#39;, u&#39;-\u03c0/2&#39;, &#39;0&#39;, u&#39;\u03c0/2&#39;, u&#39;\u03c0&#39;])
            elif axis == &#39;y&#39;:
                ax.set_ylim(-np.pi, np.pi)
                ax.set_yticks(np.arange(-np.pi, 1.5*np.pi, 0.5*np.pi))
                ax.set_yticklabels([u&#39;-\u03c0&#39;, u&#39;-\u03c0/2&#39;, &#39;0&#39;, u&#39;\u03c0/2&#39;, u&#39;\u03c0&#39;])
            elif axis == &#39;c&#39;:
                if ax is not None:
                    ax.set_yticklabels([u&#39;-\u03c0&#39;, u&#39;-\u03c0/2&#39;, &#39;0&#39;, u&#39;\u03c0/2&#39;, u&#39;\u03c0&#39;])
                return -np.pi, np.pi, np.arange(-np.pi, 1.5*np.pi, 0.5*np.pi)
        elif &#39;species&#39; in label:
            if axis == &#39;x&#39;:
                for label in ax.get_xticklabels():
                    label.set_rotation(30)
                ax.set_xlabel(&#39;&#39;)
                ax.set_xlim(np.min(data)-0.5, np.max(data)+0.5)
            elif axis == &#39;y&#39;:
                ax.set_ylabel(&#39;&#39;)
                ax.set_ylim(np.min(data)-0.5, np.max(data)+0.5)
            elif axis == &#39;c&#39;:
                if ax is not None:
                    ax.set_ylabel(&#39;&#39;)
        return np.min(data), np.max(data), None

    
    def fix_waveform_plot(self, axs, indices):
        &#34;&#34;&#34;Adapt waveform plots to EOD waveforms, derivatives, and spectra.
        &#34;&#34;&#34;
        if len(indices) == 0:
            axs[0].text(0.5, 0.5, &#39;Click to plot EOD waveforms&#39;,
                        transform = axs[0].transAxes, ha=&#39;center&#39;, va=&#39;center&#39;)
            axs[0].text(0.5, 0.3, &#39;n = %d&#39; % len(self.raw_data),
                        transform = axs[0].transAxes, ha=&#39;center&#39;, va=&#39;center&#39;)
        elif len(indices) == 1:
            file_name = self.eoddata[indices[0],&#39;file&#39;] if &#39;file&#39; in self.eoddata else basename
            if &#39;index&#39; in self.eoddata and np.isfinite(self.eoddata[indices[0],&#39;index&#39;]) and \
              np.any(self.eoddata[:,&#39;index&#39;] != self.eoddata[0,&#39;index&#39;]):
                axs[0].set_title(&#39;%s: %d&#39; % (file_name,
                                             self.eoddata[indices[0],&#39;index&#39;]))
            else:
                axs[0].set_title(file_name)
            if np.isfinite(self.eoddata[indices[0],&#39;index&#39;]):
                axs[0].text(0.05, 0.85, &#39;%.1fHz&#39; % self.eoddata[indices[0],&#39;EODf&#39;],
                            transform = axs[0].transAxes)
        else:
            axs[0].set_title(&#39;%d EOD waveforms selected&#39; % len(indices))
        for ax in axs:
            for l in ax.lines:
                l.set_linewidth(3.0)
        for ax, xl in zip(axs, self.wave_ylabels):
            if &#39;Voltage&#39; in xl:
                ax.set_ylim(top=1.1)
                ax.yaxis.set_major_locator(ticker.MaxNLocator(nbins=4))
            if &#39;dV/dt&#39; in xl:
                ax.yaxis.set_major_locator(ticker.MaxNLocator(nbins=4))
            if &#39;d^2V/dt^2&#39; in xl:
                ax.yaxis.set_major_locator(ticker.MaxNLocator(nbins=4))
        if self.wave_fish:
            for ax, xl in zip(axs, self.wave_ylabels):
                if &#39;Voltage&#39; in xl:
                    ax.set_xlim(-0.7, 0.7)
                if &#39;Ampl&#39; in xl or &#39;Power&#39; in xl or &#39;Phase&#39; in xl:
                    ax.set_xlim(-0.5, 8.5)
                    for l in ax.lines:
                        l.set_marker(&#39;.&#39;)
                        l.set_markersize(15.0)
                        l.set_markeredgewidth(0.5)
                        l.set_markeredgecolor(&#39;k&#39;)
                        l.set_markerfacecolor(l.get_color())
                if &#39;Ampl&#39; in xl:
                    ax.set_ylim(0.0, 100.0)
                    ax.yaxis.set_major_locator(ticker.MultipleLocator(25.0))
                if &#39;Power&#39; in xl:
                    ax.set_ylim(-60.0, 2.0)
                    ax.yaxis.set_major_locator(ticker.MultipleLocator(20.0))
                if &#39;Phase&#39; in xl:
                    ax.set_ylim(0.0, 2.0*np.pi)
                    ax.set_yticks(np.arange(0.0, 2.5*np.pi, 0.5*np.pi))
                    ax.set_yticklabels([&#39;0&#39;, u&#39;\u03c0/2&#39;, u&#39;\u03c0&#39;, u&#39;3\u03c0/2&#39;, u&#39;2\u03c0&#39;])
        else:
            for ax, xl in zip(axs, self.wave_ylabels):
                if &#39;Voltage&#39; in xl:
                    ax.set_xlim(-1.0, 1.5)
                if &#39;Power&#39; in xl:
                    ax.set_xlim(1.0, 2000.0)
                    ax.set_xscale(&#39;log&#39;)
                    ax.set_ylim(-60.0, 2.0)
                    ax.yaxis.set_major_locator(ticker.MultipleLocator(20.0))
        if len(indices) &gt; 0:
            for ax in axs:
                ax.axhline(c=&#39;k&#39;, lw=1)

            
    def list_selection(self, indices):
        &#34;&#34;&#34;List file names and indices of selection.

        If only a single EOD is selected, list all of its properties.
        &#34;&#34;&#34;
        if &#39;index&#39; in self.eoddata and \
           np.any(self.eoddata[:,&#39;index&#39;] != self.eoddata[0,&#39;index&#39;]):
            for i in indices:
                file_name = self.eoddata[i,&#39;file&#39;] if &#39;file&#39; in self.eoddata else basename
                if np.isfinite(self.eoddata[i,&#39;index&#39;]):
                    print(&#39;%s : %d&#39; % (file_name, self.eoddata[i,&#39;index&#39;]))
                else:
                    print(file_name)
        elif &#39;file&#39; in self.eoddata:
            for i in indices:
                print(self.eoddata[i,&#39;file&#39;])
        if len(indices) == 1:
            # write eoddata line on terminal:
            keylen = 0
            keys = []
            values = []
            for c in range(self.eoddata.columns()):
                k, v = self.eoddata.key_value(indices[0], c)
                keys.append(k)
                values.append(v)
                if keylen &lt; len(k):
                    keylen = len(k)
            for k, v in zip(keys, values):
                fs = &#39;%%-%ds: %%s&#39; % keylen
                print(fs % (k, v.strip()))

                
    def analyze_selection(self, index):
        &#34;&#34;&#34;Launch thunderfish on the selected EOD.
        &#34;&#34;&#34;
        # load data:
        file_base = self.eoddata[index,&#39;file&#39;] if &#39;file&#39; in self.eoddata else basename
        bp = os.path.join(self.path, file_base)
        fn = glob.glob(bp + &#39;.*&#39;)
        if len(fn) == 0:
            print(&#39;no recording found for %s&#39; % bp)
            return
        recording = fn[0]
        channel = 0
        try:
            raw_data, samplerate, unit = load_data(recording, channel)
        except IOError as e:
            print(&#39;%s: failed to open file: did you provide a path to the raw data (-P option)?&#39; % (recording))
            return
        if len(raw_data) &lt;= 1:
            print(&#39;%s: empty data file&#39; % recording)
            return
        # load configuration:
        cfgfile = __package__ + &#39;.cfg&#39;
        cfg = configuration(cfgfile, False, recording)
        cfg.load_files(cfgfile, recording, 4)
        if &#39;flipped&#39; in self.eoddata:
            fs = &#39;flip&#39; if self.eoddata[index,&#39;flipped&#39;] else &#39;none&#39;
            cfg.set(&#39;flipWaveEOD&#39;, fs)
            cfg.set(&#39;flipPulseEOD&#39;, fs)
        # best_window:
        data, idx0, idx1, clipped, min_clip, max_clip = analysis_window(raw_data, samplerate, cfg.value(&#39;windowPosition&#39;), cfg)
        # detect EODs in the data:
        psd_data, fishlist, _, eod_props, mean_eods, \
          spec_data, peak_data, power_thresh, skip_reason, zoom_window = \
          detect_eods(data, samplerate, min_clip, max_clip, recording, 0, 0, cfg)
        # plot EOD:
        idx = int(self.eoddata[index,&#39;index&#39;]) if &#39;index&#39; in self.eoddata else 0
        for k in [&#39;toolbar&#39;, &#39;keymap.back&#39;, &#39;keymap.forward&#39;,
                  &#39;keymap.zoom&#39;, &#39;keymap.pan&#39;]:
            plt.rcParams[k] = self.plt_params[k]
        fig = plot_eods(file_base, raw_data, samplerate, None, idx0, idx1,
                        clipped, psd_data[0], fishlist, None,
                        mean_eods, eod_props, peak_data, spec_data,
                        [idx], unit, zoom_window, 10, None, True, False,
                        &#39;auto&#39;, False, 0.0, 3000.0,
                        interactive=True, verbose=0)
        fig.canvas.set_window_title(&#39;thunderfish: %s&#39; % file_base)
        plt.show(block=False)


    &#34;&#34;&#34;Names of groups of data columns that can be selected by the select_EOD_properties() function.
    &#34;&#34;&#34;
    groups = [&#39;all&#39;, &#39;allpower&#39;, &#39;noise&#39;, &#39;timing&#39;,
              &#39;ampl&#39;, &#39;relampl&#39;, &#39;power&#39;, &#39;relpower&#39;, &#39;phase&#39;,
              &#39;time&#39;, &#39;width&#39;, &#39;peaks&#39;, &#39;none&#39;]
    
    @staticmethod
    def select_EOD_properties(data, wave_fish, max_n, column_groups, add_columns):
        &#34;&#34;&#34;Select data columns to be explored.

        First, groups of columns are selected, then individual
        columns. Columns that are selected twice are removed from the
        selection.

        Parameters
        ----------
        data: TableData
            Table with EOD properties from which columns are selected.
        wave_fish: boolean.
            Indicates if data contains properties of wave- or pulse-type electric fish.
        max_n: int
            Maximum number of harmonics (wae-type fish) or peaks (pulse-type fish)
            to be  selected.
        column_groups: list of string
            List of name denoting groups of columns to be selected. Supported groups are
            listed in `EODExplor.groups`.
        add_columns: list of string or int
            List of further individual columns to be selected.

        Returns
        -------
        data_cols: list of int
            Indices of data columns to be shown by EODExplorer.
        error: string
            In case of an invalid column group, an error string.
        &#34;&#34;&#34;
        if wave_fish:
            # maximum number of harmonics:
            if max_n == 0:
                max_n = 100
            else:
                max_n += 1
            for k in range(1, max_n):
                if not (&#39;phase%d&#39; % k) in data:
                    max_n = k
                    break
        else:
            # minimum number of peaks:
            min_peaks = -10
            for k in range(1, min_peaks, -1):
                if not (&#39;P%dampl&#39; % k) in data or not np.all(np.isfinite(data[:,&#39;P%dampl&#39; % k])):
                    min_peaks = k+1
                    break
            # maximum number of peaks:
            if max_n == 0:
                max_peaks = 20
            else:
                max_peaks = max_n + 1
            for k in range(1, max_peaks):
                if not (&#39;P%dampl&#39; % k) in data or not np.all(np.isfinite(data[:,&#39;P%dampl&#39; % k])):
                    max_peaks = k
                    break

        # default columns:
        group_cols = [&#39;EODf&#39;]
        if &#39;EODf_adjust&#39; in data:
            group_cols.append(&#39;EODf_adjust&#39;)
        if len(column_groups) == 0:
            column_groups = [&#39;all&#39;]
        for group in column_groups:
            if group == &#39;none&#39;:
                group_cols = []
            elif wave_fish:
                if group == &#39;noise&#39;:
                    group_cols.extend([&#39;noise&#39;, &#39;rmserror&#39;, &#39;power&#39;, &#39;thd&#39;,
                                       &#39;dbdiff&#39;, &#39;maxdb&#39;, &#39;p-p-amplitude&#39;,
                                       &#39;relampl1&#39;, &#39;relampl2&#39;, &#39;relampl3&#39;])
                elif group == &#39;timing&#39; or group == &#39;time&#39;:
                    group_cols.extend([&#39;peakwidth&#39;, &#39;troughwidth&#39;, &#39;p-p-distance&#39;,
                                       &#39;leftpeak&#39;, &#39;rightpeak&#39;, &#39;lefttrough&#39;, &#39;righttrough&#39;])
                elif group == &#39;ampl&#39;:
                    for k in range(0, max_n):
                        group_cols.append(&#39;ampl%d&#39; % k)
                elif group == &#39;relampl&#39;:
                    group_cols.append(&#39;thd&#39;)
                    group_cols.append(&#39;reltroughampl&#39;)
                    for k in range(1, max_n):
                        group_cols.append(&#39;relampl%d&#39; % k)
                elif group == &#39;relpower&#39; or group == &#39;power&#39;:
                    for k in range(1, max_n):
                        group_cols.append(&#39;relpower%d&#39; % k)
                elif group == &#39;phase&#39;:
                    for k in range(0, max_n):
                        group_cols.append(&#39;phase%d&#39; % k)
                elif group == &#39;all&#39;:
                    group_cols.append(&#39;thd&#39;)
                    group_cols.append(&#39;reltroughampl&#39;)
                    for k in range(1, max_n):
                        group_cols.append(&#39;relampl%d&#39; % k)
                        group_cols.append(&#39;phase%d&#39; % k)
                elif group == &#39;allpower&#39;:
                    group_cols.append(&#39;thd&#39;)
                    for k in range(1, max_n):
                        group_cols.append(&#39;relpower%d&#39; % k)
                        group_cols.append(&#39;phase%d&#39; % k)
                else:
                    return None, &#39;&#34;%s&#34; is not a valid data group for wavefish&#39; % group
            else:  # pulse fish
                if group == &#39;noise&#39;:
                    group_cols.extend([&#39;noise&#39;, &#39;p-p-amplitude&#39;, &#39;min-ampl&#39;, &#39;max-ampl&#39;])
                elif group == &#39;timing&#39;:
                    group_cols.extend([&#39;tstart&#39;, &#39;tend&#39;, &#39;width&#39;, &#39;tau&#39;, &#39;P2-P1-dist&#39;, &#39;firstpeak&#39;, &#39;lastpeak&#39;])
                elif group == &#39;power&#39;:
                    group_cols.extend([&#39;peakfreq&#39;, &#39;peakpower&#39;, &#39;poweratt5&#39;, &#39;poweratt50&#39;, &#39;lowcutoff&#39;])
                elif group == &#39;time&#39;:
                    for k in range(min_peaks, max_peaks):
                        if k != 1:
                            group_cols.append(&#39;P%dtime&#39; % k)
                elif group == &#39;ampl&#39;:
                    for k in range(min_peaks, max_peaks):
                        group_cols.append(&#39;P%dampl&#39; % k)
                elif group == &#39;relampl&#39;:
                    for k in range(min_peaks, max_peaks):
                        if k != 1:
                            group_cols.append(&#39;P%drelampl&#39; % k)
                elif group == &#39;width&#39;:
                    for k in range(min_peaks, max_peaks):
                        group_cols.append(&#39;P%dwidth&#39; % k)
                elif group == &#39;peaks&#39;:
                    group_cols.append(&#39;firstpeak&#39;)
                    group_cols.append(&#39;lastpeak&#39;)
                elif group == &#39;all&#39;:
                    group_cols.extend([&#39;firstpeak&#39;, &#39;lastpeak&#39;])
                    for k in range(min_peaks, max_peaks):
                        if k != 1:
                            group_cols.append(&#39;P%drelampl&#39; % k)
                            group_cols.append(&#39;P%dtime&#39; % k)
                        group_cols.append(&#39;P%dwidth&#39; % k)
                    group_cols.extend([&#39;tau&#39;, &#39;P2-P1-dist&#39;, &#39;peakfreq&#39;, &#39;poweratt5&#39;])
                else:
                    return None, &#39;&#34;%s&#34; is not a valid data group for pulsefish&#39; % group
        # additional data columns:
        group_cols.extend(add_columns)
        # translate to indices:
        data_cols = []
        for c in group_cols:
            idx = data.index(c)
            if idx is None:
                print(&#39;&#34;%s&#34; is not a valid data column&#39; % c)
            elif idx in data_cols:
                data_cols.remove(idx)
            else:
                data_cols.append(idx)
        return data_cols, None

    
    @staticmethod
    def select_color_property(data, data_cols, color_col):
        &#34;&#34;&#34;Select column from data table for colorizing the data.

        Pass the output of this function on to MultivariateExplorer.set_colors().

        Parameters
        ----------
        data: TableData
            Table with all EOD properties from which columns are selected.
        data_cols: list of int
            List of columns selected to be explored.
        color_col: string or int
            Column to be selected for coloring the data.
            If &#39;row&#39; then use the row index of the data in the table for coloring.

        Returns
        -------
        colors: int or column from data.
            Either index of `data_cols` or additional data from the data table
            to be used for coloring.
        color_label: string
            Label for labeling the color bar.
        color_idx: int or None
            Index of column in `data`.
        error: string
            In case an invalid column is selected, an error string.
        &#34;&#34;&#34;
        color_idx = data.index(color_col)
        colors = None
        color_label = None
        if color_idx is None and color_col != &#39;row&#39;:
            return None, None, None, &#39;&#34;%s&#34; is not a valid column for color code&#39; % color_col
        if color_idx is None:
            colors = -2
        elif color_idx in data_cols:
            colors = data_cols.index(color_idx)
        else:
            if len(data.unit(color_idx)) &gt; 0 and not data.unit(color_idx) in [&#39;-&#39;, &#39;1&#39;]:
                color_label = &#39;%s [%s]&#39; % (data.label(color_idx), data.unit(color_idx))
            else:
                color_label = data.label(color_idx)
            colors = data[:,color_idx]
        return colors, color_label, color_idx, None


class PrintHelp(argparse.Action):
    def __call__(self, parser, namespace, values, option_string):
        parser.print_help()
        print(&#39;&#39;)
        print(&#39;mouse:&#39;)
        for ma in MultivariateExplorer.mouse_actions:
            print(&#39;%-23s %s&#39; % ma)
        print(&#39;%-23s %s&#39; % (&#39;double left click&#39;, &#39;run thunderfish on selected EOD waveform&#39;))
        print(&#39;&#39;)
        print(&#39;key shortcuts:&#39;)
        for ka in MultivariateExplorer.key_actions:
            print(&#39;%-23s %s&#39; % ka)
        parser.exit()      

        
wave_fish = True
load_spec = False
data = None
data_path = None

def load_waveform(idx):
    eodf = data[idx,&#39;EODf&#39;]
    if not np.isfinite(eodf):
        if load_spec:
            return None, None
        else:
            return None
    file_name = data[idx,&#39;file&#39;] if &#39;file&#39; in data else &#39;-&#39;.join(basename.split(&#39;-&#39;)[:-1])
    file_index = data[idx,&#39;index&#39;] if &#39;index&#39; in data else 0
    eod_filename = os.path.join(data_path, &#39;%s-eodwaveform-%d.csv&#39; % (file_name, file_index))
    eod_table = TableData(eod_filename)
    eod = eod_table[:,&#39;mean&#39;]
    norm = np.max(eod)
    if wave_fish:
        eod = np.column_stack((eod_table[:,&#39;time&#39;]*0.001*eodf, eod/norm))
    else:
        eod = np.column_stack((eod_table[:,&#39;time&#39;], eod/norm))
    if not load_spec:
        return eod
    fish_type = &#39;wave&#39; if wave_fish else &#39;pulse&#39;
    spec_table = TableData(os.path.join(data_path, &#39;%s-%sspectrum-%d.csv&#39; % (file_name, fish_type, file_index)))
    spec_data = spec_table.array()
    if not wave_fish:
        spec_data = spec_data[spec_data[:,0]&lt;2000.0,:]
        spec_data = spec_data[::5,:]
    return (eod, spec_data)
        

def main(cargs=None):
    global data
    global wave_fish
    global load_spec
    global data_path
    global basename

    # command line arguments:
    if cargs is None:
        cargs = sys.argv[1:]
    parser = argparse.ArgumentParser(add_help=False,
        description=&#39;View and explore properties of EOD waveforms.&#39;,
        epilog=&#39;version %s by Benda-Lab (2019-%s)&#39; % (__version__, __year__))
    parser.add_argument(&#39;-h&#39;, &#39;--help&#39;, nargs=0, action=PrintHelp,
                        help=&#39;show this help message and exit&#39;)
    parser.add_argument(&#39;--version&#39;, action=&#39;version&#39;, version=__version__)
    parser.add_argument(&#39;-v&#39;, dest=&#39;verbose&#39;, action=&#39;store_true&#39;, default=False,
                        help=&#39;verbose output&#39;)
    parser.add_argument(&#39;-l&#39;, dest=&#39;list_columns&#39;, action=&#39;store_true&#39;,
                        help=&#39;list all available data columns and exit&#39;)
    parser.add_argument(&#39;-j&#39;, dest=&#39;jobs&#39;, nargs=&#39;?&#39;, type=int, default=None, const=0,
                        help=&#39;number of jobs run in parallel for loading waveform data. Without argument use all CPU cores.&#39;)
    parser.add_argument(&#39;-D&#39;, dest=&#39;column_groups&#39;, default=[], type=str, action=&#39;append&#39;,
                        choices=EODExplorer.groups,
                        help=&#39;default selection of data columns, check them with the -l option&#39;)
    parser.add_argument(&#39;-d&#39;, dest=&#39;add_data_cols&#39;, action=&#39;append&#39;, default=[], metavar=&#39;COLUMN&#39;,
                        help=&#39;data columns to be appended or removed (if already listed) for analysis&#39;)
    parser.add_argument(&#39;-n&#39;, dest=&#39;max_n&#39;, default=0, type=int, metavar=&#39;MAX&#39;,
                        help=&#39;maximum number of harmonics or peaks to be used&#39;)
    parser.add_argument(&#39;-w&#39;, dest=&#39;add_waveforms&#39;, default=[], type=str, action=&#39;append&#39;,
                        choices=[&#39;first&#39;, &#39;second&#39;, &#39;ampl&#39;, &#39;power&#39;, &#39;phase&#39;],
                        help=&#39;add first or second derivative of EOD waveform, or relative amplitude, power, or phase to the plot of selected EODs.&#39;)
    parser.add_argument(&#39;-s&#39;, dest=&#39;save_pca&#39;, action=&#39;store_true&#39;,
                        help=&#39;save PCA components and exit&#39;)
    parser.add_argument(&#39;-c&#39;, dest=&#39;color_col&#39;, default=&#39;EODf&#39;, type=str, metavar=&#39;COLUMN&#39;,
                        help=&#39;data column to be used for color code or &#34;row&#34;&#39;)
    parser.add_argument(&#39;-m&#39;, dest=&#39;color_map&#39;, default=&#39;jet&#39;, type=str, metavar=&#39;CMAP&#39;,
                        help=&#39;name of color map&#39;)
    parser.add_argument(&#39;-p&#39;, dest=&#39;data_path&#39;, default=&#39;.&#39;, type=str, metavar=&#39;PATH&#39;,
                        help=&#39;path to the analyzed EOD waveform data&#39;)
    parser.add_argument(&#39;-P&#39;, dest=&#39;rawdata_path&#39;, default=&#39;.&#39;, type=str, metavar=&#39;PATH&#39;,
                        help=&#39;path to the raw EOD recordings&#39;)
    parser.add_argument(&#39;-f&#39;, dest=&#39;format&#39;, default=&#39;auto&#39;, type=str,
                        choices=TableData.formats + [&#39;same&#39;],
                        help=&#39;file format used for saving PCA data (&#34;same&#34; uses same format as input file)&#39;)
    parser.add_argument(&#39;file&#39;, default=&#39;&#39;, type=str,
                        help=&#39;a wavefish.* or pulsefish.* summary file as generated by collectfish&#39;)
    args = parser.parse_args(cargs)
        
    # read in command line arguments:    
    verbose = args.verbose
    list_columns = args.list_columns
    jobs = args.jobs
    file_name = args.file
    column_groups = args.column_groups
    add_data_cols = args.add_data_cols
    max_n = args.max_n
    add_waveforms = args.add_waveforms
    save_pca = args.save_pca
    color_col = args.color_col
    color_map = args.color_map
    data_path = args.data_path
    rawdata_path = args.rawdata_path
    data_format = args.format
    
    # read configuration:
    cfgfile = __package__ + &#39;.cfg&#39;
    cfg = ConfigFile()
    add_eod_quality_config(cfg)
    add_harmonic_groups_config(cfg)
    add_species_config(cfg)
    add_write_table_config(cfg, table_format=&#39;csv&#39;, unit_style=&#39;row&#39;,
                           align_columns=True, shrink_width=False)
    cfg.load_files(cfgfile, file_name, 4)
    
    # output format:
    if data_format == &#39;same&#39;:
        ext = os.path.splitext(file_name)[1][1:]
        if ext in TableData.ext_formats:
            data_format = TableData.ext_formats[ext]
        else:
            data_format = &#39;dat&#39;
    if data_format != &#39;auto&#39;:
        cfg.set(&#39;fileFormat&#39;, data_format)

    # check color map:
    if not color_map in plt.colormaps():
        parser.error(&#39;&#34;%s&#34; is not a valid color map&#39; % color_map)
        
    # load summary data:
    wave_fish = &#39;wave&#39; in file_name
    data = TableData(file_name)

    # basename:
    basename = os.path.splitext(os.path.basename(file_name))[0]
    
    # check quality:
    skipped = 0
    for r in reversed(range(data.rows())):
        idx = 0
        if &#39;index&#39; in data:
            idx = data[r,&#39;index&#39;]
        skips = &#39;&#39;
        if wave_fish:
            harm_rampl = np.array([0.01*data[r,&#39;relampl%d&#39;%(k+1)] for k in range(3)
                                   if &#39;relampl%d&#39;%(k+1) in data])
            props = data.row_dict(r)
            if &#39;clipped&#39; in props:
                props[&#39;clipped&#39;] *= 0.01 
            if &#39;noise&#39; in props:
                props[&#39;noise&#39;] *= 0.01 
            if &#39;rmserror&#39; in props:
                props[&#39;rmserror&#39;] *= 0.01
            if &#39;thd&#39; in props:
                props[&#39;thd&#39;] *= 0.01 
            _, skips, msg = wave_quality(props, harm_rampl, **wave_quality_args(cfg))
        else:
            props = data.row_dict(r)
            if &#39;clipped&#39; in props:
                props[&#39;clipped&#39;] *= 0.01 
            if &#39;noise&#39; in props:
                props[&#39;noise&#39;] *= 0.01 
            skips, msg, _ = pulse_quality(props, **pulse_quality_args(cfg))
        if len(skips) &gt; 0:
            if verbose:
                print(&#39;skip fish %2d from %s: %s&#39; % (idx, data[r,&#39;file&#39;] if &#39;file&#39; in data else basename, skips))
            del data[r,:]
            skipped += 1
    if verbose and skipped &gt; 0:
        print(&#39;&#39;)

    # select columns (EOD properties) to be shown:
    data_cols, error = \
      EODExplorer.select_EOD_properties(data, wave_fish, max_n,
                                        column_groups, add_data_cols)
    if error:
        parser.error(error)

    # select column used for coloring the data:
    colors, color_label, color_idx, error = \
      EODExplorer.select_color_property(data, data_cols, color_col)
    if error:
        parser.error(error)

    # list columns:
    if list_columns:
        for k, c in enumerate(data.keys()):
            s = [&#39; &#39;] * 3
            if k in data_cols:
                s[1] = &#39;*&#39;
            if color_idx is not None and k == color_idx:
                s[0] = &#39;C&#39;
            print(&#39;&#39;.join(s) + c)
        parser.exit()

    # load waveforms:
    load_spec = &#39;ampl&#39; in add_waveforms or &#39;power&#39; in add_waveforms or &#39;phase&#39; in add_waveforms
    if jobs is not None:
        cpus = cpu_count() if jobs == 0 else jobs
        p = Pool(cpus)
        eod_data = p.map(load_waveform, range(data.rows()))
        del p
    else:
        eod_data = list(map(load_waveform, range(data.rows())))

    # explore:
    eod_expl = EODExplorer(data, data_cols, wave_fish, eod_data,
                           add_waveforms, load_spec, rawdata_path)
    # write pca:
    if save_pca:
        eod_expl.compute_pca(False)
        eod_expl.save_pca(basename, False, **write_table_args(cfg))
        eod_expl.compute_pca(True)
        eod_expl.save_pca(basename, True, **write_table_args(cfg))
    else:
        eod_expl.set_colors(colors, color_label, color_map)
        eod_expl.show()


if __name__ == &#39;__main__&#39;:
    freeze_support()  # needed by multiprocessing for some weired windows stuff
    main()</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="thunderfish.eodexplorer.load_waveform"><code class="name flex">
<span>def <span class="ident">load_waveform</span></span>(<span>idx)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def load_waveform(idx):
    eodf = data[idx,&#39;EODf&#39;]
    if not np.isfinite(eodf):
        if load_spec:
            return None, None
        else:
            return None
    file_name = data[idx,&#39;file&#39;] if &#39;file&#39; in data else &#39;-&#39;.join(basename.split(&#39;-&#39;)[:-1])
    file_index = data[idx,&#39;index&#39;] if &#39;index&#39; in data else 0
    eod_filename = os.path.join(data_path, &#39;%s-eodwaveform-%d.csv&#39; % (file_name, file_index))
    eod_table = TableData(eod_filename)
    eod = eod_table[:,&#39;mean&#39;]
    norm = np.max(eod)
    if wave_fish:
        eod = np.column_stack((eod_table[:,&#39;time&#39;]*0.001*eodf, eod/norm))
    else:
        eod = np.column_stack((eod_table[:,&#39;time&#39;], eod/norm))
    if not load_spec:
        return eod
    fish_type = &#39;wave&#39; if wave_fish else &#39;pulse&#39;
    spec_table = TableData(os.path.join(data_path, &#39;%s-%sspectrum-%d.csv&#39; % (file_name, fish_type, file_index)))
    spec_data = spec_table.array()
    if not wave_fish:
        spec_data = spec_data[spec_data[:,0]&lt;2000.0,:]
        spec_data = spec_data[::5,:]
    return (eod, spec_data)</code></pre>
</details>
</dd>
<dt id="thunderfish.eodexplorer.main"><code class="name flex">
<span>def <span class="ident">main</span></span>(<span>cargs=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def main(cargs=None):
    global data
    global wave_fish
    global load_spec
    global data_path
    global basename

    # command line arguments:
    if cargs is None:
        cargs = sys.argv[1:]
    parser = argparse.ArgumentParser(add_help=False,
        description=&#39;View and explore properties of EOD waveforms.&#39;,
        epilog=&#39;version %s by Benda-Lab (2019-%s)&#39; % (__version__, __year__))
    parser.add_argument(&#39;-h&#39;, &#39;--help&#39;, nargs=0, action=PrintHelp,
                        help=&#39;show this help message and exit&#39;)
    parser.add_argument(&#39;--version&#39;, action=&#39;version&#39;, version=__version__)
    parser.add_argument(&#39;-v&#39;, dest=&#39;verbose&#39;, action=&#39;store_true&#39;, default=False,
                        help=&#39;verbose output&#39;)
    parser.add_argument(&#39;-l&#39;, dest=&#39;list_columns&#39;, action=&#39;store_true&#39;,
                        help=&#39;list all available data columns and exit&#39;)
    parser.add_argument(&#39;-j&#39;, dest=&#39;jobs&#39;, nargs=&#39;?&#39;, type=int, default=None, const=0,
                        help=&#39;number of jobs run in parallel for loading waveform data. Without argument use all CPU cores.&#39;)
    parser.add_argument(&#39;-D&#39;, dest=&#39;column_groups&#39;, default=[], type=str, action=&#39;append&#39;,
                        choices=EODExplorer.groups,
                        help=&#39;default selection of data columns, check them with the -l option&#39;)
    parser.add_argument(&#39;-d&#39;, dest=&#39;add_data_cols&#39;, action=&#39;append&#39;, default=[], metavar=&#39;COLUMN&#39;,
                        help=&#39;data columns to be appended or removed (if already listed) for analysis&#39;)
    parser.add_argument(&#39;-n&#39;, dest=&#39;max_n&#39;, default=0, type=int, metavar=&#39;MAX&#39;,
                        help=&#39;maximum number of harmonics or peaks to be used&#39;)
    parser.add_argument(&#39;-w&#39;, dest=&#39;add_waveforms&#39;, default=[], type=str, action=&#39;append&#39;,
                        choices=[&#39;first&#39;, &#39;second&#39;, &#39;ampl&#39;, &#39;power&#39;, &#39;phase&#39;],
                        help=&#39;add first or second derivative of EOD waveform, or relative amplitude, power, or phase to the plot of selected EODs.&#39;)
    parser.add_argument(&#39;-s&#39;, dest=&#39;save_pca&#39;, action=&#39;store_true&#39;,
                        help=&#39;save PCA components and exit&#39;)
    parser.add_argument(&#39;-c&#39;, dest=&#39;color_col&#39;, default=&#39;EODf&#39;, type=str, metavar=&#39;COLUMN&#39;,
                        help=&#39;data column to be used for color code or &#34;row&#34;&#39;)
    parser.add_argument(&#39;-m&#39;, dest=&#39;color_map&#39;, default=&#39;jet&#39;, type=str, metavar=&#39;CMAP&#39;,
                        help=&#39;name of color map&#39;)
    parser.add_argument(&#39;-p&#39;, dest=&#39;data_path&#39;, default=&#39;.&#39;, type=str, metavar=&#39;PATH&#39;,
                        help=&#39;path to the analyzed EOD waveform data&#39;)
    parser.add_argument(&#39;-P&#39;, dest=&#39;rawdata_path&#39;, default=&#39;.&#39;, type=str, metavar=&#39;PATH&#39;,
                        help=&#39;path to the raw EOD recordings&#39;)
    parser.add_argument(&#39;-f&#39;, dest=&#39;format&#39;, default=&#39;auto&#39;, type=str,
                        choices=TableData.formats + [&#39;same&#39;],
                        help=&#39;file format used for saving PCA data (&#34;same&#34; uses same format as input file)&#39;)
    parser.add_argument(&#39;file&#39;, default=&#39;&#39;, type=str,
                        help=&#39;a wavefish.* or pulsefish.* summary file as generated by collectfish&#39;)
    args = parser.parse_args(cargs)
        
    # read in command line arguments:    
    verbose = args.verbose
    list_columns = args.list_columns
    jobs = args.jobs
    file_name = args.file
    column_groups = args.column_groups
    add_data_cols = args.add_data_cols
    max_n = args.max_n
    add_waveforms = args.add_waveforms
    save_pca = args.save_pca
    color_col = args.color_col
    color_map = args.color_map
    data_path = args.data_path
    rawdata_path = args.rawdata_path
    data_format = args.format
    
    # read configuration:
    cfgfile = __package__ + &#39;.cfg&#39;
    cfg = ConfigFile()
    add_eod_quality_config(cfg)
    add_harmonic_groups_config(cfg)
    add_species_config(cfg)
    add_write_table_config(cfg, table_format=&#39;csv&#39;, unit_style=&#39;row&#39;,
                           align_columns=True, shrink_width=False)
    cfg.load_files(cfgfile, file_name, 4)
    
    # output format:
    if data_format == &#39;same&#39;:
        ext = os.path.splitext(file_name)[1][1:]
        if ext in TableData.ext_formats:
            data_format = TableData.ext_formats[ext]
        else:
            data_format = &#39;dat&#39;
    if data_format != &#39;auto&#39;:
        cfg.set(&#39;fileFormat&#39;, data_format)

    # check color map:
    if not color_map in plt.colormaps():
        parser.error(&#39;&#34;%s&#34; is not a valid color map&#39; % color_map)
        
    # load summary data:
    wave_fish = &#39;wave&#39; in file_name
    data = TableData(file_name)

    # basename:
    basename = os.path.splitext(os.path.basename(file_name))[0]
    
    # check quality:
    skipped = 0
    for r in reversed(range(data.rows())):
        idx = 0
        if &#39;index&#39; in data:
            idx = data[r,&#39;index&#39;]
        skips = &#39;&#39;
        if wave_fish:
            harm_rampl = np.array([0.01*data[r,&#39;relampl%d&#39;%(k+1)] for k in range(3)
                                   if &#39;relampl%d&#39;%(k+1) in data])
            props = data.row_dict(r)
            if &#39;clipped&#39; in props:
                props[&#39;clipped&#39;] *= 0.01 
            if &#39;noise&#39; in props:
                props[&#39;noise&#39;] *= 0.01 
            if &#39;rmserror&#39; in props:
                props[&#39;rmserror&#39;] *= 0.01
            if &#39;thd&#39; in props:
                props[&#39;thd&#39;] *= 0.01 
            _, skips, msg = wave_quality(props, harm_rampl, **wave_quality_args(cfg))
        else:
            props = data.row_dict(r)
            if &#39;clipped&#39; in props:
                props[&#39;clipped&#39;] *= 0.01 
            if &#39;noise&#39; in props:
                props[&#39;noise&#39;] *= 0.01 
            skips, msg, _ = pulse_quality(props, **pulse_quality_args(cfg))
        if len(skips) &gt; 0:
            if verbose:
                print(&#39;skip fish %2d from %s: %s&#39; % (idx, data[r,&#39;file&#39;] if &#39;file&#39; in data else basename, skips))
            del data[r,:]
            skipped += 1
    if verbose and skipped &gt; 0:
        print(&#39;&#39;)

    # select columns (EOD properties) to be shown:
    data_cols, error = \
      EODExplorer.select_EOD_properties(data, wave_fish, max_n,
                                        column_groups, add_data_cols)
    if error:
        parser.error(error)

    # select column used for coloring the data:
    colors, color_label, color_idx, error = \
      EODExplorer.select_color_property(data, data_cols, color_col)
    if error:
        parser.error(error)

    # list columns:
    if list_columns:
        for k, c in enumerate(data.keys()):
            s = [&#39; &#39;] * 3
            if k in data_cols:
                s[1] = &#39;*&#39;
            if color_idx is not None and k == color_idx:
                s[0] = &#39;C&#39;
            print(&#39;&#39;.join(s) + c)
        parser.exit()

    # load waveforms:
    load_spec = &#39;ampl&#39; in add_waveforms or &#39;power&#39; in add_waveforms or &#39;phase&#39; in add_waveforms
    if jobs is not None:
        cpus = cpu_count() if jobs == 0 else jobs
        p = Pool(cpus)
        eod_data = p.map(load_waveform, range(data.rows()))
        del p
    else:
        eod_data = list(map(load_waveform, range(data.rows())))

    # explore:
    eod_expl = EODExplorer(data, data_cols, wave_fish, eod_data,
                           add_waveforms, load_spec, rawdata_path)
    # write pca:
    if save_pca:
        eod_expl.compute_pca(False)
        eod_expl.save_pca(basename, False, **write_table_args(cfg))
        eod_expl.compute_pca(True)
        eod_expl.save_pca(basename, True, **write_table_args(cfg))
    else:
        eod_expl.set_colors(colors, color_label, color_map)
        eod_expl.show()</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="thunderfish.eodexplorer.EODExplorer"><code class="flex name class">
<span>class <span class="ident">EODExplorer</span></span>
<span>(</span><span>data, data_cols, wave_fish, eod_data, add_waveforms, loaded_spec, rawdata_path)</span>
</code></dt>
<dd>
<div class="desc"><p>Simple GUI for viewing and exploring properties of EOD waveforms.</p>
<p>EODExplorer adapts a MultivariateExplorer to specific needs of EODs.</p>
<h2 id="static-members">Static Members</h2>
<ul>
<li><code>groups</code>: names of groups of data columns that can be selected.</li>
<li><code>select_EOD_properties()</code>: select data columns to be explored.</li>
<li><code>select_color_property()</code>: select column from data table for colorizing the data.</li>
</ul>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>data</code></strong> :&ensp;<code>TableData</code></dt>
<dd>Full table of EOD properties. Each row is a fish.</dd>
<dt><strong><code>data_cols</code></strong> :&ensp;<code>list</code> of <code>string</code> or <code>ints</code></dt>
<dd>Names or indices of columns in <code>data</code> to be explored.
You may use the static function <code>select_EOD_properties()</code>
for assisting the selection of columns.</dd>
<dt><strong><code>wave_fish</code></strong> :&ensp;<code>boolean</code></dt>
<dd>True if data are about wave-type weakly electric fish.
False if data are about pulse-type weakly electric fish.</dd>
<dt><strong><code>eod_data</code></strong> :&ensp;<code>list</code> of <code>waveform data</code></dt>
<dd>Either waveform data is only the EOD waveform,
a ndarray of shape (time, ['time', 'voltage']), or
it is a list with the first element being the EOD waveform,
and the second element being a 2D ndarray of spectral properties
of the EOD waveform with first column being the frequency or harmonics.</dd>
<dt><strong><code>add_waveforms</code></strong> :&ensp;<code>list</code> of <code>string</code></dt>
<dd>List of what should be shown as waveform. Elements can be
'first', 'second', 'ampl', 'power', or 'phase'. For 'first' and 'second'
the first and second derivatives of the supplied EOD waveform a computed and shown.
'ampl', 'power', and 'phase' select properties of the provided spectral properties.</dd>
<dt><strong><code>loaded_spec</code></strong> :&ensp;<code>boolean</code></dt>
<dd>Indicates whether eod_data contains spectral properties.</dd>
<dt><strong><code>rawdata_path</code></strong> :&ensp;<code>string</code></dt>
<dd>Base path to the raw recording, needed to show thunderfish
when double clicking on a single EOD.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class EODExplorer(MultivariateExplorer):
    &#34;&#34;&#34;Simple GUI for viewing and exploring properties of EOD waveforms.

    EODExplorer adapts a MultivariateExplorer to specific needs of EODs.

    Static members
    --------------
    - `groups`: names of groups of data columns that can be selected.
    - `select_EOD_properties()`: select data columns to be explored.
    - `select_color_property()`: select column from data table for colorizing the data.
    &#34;&#34;&#34;
    
    def __init__(self, data, data_cols, wave_fish, eod_data,
                 add_waveforms, loaded_spec, rawdata_path):
        &#34;&#34;&#34;
        Parameters
        ----------
        data: TableData
            Full table of EOD properties. Each row is a fish.
        data_cols: list of string or ints
            Names or indices of columns in `data` to be explored.
            You may use the static function `select_EOD_properties()`
            for assisting the selection of columns.
        wave_fish: boolean
            True if data are about wave-type weakly electric fish.
            False if data are about pulse-type weakly electric fish.
        eod_data: list of waveform data
            Either waveform data is only the EOD waveform,
            a ndarray of shape (time, [&#39;time&#39;, &#39;voltage&#39;]), or
            it is a list with the first element being the EOD waveform,
            and the second element being a 2D ndarray of spectral properties
            of the EOD waveform with first column being the frequency or harmonics.
        add_waveforms: list of string
            List of what should be shown as waveform. Elements can be
            &#39;first&#39;, &#39;second&#39;, &#39;ampl&#39;, &#39;power&#39;, or &#39;phase&#39;. For &#39;first&#39; and &#39;second&#39;
            the first and second derivatives of the supplied EOD waveform a computed and shown.
            &#39;ampl&#39;, &#39;power&#39;, and &#39;phase&#39; select properties of the provided spectral properties.
        loaded_spec: boolean
            Indicates whether eod_data contains spectral properties.
        rawdata_path: string
            Base path to the raw recording, needed to show thunderfish
            when double clicking on a single EOD.
        &#34;&#34;&#34;
        self.wave_fish = wave_fish
        self.eoddata = data
        self.path = rawdata_path
        MultivariateExplorer.__init__(self, data[:,data_cols],
                                      None, &#39;EODExplorer&#39;)
        tunit = &#39;ms&#39;
        dunit = &#39;1/ms&#39;
        if wave_fish:
            tunit = &#39;1/EODf&#39;        
            dunit = &#39;EODf&#39;
        wave_data = eod_data
        xlabels = [&#39;Time [%s]&#39; % tunit]
        ylabels = [&#39;Voltage&#39;]
        if &#39;first&#39; in add_waveforms:
            # first derivative:
            if loaded_spec:
                if hasattr(sig, &#39;savgol_filter&#39;):
                    derivative = lambda x: (np.column_stack((x[0], \
                        sig.savgol_filter(x[0][:,1], 5, 2, 1, x[0][1,0]-x[0][0,0]))), x[1])
                else:
                    derivative = lambda x: (np.column_stack((x[0][:-1,:], \
                        np.diff(x[0][:,1])/(x[0][1,0]-x[0][0,0]))), x[1])
            else:
                if hasattr(sig, &#39;savgol_filter&#39;):
                    derivative = lambda x: np.column_stack((x, \
                        sig.savgol_filter(x[:,1], 5, 2, 1, x[1,0]-x[0,0])))
                else:
                    derivative = lambda x: np.column_stack((x[:-1,:], \
                        np.diff(x[:,1])/(x[1,0]-x[0,0])))
            wave_data = list(map(derivative, wave_data))
            ylabels.append(&#39;dV/dt [%s]&#39; % dunit)
            if &#39;second&#39; in add_waveforms:
                # second derivative:
                if loaded_spec:
                    if hasattr(sig, &#39;savgol_filter&#39;):
                        derivative = lambda x: (np.column_stack((x[0], \
                            sig.savgol_filter(x[0][:,1], 5, 2, 2, x[0][1,0]-x[0][0,0]))), x[1])
                    else:
                        derivative = lambda x: (np.column_stack((x[0][:-1,:], \
                            np.diff(x[0][:,2])/(x[0][1,0]-x[0][0,0]))), x[1])
                else:
                    if hasattr(sig, &#39;savgol_filter&#39;):
                        derivative = lambda x: np.column_stack((x, \
                            sig.savgol_filter(x[:,1], 5, 2, 2, x[1,0]-x[0,0])))
                    else:
                        derivative = lambda x: np.column_stack((x[:-1,:], \
                            np.diff(x[:,2])/(x[1,0]-x[0,0])))
                wave_data = list(map(derivative, wave_data))
                ylabels.append(&#39;d^2V/dt^2 [%s^2]&#39; % dunit)
        if loaded_spec:
            if wave_fish:
                indices = [0]
                phase = False
                xlabels.append(&#39;Harmonics&#39;)
                if &#39;ampl&#39; in add_waveforms:
                    indices.append(3)
                    ylabels.append(&#39;Ampl [%]&#39;)
                if &#39;power&#39; in add_waveforms:
                    indices.append(4)
                    ylabels.append(&#39;Power [dB]&#39;)
                if &#39;phase&#39; in add_waveforms:
                    indices.append(5)
                    ylabels.append(&#39;Phase&#39;)
                    phase = True
                def get_spectra(x):
                    y = x[1][:,indices]
                    if phase:
                        y[y[:,-1]&lt;0.0,-1] += 2.0*np.pi 
                    return (x[0], y)
                wave_data = list(map(get_spectra, wave_data))
            else:
                xlabels.append(&#39;Frequency [Hz]&#39;)
                ylabels.append(&#39;Power [dB]&#39;)
                def get_spectra(x):
                    y = x[1]
                    y[:,1] = decibel(y[:,1], None)
                    return (x[0], y)
                wave_data = list(map(get_spectra, wave_data))
        self.set_wave_data(wave_data, xlabels, ylabels, True)

        
    def fix_scatter_plot(self, ax, data, label, axis):
        &#34;&#34;&#34;Customize an axes of a scatter plot.

        - Limits for amplitude and time like quantities start at zero.
        - Phases a labeled with multuples of pi.
        - Species labels are rotated.
        &#34;&#34;&#34;
        if any(l in label for l in [&#39;ampl&#39;, &#39;power&#39;, &#39;width&#39;,
                                    &#39;time&#39;, &#39;tau&#39;, &#39;P2-P1-dist&#39;,
                                    &#39;var&#39;, &#39;peak&#39;, &#39;trough&#39;,
                                    &#39;dist&#39;, &#39;rms&#39;, &#39;noise&#39;]):
            if np.all(data[np.isfinite(data)] &gt;= 0.0):
                if axis == &#39;x&#39;:
                    ax.set_xlim(0.0, None)
                elif axis == &#39;y&#39;:
                    ax.set_ylim(0.0, None)
                elif axis == &#39;c&#39;:
                    return 0.0, np.max(data), None
            else:
                if axis == &#39;x&#39;:
                    ax.set_xlim(None, 0.0)
                elif axis == &#39;y&#39;:
                    ax.set_ylim(None, 0.0)
                elif axis == &#39;c&#39;:
                    return np.min(data), 0.0, None
        elif &#39;phase&#39; in label:
            if axis == &#39;x&#39;:
                ax.set_xlim(-np.pi, np.pi)
                ax.set_xticks(np.arange(-np.pi, 1.5*np.pi, 0.5*np.pi))
                ax.set_xticklabels([u&#39;-\u03c0&#39;, u&#39;-\u03c0/2&#39;, &#39;0&#39;, u&#39;\u03c0/2&#39;, u&#39;\u03c0&#39;])
            elif axis == &#39;y&#39;:
                ax.set_ylim(-np.pi, np.pi)
                ax.set_yticks(np.arange(-np.pi, 1.5*np.pi, 0.5*np.pi))
                ax.set_yticklabels([u&#39;-\u03c0&#39;, u&#39;-\u03c0/2&#39;, &#39;0&#39;, u&#39;\u03c0/2&#39;, u&#39;\u03c0&#39;])
            elif axis == &#39;c&#39;:
                if ax is not None:
                    ax.set_yticklabels([u&#39;-\u03c0&#39;, u&#39;-\u03c0/2&#39;, &#39;0&#39;, u&#39;\u03c0/2&#39;, u&#39;\u03c0&#39;])
                return -np.pi, np.pi, np.arange(-np.pi, 1.5*np.pi, 0.5*np.pi)
        elif &#39;species&#39; in label:
            if axis == &#39;x&#39;:
                for label in ax.get_xticklabels():
                    label.set_rotation(30)
                ax.set_xlabel(&#39;&#39;)
                ax.set_xlim(np.min(data)-0.5, np.max(data)+0.5)
            elif axis == &#39;y&#39;:
                ax.set_ylabel(&#39;&#39;)
                ax.set_ylim(np.min(data)-0.5, np.max(data)+0.5)
            elif axis == &#39;c&#39;:
                if ax is not None:
                    ax.set_ylabel(&#39;&#39;)
        return np.min(data), np.max(data), None

    
    def fix_waveform_plot(self, axs, indices):
        &#34;&#34;&#34;Adapt waveform plots to EOD waveforms, derivatives, and spectra.
        &#34;&#34;&#34;
        if len(indices) == 0:
            axs[0].text(0.5, 0.5, &#39;Click to plot EOD waveforms&#39;,
                        transform = axs[0].transAxes, ha=&#39;center&#39;, va=&#39;center&#39;)
            axs[0].text(0.5, 0.3, &#39;n = %d&#39; % len(self.raw_data),
                        transform = axs[0].transAxes, ha=&#39;center&#39;, va=&#39;center&#39;)
        elif len(indices) == 1:
            file_name = self.eoddata[indices[0],&#39;file&#39;] if &#39;file&#39; in self.eoddata else basename
            if &#39;index&#39; in self.eoddata and np.isfinite(self.eoddata[indices[0],&#39;index&#39;]) and \
              np.any(self.eoddata[:,&#39;index&#39;] != self.eoddata[0,&#39;index&#39;]):
                axs[0].set_title(&#39;%s: %d&#39; % (file_name,
                                             self.eoddata[indices[0],&#39;index&#39;]))
            else:
                axs[0].set_title(file_name)
            if np.isfinite(self.eoddata[indices[0],&#39;index&#39;]):
                axs[0].text(0.05, 0.85, &#39;%.1fHz&#39; % self.eoddata[indices[0],&#39;EODf&#39;],
                            transform = axs[0].transAxes)
        else:
            axs[0].set_title(&#39;%d EOD waveforms selected&#39; % len(indices))
        for ax in axs:
            for l in ax.lines:
                l.set_linewidth(3.0)
        for ax, xl in zip(axs, self.wave_ylabels):
            if &#39;Voltage&#39; in xl:
                ax.set_ylim(top=1.1)
                ax.yaxis.set_major_locator(ticker.MaxNLocator(nbins=4))
            if &#39;dV/dt&#39; in xl:
                ax.yaxis.set_major_locator(ticker.MaxNLocator(nbins=4))
            if &#39;d^2V/dt^2&#39; in xl:
                ax.yaxis.set_major_locator(ticker.MaxNLocator(nbins=4))
        if self.wave_fish:
            for ax, xl in zip(axs, self.wave_ylabels):
                if &#39;Voltage&#39; in xl:
                    ax.set_xlim(-0.7, 0.7)
                if &#39;Ampl&#39; in xl or &#39;Power&#39; in xl or &#39;Phase&#39; in xl:
                    ax.set_xlim(-0.5, 8.5)
                    for l in ax.lines:
                        l.set_marker(&#39;.&#39;)
                        l.set_markersize(15.0)
                        l.set_markeredgewidth(0.5)
                        l.set_markeredgecolor(&#39;k&#39;)
                        l.set_markerfacecolor(l.get_color())
                if &#39;Ampl&#39; in xl:
                    ax.set_ylim(0.0, 100.0)
                    ax.yaxis.set_major_locator(ticker.MultipleLocator(25.0))
                if &#39;Power&#39; in xl:
                    ax.set_ylim(-60.0, 2.0)
                    ax.yaxis.set_major_locator(ticker.MultipleLocator(20.0))
                if &#39;Phase&#39; in xl:
                    ax.set_ylim(0.0, 2.0*np.pi)
                    ax.set_yticks(np.arange(0.0, 2.5*np.pi, 0.5*np.pi))
                    ax.set_yticklabels([&#39;0&#39;, u&#39;\u03c0/2&#39;, u&#39;\u03c0&#39;, u&#39;3\u03c0/2&#39;, u&#39;2\u03c0&#39;])
        else:
            for ax, xl in zip(axs, self.wave_ylabels):
                if &#39;Voltage&#39; in xl:
                    ax.set_xlim(-1.0, 1.5)
                if &#39;Power&#39; in xl:
                    ax.set_xlim(1.0, 2000.0)
                    ax.set_xscale(&#39;log&#39;)
                    ax.set_ylim(-60.0, 2.0)
                    ax.yaxis.set_major_locator(ticker.MultipleLocator(20.0))
        if len(indices) &gt; 0:
            for ax in axs:
                ax.axhline(c=&#39;k&#39;, lw=1)

            
    def list_selection(self, indices):
        &#34;&#34;&#34;List file names and indices of selection.

        If only a single EOD is selected, list all of its properties.
        &#34;&#34;&#34;
        if &#39;index&#39; in self.eoddata and \
           np.any(self.eoddata[:,&#39;index&#39;] != self.eoddata[0,&#39;index&#39;]):
            for i in indices:
                file_name = self.eoddata[i,&#39;file&#39;] if &#39;file&#39; in self.eoddata else basename
                if np.isfinite(self.eoddata[i,&#39;index&#39;]):
                    print(&#39;%s : %d&#39; % (file_name, self.eoddata[i,&#39;index&#39;]))
                else:
                    print(file_name)
        elif &#39;file&#39; in self.eoddata:
            for i in indices:
                print(self.eoddata[i,&#39;file&#39;])
        if len(indices) == 1:
            # write eoddata line on terminal:
            keylen = 0
            keys = []
            values = []
            for c in range(self.eoddata.columns()):
                k, v = self.eoddata.key_value(indices[0], c)
                keys.append(k)
                values.append(v)
                if keylen &lt; len(k):
                    keylen = len(k)
            for k, v in zip(keys, values):
                fs = &#39;%%-%ds: %%s&#39; % keylen
                print(fs % (k, v.strip()))

                
    def analyze_selection(self, index):
        &#34;&#34;&#34;Launch thunderfish on the selected EOD.
        &#34;&#34;&#34;
        # load data:
        file_base = self.eoddata[index,&#39;file&#39;] if &#39;file&#39; in self.eoddata else basename
        bp = os.path.join(self.path, file_base)
        fn = glob.glob(bp + &#39;.*&#39;)
        if len(fn) == 0:
            print(&#39;no recording found for %s&#39; % bp)
            return
        recording = fn[0]
        channel = 0
        try:
            raw_data, samplerate, unit = load_data(recording, channel)
        except IOError as e:
            print(&#39;%s: failed to open file: did you provide a path to the raw data (-P option)?&#39; % (recording))
            return
        if len(raw_data) &lt;= 1:
            print(&#39;%s: empty data file&#39; % recording)
            return
        # load configuration:
        cfgfile = __package__ + &#39;.cfg&#39;
        cfg = configuration(cfgfile, False, recording)
        cfg.load_files(cfgfile, recording, 4)
        if &#39;flipped&#39; in self.eoddata:
            fs = &#39;flip&#39; if self.eoddata[index,&#39;flipped&#39;] else &#39;none&#39;
            cfg.set(&#39;flipWaveEOD&#39;, fs)
            cfg.set(&#39;flipPulseEOD&#39;, fs)
        # best_window:
        data, idx0, idx1, clipped, min_clip, max_clip = analysis_window(raw_data, samplerate, cfg.value(&#39;windowPosition&#39;), cfg)
        # detect EODs in the data:
        psd_data, fishlist, _, eod_props, mean_eods, \
          spec_data, peak_data, power_thresh, skip_reason, zoom_window = \
          detect_eods(data, samplerate, min_clip, max_clip, recording, 0, 0, cfg)
        # plot EOD:
        idx = int(self.eoddata[index,&#39;index&#39;]) if &#39;index&#39; in self.eoddata else 0
        for k in [&#39;toolbar&#39;, &#39;keymap.back&#39;, &#39;keymap.forward&#39;,
                  &#39;keymap.zoom&#39;, &#39;keymap.pan&#39;]:
            plt.rcParams[k] = self.plt_params[k]
        fig = plot_eods(file_base, raw_data, samplerate, None, idx0, idx1,
                        clipped, psd_data[0], fishlist, None,
                        mean_eods, eod_props, peak_data, spec_data,
                        [idx], unit, zoom_window, 10, None, True, False,
                        &#39;auto&#39;, False, 0.0, 3000.0,
                        interactive=True, verbose=0)
        fig.canvas.set_window_title(&#39;thunderfish: %s&#39; % file_base)
        plt.show(block=False)


    &#34;&#34;&#34;Names of groups of data columns that can be selected by the select_EOD_properties() function.
    &#34;&#34;&#34;
    groups = [&#39;all&#39;, &#39;allpower&#39;, &#39;noise&#39;, &#39;timing&#39;,
              &#39;ampl&#39;, &#39;relampl&#39;, &#39;power&#39;, &#39;relpower&#39;, &#39;phase&#39;,
              &#39;time&#39;, &#39;width&#39;, &#39;peaks&#39;, &#39;none&#39;]
    
    @staticmethod
    def select_EOD_properties(data, wave_fish, max_n, column_groups, add_columns):
        &#34;&#34;&#34;Select data columns to be explored.

        First, groups of columns are selected, then individual
        columns. Columns that are selected twice are removed from the
        selection.

        Parameters
        ----------
        data: TableData
            Table with EOD properties from which columns are selected.
        wave_fish: boolean.
            Indicates if data contains properties of wave- or pulse-type electric fish.
        max_n: int
            Maximum number of harmonics (wae-type fish) or peaks (pulse-type fish)
            to be  selected.
        column_groups: list of string
            List of name denoting groups of columns to be selected. Supported groups are
            listed in `EODExplor.groups`.
        add_columns: list of string or int
            List of further individual columns to be selected.

        Returns
        -------
        data_cols: list of int
            Indices of data columns to be shown by EODExplorer.
        error: string
            In case of an invalid column group, an error string.
        &#34;&#34;&#34;
        if wave_fish:
            # maximum number of harmonics:
            if max_n == 0:
                max_n = 100
            else:
                max_n += 1
            for k in range(1, max_n):
                if not (&#39;phase%d&#39; % k) in data:
                    max_n = k
                    break
        else:
            # minimum number of peaks:
            min_peaks = -10
            for k in range(1, min_peaks, -1):
                if not (&#39;P%dampl&#39; % k) in data or not np.all(np.isfinite(data[:,&#39;P%dampl&#39; % k])):
                    min_peaks = k+1
                    break
            # maximum number of peaks:
            if max_n == 0:
                max_peaks = 20
            else:
                max_peaks = max_n + 1
            for k in range(1, max_peaks):
                if not (&#39;P%dampl&#39; % k) in data or not np.all(np.isfinite(data[:,&#39;P%dampl&#39; % k])):
                    max_peaks = k
                    break

        # default columns:
        group_cols = [&#39;EODf&#39;]
        if &#39;EODf_adjust&#39; in data:
            group_cols.append(&#39;EODf_adjust&#39;)
        if len(column_groups) == 0:
            column_groups = [&#39;all&#39;]
        for group in column_groups:
            if group == &#39;none&#39;:
                group_cols = []
            elif wave_fish:
                if group == &#39;noise&#39;:
                    group_cols.extend([&#39;noise&#39;, &#39;rmserror&#39;, &#39;power&#39;, &#39;thd&#39;,
                                       &#39;dbdiff&#39;, &#39;maxdb&#39;, &#39;p-p-amplitude&#39;,
                                       &#39;relampl1&#39;, &#39;relampl2&#39;, &#39;relampl3&#39;])
                elif group == &#39;timing&#39; or group == &#39;time&#39;:
                    group_cols.extend([&#39;peakwidth&#39;, &#39;troughwidth&#39;, &#39;p-p-distance&#39;,
                                       &#39;leftpeak&#39;, &#39;rightpeak&#39;, &#39;lefttrough&#39;, &#39;righttrough&#39;])
                elif group == &#39;ampl&#39;:
                    for k in range(0, max_n):
                        group_cols.append(&#39;ampl%d&#39; % k)
                elif group == &#39;relampl&#39;:
                    group_cols.append(&#39;thd&#39;)
                    group_cols.append(&#39;reltroughampl&#39;)
                    for k in range(1, max_n):
                        group_cols.append(&#39;relampl%d&#39; % k)
                elif group == &#39;relpower&#39; or group == &#39;power&#39;:
                    for k in range(1, max_n):
                        group_cols.append(&#39;relpower%d&#39; % k)
                elif group == &#39;phase&#39;:
                    for k in range(0, max_n):
                        group_cols.append(&#39;phase%d&#39; % k)
                elif group == &#39;all&#39;:
                    group_cols.append(&#39;thd&#39;)
                    group_cols.append(&#39;reltroughampl&#39;)
                    for k in range(1, max_n):
                        group_cols.append(&#39;relampl%d&#39; % k)
                        group_cols.append(&#39;phase%d&#39; % k)
                elif group == &#39;allpower&#39;:
                    group_cols.append(&#39;thd&#39;)
                    for k in range(1, max_n):
                        group_cols.append(&#39;relpower%d&#39; % k)
                        group_cols.append(&#39;phase%d&#39; % k)
                else:
                    return None, &#39;&#34;%s&#34; is not a valid data group for wavefish&#39; % group
            else:  # pulse fish
                if group == &#39;noise&#39;:
                    group_cols.extend([&#39;noise&#39;, &#39;p-p-amplitude&#39;, &#39;min-ampl&#39;, &#39;max-ampl&#39;])
                elif group == &#39;timing&#39;:
                    group_cols.extend([&#39;tstart&#39;, &#39;tend&#39;, &#39;width&#39;, &#39;tau&#39;, &#39;P2-P1-dist&#39;, &#39;firstpeak&#39;, &#39;lastpeak&#39;])
                elif group == &#39;power&#39;:
                    group_cols.extend([&#39;peakfreq&#39;, &#39;peakpower&#39;, &#39;poweratt5&#39;, &#39;poweratt50&#39;, &#39;lowcutoff&#39;])
                elif group == &#39;time&#39;:
                    for k in range(min_peaks, max_peaks):
                        if k != 1:
                            group_cols.append(&#39;P%dtime&#39; % k)
                elif group == &#39;ampl&#39;:
                    for k in range(min_peaks, max_peaks):
                        group_cols.append(&#39;P%dampl&#39; % k)
                elif group == &#39;relampl&#39;:
                    for k in range(min_peaks, max_peaks):
                        if k != 1:
                            group_cols.append(&#39;P%drelampl&#39; % k)
                elif group == &#39;width&#39;:
                    for k in range(min_peaks, max_peaks):
                        group_cols.append(&#39;P%dwidth&#39; % k)
                elif group == &#39;peaks&#39;:
                    group_cols.append(&#39;firstpeak&#39;)
                    group_cols.append(&#39;lastpeak&#39;)
                elif group == &#39;all&#39;:
                    group_cols.extend([&#39;firstpeak&#39;, &#39;lastpeak&#39;])
                    for k in range(min_peaks, max_peaks):
                        if k != 1:
                            group_cols.append(&#39;P%drelampl&#39; % k)
                            group_cols.append(&#39;P%dtime&#39; % k)
                        group_cols.append(&#39;P%dwidth&#39; % k)
                    group_cols.extend([&#39;tau&#39;, &#39;P2-P1-dist&#39;, &#39;peakfreq&#39;, &#39;poweratt5&#39;])
                else:
                    return None, &#39;&#34;%s&#34; is not a valid data group for pulsefish&#39; % group
        # additional data columns:
        group_cols.extend(add_columns)
        # translate to indices:
        data_cols = []
        for c in group_cols:
            idx = data.index(c)
            if idx is None:
                print(&#39;&#34;%s&#34; is not a valid data column&#39; % c)
            elif idx in data_cols:
                data_cols.remove(idx)
            else:
                data_cols.append(idx)
        return data_cols, None

    
    @staticmethod
    def select_color_property(data, data_cols, color_col):
        &#34;&#34;&#34;Select column from data table for colorizing the data.

        Pass the output of this function on to MultivariateExplorer.set_colors().

        Parameters
        ----------
        data: TableData
            Table with all EOD properties from which columns are selected.
        data_cols: list of int
            List of columns selected to be explored.
        color_col: string or int
            Column to be selected for coloring the data.
            If &#39;row&#39; then use the row index of the data in the table for coloring.

        Returns
        -------
        colors: int or column from data.
            Either index of `data_cols` or additional data from the data table
            to be used for coloring.
        color_label: string
            Label for labeling the color bar.
        color_idx: int or None
            Index of column in `data`.
        error: string
            In case an invalid column is selected, an error string.
        &#34;&#34;&#34;
        color_idx = data.index(color_col)
        colors = None
        color_label = None
        if color_idx is None and color_col != &#39;row&#39;:
            return None, None, None, &#39;&#34;%s&#34; is not a valid column for color code&#39; % color_col
        if color_idx is None:
            colors = -2
        elif color_idx in data_cols:
            colors = data_cols.index(color_idx)
        else:
            if len(data.unit(color_idx)) &gt; 0 and not data.unit(color_idx) in [&#39;-&#39;, &#39;1&#39;]:
                color_label = &#39;%s [%s]&#39; % (data.label(color_idx), data.unit(color_idx))
            else:
                color_label = data.label(color_idx)
            colors = data[:,color_idx]
        return colors, color_label, color_idx, None</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="thunderfish.multivariateexplorer.MultivariateExplorer" href="multivariateexplorer.html#thunderfish.multivariateexplorer.MultivariateExplorer">MultivariateExplorer</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="thunderfish.eodexplorer.EODExplorer.groups"><code class="name">var <span class="ident">groups</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="thunderfish.eodexplorer.EODExplorer.select_EOD_properties"><code class="name flex">
<span>def <span class="ident">select_EOD_properties</span></span>(<span>data, wave_fish, max_n, column_groups, add_columns)</span>
</code></dt>
<dd>
<div class="desc"><p>Select data columns to be explored.</p>
<p>First, groups of columns are selected, then individual
columns. Columns that are selected twice are removed from the
selection.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>data</code></strong> :&ensp;<code>TableData</code></dt>
<dd>Table with EOD properties from which columns are selected.</dd>
<dt>wave_fish: boolean.</dt>
<dt>Indicates if data contains properties of wave- or pulse-type electric fish.</dt>
<dt><strong><code>max_n</code></strong> :&ensp;<code>int</code></dt>
<dd>Maximum number of harmonics (wae-type fish) or peaks (pulse-type fish)
to be
selected.</dd>
<dt><strong><code>column_groups</code></strong> :&ensp;<code>list</code> of <code>string</code></dt>
<dd>List of name denoting groups of columns to be selected. Supported groups are
listed in <code>EODExplor.groups</code>.</dd>
<dt><strong><code>add_columns</code></strong> :&ensp;<code>list</code> of <code>string</code> or <code>int</code></dt>
<dd>List of further individual columns to be selected.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>data_cols</code></strong> :&ensp;<code>list</code> of <code>int</code></dt>
<dd>Indices of data columns to be shown by EODExplorer.</dd>
<dt><strong><code>error</code></strong> :&ensp;<code>string</code></dt>
<dd>In case of an invalid column group, an error string.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def select_EOD_properties(data, wave_fish, max_n, column_groups, add_columns):
    &#34;&#34;&#34;Select data columns to be explored.

    First, groups of columns are selected, then individual
    columns. Columns that are selected twice are removed from the
    selection.

    Parameters
    ----------
    data: TableData
        Table with EOD properties from which columns are selected.
    wave_fish: boolean.
        Indicates if data contains properties of wave- or pulse-type electric fish.
    max_n: int
        Maximum number of harmonics (wae-type fish) or peaks (pulse-type fish)
        to be  selected.
    column_groups: list of string
        List of name denoting groups of columns to be selected. Supported groups are
        listed in `EODExplor.groups`.
    add_columns: list of string or int
        List of further individual columns to be selected.

    Returns
    -------
    data_cols: list of int
        Indices of data columns to be shown by EODExplorer.
    error: string
        In case of an invalid column group, an error string.
    &#34;&#34;&#34;
    if wave_fish:
        # maximum number of harmonics:
        if max_n == 0:
            max_n = 100
        else:
            max_n += 1
        for k in range(1, max_n):
            if not (&#39;phase%d&#39; % k) in data:
                max_n = k
                break
    else:
        # minimum number of peaks:
        min_peaks = -10
        for k in range(1, min_peaks, -1):
            if not (&#39;P%dampl&#39; % k) in data or not np.all(np.isfinite(data[:,&#39;P%dampl&#39; % k])):
                min_peaks = k+1
                break
        # maximum number of peaks:
        if max_n == 0:
            max_peaks = 20
        else:
            max_peaks = max_n + 1
        for k in range(1, max_peaks):
            if not (&#39;P%dampl&#39; % k) in data or not np.all(np.isfinite(data[:,&#39;P%dampl&#39; % k])):
                max_peaks = k
                break

    # default columns:
    group_cols = [&#39;EODf&#39;]
    if &#39;EODf_adjust&#39; in data:
        group_cols.append(&#39;EODf_adjust&#39;)
    if len(column_groups) == 0:
        column_groups = [&#39;all&#39;]
    for group in column_groups:
        if group == &#39;none&#39;:
            group_cols = []
        elif wave_fish:
            if group == &#39;noise&#39;:
                group_cols.extend([&#39;noise&#39;, &#39;rmserror&#39;, &#39;power&#39;, &#39;thd&#39;,
                                   &#39;dbdiff&#39;, &#39;maxdb&#39;, &#39;p-p-amplitude&#39;,
                                   &#39;relampl1&#39;, &#39;relampl2&#39;, &#39;relampl3&#39;])
            elif group == &#39;timing&#39; or group == &#39;time&#39;:
                group_cols.extend([&#39;peakwidth&#39;, &#39;troughwidth&#39;, &#39;p-p-distance&#39;,
                                   &#39;leftpeak&#39;, &#39;rightpeak&#39;, &#39;lefttrough&#39;, &#39;righttrough&#39;])
            elif group == &#39;ampl&#39;:
                for k in range(0, max_n):
                    group_cols.append(&#39;ampl%d&#39; % k)
            elif group == &#39;relampl&#39;:
                group_cols.append(&#39;thd&#39;)
                group_cols.append(&#39;reltroughampl&#39;)
                for k in range(1, max_n):
                    group_cols.append(&#39;relampl%d&#39; % k)
            elif group == &#39;relpower&#39; or group == &#39;power&#39;:
                for k in range(1, max_n):
                    group_cols.append(&#39;relpower%d&#39; % k)
            elif group == &#39;phase&#39;:
                for k in range(0, max_n):
                    group_cols.append(&#39;phase%d&#39; % k)
            elif group == &#39;all&#39;:
                group_cols.append(&#39;thd&#39;)
                group_cols.append(&#39;reltroughampl&#39;)
                for k in range(1, max_n):
                    group_cols.append(&#39;relampl%d&#39; % k)
                    group_cols.append(&#39;phase%d&#39; % k)
            elif group == &#39;allpower&#39;:
                group_cols.append(&#39;thd&#39;)
                for k in range(1, max_n):
                    group_cols.append(&#39;relpower%d&#39; % k)
                    group_cols.append(&#39;phase%d&#39; % k)
            else:
                return None, &#39;&#34;%s&#34; is not a valid data group for wavefish&#39; % group
        else:  # pulse fish
            if group == &#39;noise&#39;:
                group_cols.extend([&#39;noise&#39;, &#39;p-p-amplitude&#39;, &#39;min-ampl&#39;, &#39;max-ampl&#39;])
            elif group == &#39;timing&#39;:
                group_cols.extend([&#39;tstart&#39;, &#39;tend&#39;, &#39;width&#39;, &#39;tau&#39;, &#39;P2-P1-dist&#39;, &#39;firstpeak&#39;, &#39;lastpeak&#39;])
            elif group == &#39;power&#39;:
                group_cols.extend([&#39;peakfreq&#39;, &#39;peakpower&#39;, &#39;poweratt5&#39;, &#39;poweratt50&#39;, &#39;lowcutoff&#39;])
            elif group == &#39;time&#39;:
                for k in range(min_peaks, max_peaks):
                    if k != 1:
                        group_cols.append(&#39;P%dtime&#39; % k)
            elif group == &#39;ampl&#39;:
                for k in range(min_peaks, max_peaks):
                    group_cols.append(&#39;P%dampl&#39; % k)
            elif group == &#39;relampl&#39;:
                for k in range(min_peaks, max_peaks):
                    if k != 1:
                        group_cols.append(&#39;P%drelampl&#39; % k)
            elif group == &#39;width&#39;:
                for k in range(min_peaks, max_peaks):
                    group_cols.append(&#39;P%dwidth&#39; % k)
            elif group == &#39;peaks&#39;:
                group_cols.append(&#39;firstpeak&#39;)
                group_cols.append(&#39;lastpeak&#39;)
            elif group == &#39;all&#39;:
                group_cols.extend([&#39;firstpeak&#39;, &#39;lastpeak&#39;])
                for k in range(min_peaks, max_peaks):
                    if k != 1:
                        group_cols.append(&#39;P%drelampl&#39; % k)
                        group_cols.append(&#39;P%dtime&#39; % k)
                    group_cols.append(&#39;P%dwidth&#39; % k)
                group_cols.extend([&#39;tau&#39;, &#39;P2-P1-dist&#39;, &#39;peakfreq&#39;, &#39;poweratt5&#39;])
            else:
                return None, &#39;&#34;%s&#34; is not a valid data group for pulsefish&#39; % group
    # additional data columns:
    group_cols.extend(add_columns)
    # translate to indices:
    data_cols = []
    for c in group_cols:
        idx = data.index(c)
        if idx is None:
            print(&#39;&#34;%s&#34; is not a valid data column&#39; % c)
        elif idx in data_cols:
            data_cols.remove(idx)
        else:
            data_cols.append(idx)
    return data_cols, None</code></pre>
</details>
</dd>
<dt id="thunderfish.eodexplorer.EODExplorer.select_color_property"><code class="name flex">
<span>def <span class="ident">select_color_property</span></span>(<span>data, data_cols, color_col)</span>
</code></dt>
<dd>
<div class="desc"><p>Select column from data table for colorizing the data.</p>
<p>Pass the output of this function on to MultivariateExplorer.set_colors().</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>data</code></strong> :&ensp;<code>TableData</code></dt>
<dd>Table with all EOD properties from which columns are selected.</dd>
<dt><strong><code>data_cols</code></strong> :&ensp;<code>list</code> of <code>int</code></dt>
<dd>List of columns selected to be explored.</dd>
<dt><strong><code>color_col</code></strong> :&ensp;<code>string</code> or <code>int</code></dt>
<dd>Column to be selected for coloring the data.
If 'row' then use the row index of the data in the table for coloring.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt>colors: int or column from data.</dt>
<dt>Either index of <code>data_cols</code> or additional data from the data table</dt>
<dt>to be used for coloring.</dt>
<dt><strong><code>color_label</code></strong> :&ensp;<code>string</code></dt>
<dd>Label for labeling the color bar.</dd>
<dt><strong><code>color_idx</code></strong> :&ensp;<code>int</code> or <code>None</code></dt>
<dd>Index of column in <code>data</code>.</dd>
<dt><strong><code>error</code></strong> :&ensp;<code>string</code></dt>
<dd>In case an invalid column is selected, an error string.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def select_color_property(data, data_cols, color_col):
    &#34;&#34;&#34;Select column from data table for colorizing the data.

    Pass the output of this function on to MultivariateExplorer.set_colors().

    Parameters
    ----------
    data: TableData
        Table with all EOD properties from which columns are selected.
    data_cols: list of int
        List of columns selected to be explored.
    color_col: string or int
        Column to be selected for coloring the data.
        If &#39;row&#39; then use the row index of the data in the table for coloring.

    Returns
    -------
    colors: int or column from data.
        Either index of `data_cols` or additional data from the data table
        to be used for coloring.
    color_label: string
        Label for labeling the color bar.
    color_idx: int or None
        Index of column in `data`.
    error: string
        In case an invalid column is selected, an error string.
    &#34;&#34;&#34;
    color_idx = data.index(color_col)
    colors = None
    color_label = None
    if color_idx is None and color_col != &#39;row&#39;:
        return None, None, None, &#39;&#34;%s&#34; is not a valid column for color code&#39; % color_col
    if color_idx is None:
        colors = -2
    elif color_idx in data_cols:
        colors = data_cols.index(color_idx)
    else:
        if len(data.unit(color_idx)) &gt; 0 and not data.unit(color_idx) in [&#39;-&#39;, &#39;1&#39;]:
            color_label = &#39;%s [%s]&#39; % (data.label(color_idx), data.unit(color_idx))
        else:
            color_label = data.label(color_idx)
        colors = data[:,color_idx]
    return colors, color_label, color_idx, None</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="thunderfish.eodexplorer.EODExplorer.analyze_selection"><code class="name flex">
<span>def <span class="ident">analyze_selection</span></span>(<span>self, index)</span>
</code></dt>
<dd>
<div class="desc"><p>Launch thunderfish on the selected EOD.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def analyze_selection(self, index):
    &#34;&#34;&#34;Launch thunderfish on the selected EOD.
    &#34;&#34;&#34;
    # load data:
    file_base = self.eoddata[index,&#39;file&#39;] if &#39;file&#39; in self.eoddata else basename
    bp = os.path.join(self.path, file_base)
    fn = glob.glob(bp + &#39;.*&#39;)
    if len(fn) == 0:
        print(&#39;no recording found for %s&#39; % bp)
        return
    recording = fn[0]
    channel = 0
    try:
        raw_data, samplerate, unit = load_data(recording, channel)
    except IOError as e:
        print(&#39;%s: failed to open file: did you provide a path to the raw data (-P option)?&#39; % (recording))
        return
    if len(raw_data) &lt;= 1:
        print(&#39;%s: empty data file&#39; % recording)
        return
    # load configuration:
    cfgfile = __package__ + &#39;.cfg&#39;
    cfg = configuration(cfgfile, False, recording)
    cfg.load_files(cfgfile, recording, 4)
    if &#39;flipped&#39; in self.eoddata:
        fs = &#39;flip&#39; if self.eoddata[index,&#39;flipped&#39;] else &#39;none&#39;
        cfg.set(&#39;flipWaveEOD&#39;, fs)
        cfg.set(&#39;flipPulseEOD&#39;, fs)
    # best_window:
    data, idx0, idx1, clipped, min_clip, max_clip = analysis_window(raw_data, samplerate, cfg.value(&#39;windowPosition&#39;), cfg)
    # detect EODs in the data:
    psd_data, fishlist, _, eod_props, mean_eods, \
      spec_data, peak_data, power_thresh, skip_reason, zoom_window = \
      detect_eods(data, samplerate, min_clip, max_clip, recording, 0, 0, cfg)
    # plot EOD:
    idx = int(self.eoddata[index,&#39;index&#39;]) if &#39;index&#39; in self.eoddata else 0
    for k in [&#39;toolbar&#39;, &#39;keymap.back&#39;, &#39;keymap.forward&#39;,
              &#39;keymap.zoom&#39;, &#39;keymap.pan&#39;]:
        plt.rcParams[k] = self.plt_params[k]
    fig = plot_eods(file_base, raw_data, samplerate, None, idx0, idx1,
                    clipped, psd_data[0], fishlist, None,
                    mean_eods, eod_props, peak_data, spec_data,
                    [idx], unit, zoom_window, 10, None, True, False,
                    &#39;auto&#39;, False, 0.0, 3000.0,
                    interactive=True, verbose=0)
    fig.canvas.set_window_title(&#39;thunderfish: %s&#39; % file_base)
    plt.show(block=False)</code></pre>
</details>
</dd>
<dt id="thunderfish.eodexplorer.EODExplorer.fix_scatter_plot"><code class="name flex">
<span>def <span class="ident">fix_scatter_plot</span></span>(<span>self, ax, data, label, axis)</span>
</code></dt>
<dd>
<div class="desc"><p>Customize an axes of a scatter plot.</p>
<ul>
<li>Limits for amplitude and time like quantities start at zero.</li>
<li>Phases a labeled with multuples of pi.</li>
<li>Species labels are rotated.</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def fix_scatter_plot(self, ax, data, label, axis):
    &#34;&#34;&#34;Customize an axes of a scatter plot.

    - Limits for amplitude and time like quantities start at zero.
    - Phases a labeled with multuples of pi.
    - Species labels are rotated.
    &#34;&#34;&#34;
    if any(l in label for l in [&#39;ampl&#39;, &#39;power&#39;, &#39;width&#39;,
                                &#39;time&#39;, &#39;tau&#39;, &#39;P2-P1-dist&#39;,
                                &#39;var&#39;, &#39;peak&#39;, &#39;trough&#39;,
                                &#39;dist&#39;, &#39;rms&#39;, &#39;noise&#39;]):
        if np.all(data[np.isfinite(data)] &gt;= 0.0):
            if axis == &#39;x&#39;:
                ax.set_xlim(0.0, None)
            elif axis == &#39;y&#39;:
                ax.set_ylim(0.0, None)
            elif axis == &#39;c&#39;:
                return 0.0, np.max(data), None
        else:
            if axis == &#39;x&#39;:
                ax.set_xlim(None, 0.0)
            elif axis == &#39;y&#39;:
                ax.set_ylim(None, 0.0)
            elif axis == &#39;c&#39;:
                return np.min(data), 0.0, None
    elif &#39;phase&#39; in label:
        if axis == &#39;x&#39;:
            ax.set_xlim(-np.pi, np.pi)
            ax.set_xticks(np.arange(-np.pi, 1.5*np.pi, 0.5*np.pi))
            ax.set_xticklabels([u&#39;-\u03c0&#39;, u&#39;-\u03c0/2&#39;, &#39;0&#39;, u&#39;\u03c0/2&#39;, u&#39;\u03c0&#39;])
        elif axis == &#39;y&#39;:
            ax.set_ylim(-np.pi, np.pi)
            ax.set_yticks(np.arange(-np.pi, 1.5*np.pi, 0.5*np.pi))
            ax.set_yticklabels([u&#39;-\u03c0&#39;, u&#39;-\u03c0/2&#39;, &#39;0&#39;, u&#39;\u03c0/2&#39;, u&#39;\u03c0&#39;])
        elif axis == &#39;c&#39;:
            if ax is not None:
                ax.set_yticklabels([u&#39;-\u03c0&#39;, u&#39;-\u03c0/2&#39;, &#39;0&#39;, u&#39;\u03c0/2&#39;, u&#39;\u03c0&#39;])
            return -np.pi, np.pi, np.arange(-np.pi, 1.5*np.pi, 0.5*np.pi)
    elif &#39;species&#39; in label:
        if axis == &#39;x&#39;:
            for label in ax.get_xticklabels():
                label.set_rotation(30)
            ax.set_xlabel(&#39;&#39;)
            ax.set_xlim(np.min(data)-0.5, np.max(data)+0.5)
        elif axis == &#39;y&#39;:
            ax.set_ylabel(&#39;&#39;)
            ax.set_ylim(np.min(data)-0.5, np.max(data)+0.5)
        elif axis == &#39;c&#39;:
            if ax is not None:
                ax.set_ylabel(&#39;&#39;)
    return np.min(data), np.max(data), None</code></pre>
</details>
</dd>
<dt id="thunderfish.eodexplorer.EODExplorer.fix_waveform_plot"><code class="name flex">
<span>def <span class="ident">fix_waveform_plot</span></span>(<span>self, axs, indices)</span>
</code></dt>
<dd>
<div class="desc"><p>Adapt waveform plots to EOD waveforms, derivatives, and spectra.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def fix_waveform_plot(self, axs, indices):
    &#34;&#34;&#34;Adapt waveform plots to EOD waveforms, derivatives, and spectra.
    &#34;&#34;&#34;
    if len(indices) == 0:
        axs[0].text(0.5, 0.5, &#39;Click to plot EOD waveforms&#39;,
                    transform = axs[0].transAxes, ha=&#39;center&#39;, va=&#39;center&#39;)
        axs[0].text(0.5, 0.3, &#39;n = %d&#39; % len(self.raw_data),
                    transform = axs[0].transAxes, ha=&#39;center&#39;, va=&#39;center&#39;)
    elif len(indices) == 1:
        file_name = self.eoddata[indices[0],&#39;file&#39;] if &#39;file&#39; in self.eoddata else basename
        if &#39;index&#39; in self.eoddata and np.isfinite(self.eoddata[indices[0],&#39;index&#39;]) and \
          np.any(self.eoddata[:,&#39;index&#39;] != self.eoddata[0,&#39;index&#39;]):
            axs[0].set_title(&#39;%s: %d&#39; % (file_name,
                                         self.eoddata[indices[0],&#39;index&#39;]))
        else:
            axs[0].set_title(file_name)
        if np.isfinite(self.eoddata[indices[0],&#39;index&#39;]):
            axs[0].text(0.05, 0.85, &#39;%.1fHz&#39; % self.eoddata[indices[0],&#39;EODf&#39;],
                        transform = axs[0].transAxes)
    else:
        axs[0].set_title(&#39;%d EOD waveforms selected&#39; % len(indices))
    for ax in axs:
        for l in ax.lines:
            l.set_linewidth(3.0)
    for ax, xl in zip(axs, self.wave_ylabels):
        if &#39;Voltage&#39; in xl:
            ax.set_ylim(top=1.1)
            ax.yaxis.set_major_locator(ticker.MaxNLocator(nbins=4))
        if &#39;dV/dt&#39; in xl:
            ax.yaxis.set_major_locator(ticker.MaxNLocator(nbins=4))
        if &#39;d^2V/dt^2&#39; in xl:
            ax.yaxis.set_major_locator(ticker.MaxNLocator(nbins=4))
    if self.wave_fish:
        for ax, xl in zip(axs, self.wave_ylabels):
            if &#39;Voltage&#39; in xl:
                ax.set_xlim(-0.7, 0.7)
            if &#39;Ampl&#39; in xl or &#39;Power&#39; in xl or &#39;Phase&#39; in xl:
                ax.set_xlim(-0.5, 8.5)
                for l in ax.lines:
                    l.set_marker(&#39;.&#39;)
                    l.set_markersize(15.0)
                    l.set_markeredgewidth(0.5)
                    l.set_markeredgecolor(&#39;k&#39;)
                    l.set_markerfacecolor(l.get_color())
            if &#39;Ampl&#39; in xl:
                ax.set_ylim(0.0, 100.0)
                ax.yaxis.set_major_locator(ticker.MultipleLocator(25.0))
            if &#39;Power&#39; in xl:
                ax.set_ylim(-60.0, 2.0)
                ax.yaxis.set_major_locator(ticker.MultipleLocator(20.0))
            if &#39;Phase&#39; in xl:
                ax.set_ylim(0.0, 2.0*np.pi)
                ax.set_yticks(np.arange(0.0, 2.5*np.pi, 0.5*np.pi))
                ax.set_yticklabels([&#39;0&#39;, u&#39;\u03c0/2&#39;, u&#39;\u03c0&#39;, u&#39;3\u03c0/2&#39;, u&#39;2\u03c0&#39;])
    else:
        for ax, xl in zip(axs, self.wave_ylabels):
            if &#39;Voltage&#39; in xl:
                ax.set_xlim(-1.0, 1.5)
            if &#39;Power&#39; in xl:
                ax.set_xlim(1.0, 2000.0)
                ax.set_xscale(&#39;log&#39;)
                ax.set_ylim(-60.0, 2.0)
                ax.yaxis.set_major_locator(ticker.MultipleLocator(20.0))
    if len(indices) &gt; 0:
        for ax in axs:
            ax.axhline(c=&#39;k&#39;, lw=1)</code></pre>
</details>
</dd>
<dt id="thunderfish.eodexplorer.EODExplorer.list_selection"><code class="name flex">
<span>def <span class="ident">list_selection</span></span>(<span>self, indices)</span>
</code></dt>
<dd>
<div class="desc"><p>List file names and indices of selection.</p>
<p>If only a single EOD is selected, list all of its properties.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def list_selection(self, indices):
    &#34;&#34;&#34;List file names and indices of selection.

    If only a single EOD is selected, list all of its properties.
    &#34;&#34;&#34;
    if &#39;index&#39; in self.eoddata and \
       np.any(self.eoddata[:,&#39;index&#39;] != self.eoddata[0,&#39;index&#39;]):
        for i in indices:
            file_name = self.eoddata[i,&#39;file&#39;] if &#39;file&#39; in self.eoddata else basename
            if np.isfinite(self.eoddata[i,&#39;index&#39;]):
                print(&#39;%s : %d&#39; % (file_name, self.eoddata[i,&#39;index&#39;]))
            else:
                print(file_name)
    elif &#39;file&#39; in self.eoddata:
        for i in indices:
            print(self.eoddata[i,&#39;file&#39;])
    if len(indices) == 1:
        # write eoddata line on terminal:
        keylen = 0
        keys = []
        values = []
        for c in range(self.eoddata.columns()):
            k, v = self.eoddata.key_value(indices[0], c)
            keys.append(k)
            values.append(v)
            if keylen &lt; len(k):
                keylen = len(k)
        for k, v in zip(keys, values):
            fs = &#39;%%-%ds: %%s&#39; % keylen
            print(fs % (k, v.strip()))</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="thunderfish.multivariateexplorer.MultivariateExplorer" href="multivariateexplorer.html#thunderfish.multivariateexplorer.MultivariateExplorer">MultivariateExplorer</a></b></code>:
<ul class="hlist">
<li><code><a title="thunderfish.multivariateexplorer.MultivariateExplorer.compute_pca" href="multivariateexplorer.html#thunderfish.multivariateexplorer.MultivariateExplorer.compute_pca">compute_pca</a></code></li>
<li><code><a title="thunderfish.multivariateexplorer.MultivariateExplorer.save_pca" href="multivariateexplorer.html#thunderfish.multivariateexplorer.MultivariateExplorer.save_pca">save_pca</a></code></li>
<li><code><a title="thunderfish.multivariateexplorer.MultivariateExplorer.set_colors" href="multivariateexplorer.html#thunderfish.multivariateexplorer.MultivariateExplorer.set_colors">set_colors</a></code></li>
<li><code><a title="thunderfish.multivariateexplorer.MultivariateExplorer.set_wave_data" href="multivariateexplorer.html#thunderfish.multivariateexplorer.MultivariateExplorer.set_wave_data">set_wave_data</a></code></li>
<li><code><a title="thunderfish.multivariateexplorer.MultivariateExplorer.show" href="multivariateexplorer.html#thunderfish.multivariateexplorer.MultivariateExplorer.show">show</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="thunderfish.eodexplorer.PrintHelp"><code class="flex name class">
<span>class <span class="ident">PrintHelp</span></span>
<span>(</span><span>option_strings, dest, nargs=None, const=None, default=None, type=None, choices=None, required=False, help=None, metavar=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Information about how to convert command line strings to Python objects.</p>
<p>Action objects are used by an ArgumentParser to represent the information
needed to parse a single argument from one or more strings from the
command line. The keyword arguments to the Action constructor are also
all attributes of Action instances.</p>
<p>Keyword Arguments:</p>
<pre><code>- option_strings -- A list of command-line option strings which
    should be associated with this action.

- dest -- The name of the attribute to hold the created object(s)

- nargs -- The number of command-line arguments that should be
    consumed. By default, one argument will be consumed and a single
    value will be produced.  Other values include:
        - N (an integer) consumes N arguments (and produces a list)
        - '?' consumes zero or one arguments
        - '*' consumes zero or more arguments (and produces a list)
        - '+' consumes one or more arguments (and produces a list)
    Note that the difference between the default and nargs=1 is that
    with the default, a single value will be produced, while with
    nargs=1, a list containing a single value will be produced.

- const -- The value to be produced if the option is specified and the
    option uses an action that takes no values.

- default -- The value to be produced if the option is not specified.

- type -- A callable that accepts a single string argument, and
    returns the converted value.  The standard Python types str, int,
    float, and complex are useful examples of such callables.  If None,
    str is used.

- choices -- A container of values that should be allowed. If not None,
    after a command-line argument has been converted to the appropriate
    type, an exception will be raised if it is not a member of this
    collection.

- required -- True if the action must always be specified at the
    command line. This is only meaningful for optional command-line
    arguments.

- help -- The help string describing the argument.

- metavar -- The name to be used for the option's argument with the
    help string. If None, the 'dest' value will be used as the name.
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class PrintHelp(argparse.Action):
    def __call__(self, parser, namespace, values, option_string):
        parser.print_help()
        print(&#39;&#39;)
        print(&#39;mouse:&#39;)
        for ma in MultivariateExplorer.mouse_actions:
            print(&#39;%-23s %s&#39; % ma)
        print(&#39;%-23s %s&#39; % (&#39;double left click&#39;, &#39;run thunderfish on selected EOD waveform&#39;))
        print(&#39;&#39;)
        print(&#39;key shortcuts:&#39;)
        for ka in MultivariateExplorer.key_actions:
            print(&#39;%-23s %s&#39; % ka)
        parser.exit()      </code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>argparse.Action</li>
<li>argparse._AttributeHolder</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="thunderfish" href="index.html">thunderfish</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="thunderfish.eodexplorer.load_waveform" href="#thunderfish.eodexplorer.load_waveform">load_waveform</a></code></li>
<li><code><a title="thunderfish.eodexplorer.main" href="#thunderfish.eodexplorer.main">main</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="thunderfish.eodexplorer.EODExplorer" href="#thunderfish.eodexplorer.EODExplorer">EODExplorer</a></code></h4>
<ul class="">
<li><code><a title="thunderfish.eodexplorer.EODExplorer.analyze_selection" href="#thunderfish.eodexplorer.EODExplorer.analyze_selection">analyze_selection</a></code></li>
<li><code><a title="thunderfish.eodexplorer.EODExplorer.fix_scatter_plot" href="#thunderfish.eodexplorer.EODExplorer.fix_scatter_plot">fix_scatter_plot</a></code></li>
<li><code><a title="thunderfish.eodexplorer.EODExplorer.fix_waveform_plot" href="#thunderfish.eodexplorer.EODExplorer.fix_waveform_plot">fix_waveform_plot</a></code></li>
<li><code><a title="thunderfish.eodexplorer.EODExplorer.groups" href="#thunderfish.eodexplorer.EODExplorer.groups">groups</a></code></li>
<li><code><a title="thunderfish.eodexplorer.EODExplorer.list_selection" href="#thunderfish.eodexplorer.EODExplorer.list_selection">list_selection</a></code></li>
<li><code><a title="thunderfish.eodexplorer.EODExplorer.select_EOD_properties" href="#thunderfish.eodexplorer.EODExplorer.select_EOD_properties">select_EOD_properties</a></code></li>
<li><code><a title="thunderfish.eodexplorer.EODExplorer.select_color_property" href="#thunderfish.eodexplorer.EODExplorer.select_color_property">select_color_property</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="thunderfish.eodexplorer.PrintHelp" href="#thunderfish.eodexplorer.PrintHelp">PrintHelp</a></code></h4>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>