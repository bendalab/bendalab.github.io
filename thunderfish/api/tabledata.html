<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>thunderfish.tabledata API documentation</title>
<meta name="description" content="Tables with hierarchical headers and units â€¦" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS_CHTML" integrity="sha256-kZafAc6mZvK3W3v1pHOcUix30OHQN6pU/NO2oFkqZVw=" crossorigin></script>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>thunderfish.tabledata</code></h1>
</header>
<section id="section-intro">
<p>Tables with hierarchical headers and units</p>
<h2 id="classes">Classes</h2>
<ul>
<li><code>class <a title="thunderfish.tabledata.TableData" href="#thunderfish.tabledata.TableData">TableData</a></code>: tables with a rich hierarchical header
including units and column-specific formats. Kind of similar to a
pandas data frame, but with intuitive numpy-style indexing and nicely
formatted output to csv, html, and latex.</li>
</ul>
<h2 id="helper-functions">Helper functions</h2>
<ul>
<li><code><a title="thunderfish.tabledata.write" href="#thunderfish.tabledata.write">write()</a></code>: shortcut for constructing and writing a TableData.</li>
<li><code><a title="thunderfish.tabledata.latex_unit" href="#thunderfish.tabledata.latex_unit">latex_unit()</a></code>: translate unit string into SIunit LaTeX code.</li>
<li><code><a title="thunderfish.tabledata.index2aa" href="#thunderfish.tabledata.index2aa">index2aa()</a></code>: convert an integer into an alphabetical representation.</li>
<li><code><a title="thunderfish.tabledata.aa2index" href="#thunderfish.tabledata.aa2index">aa2index()</a></code>: convert an alphabetical representation to an index.</li>
</ul>
<h2 id="configuration">Configuration</h2>
<ul>
<li><code><a title="thunderfish.tabledata.add_write_table_config" href="#thunderfish.tabledata.add_write_table_config">add_write_table_config()</a></code>: add parameter specifying how to write a table to a file as a new section to a configuration.</li>
<li><code><a title="thunderfish.tabledata.write_table_args" href="#thunderfish.tabledata.write_table_args">write_table_args()</a></code>: translates a configuration to the respective parameter names for writing a table to a file.</li>
</ul>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
Tables with hierarchical headers and units

## Classes

- `class TableData`: tables with a rich hierarchical header
  including units and column-specific formats. Kind of similar to a
  pandas data frame, but with intuitive numpy-style indexing and nicely
  formatted output to csv, html, and latex.


## Helper functions

- `write()`: shortcut for constructing and writing a TableData.
- `latex_unit()`: translate unit string into SIunit LaTeX code.
- `index2aa()`: convert an integer into an alphabetical representation.
- `aa2index()`: convert an alphabetical representation to an index.


## Configuration

- `add_write_table_config()`: add parameter specifying how to write a table to a file as a new section to a configuration.
- `write_table_args()`: translates a configuration to the respective parameter names for writing a table to a file.
&#34;&#34;&#34;

import sys
import os
import re
import math as m
import numpy as np
if sys.version_info[0] &lt; 3:
    from io import BytesIO as StringIO
else:
    from io import StringIO
try:
    import pandas as pd
except ImportError:
    pass


__pdoc__ = {}
__pdoc__[&#39;TableData.__contains__&#39;] = True
__pdoc__[&#39;TableData.__len__&#39;] = True
__pdoc__[&#39;TableData.__iter__&#39;] = True
__pdoc__[&#39;TableData.__next__&#39;] = True
__pdoc__[&#39;TableData.__setupkey__&#39;] = True
__pdoc__[&#39;TableData.__call__&#39;] = True
__pdoc__[&#39;TableData.__getitem__&#39;] = True
__pdoc__[&#39;TableData.__setitem__&#39;] = True
__pdoc__[&#39;TableData.__delitem__&#39;] = True
__pdoc__[&#39;TableData.__str__&#39;] = True


class TableData(object):
    &#34;&#34;&#34;Table with numpy-style indexing and a rich hierarchical header including units and formats.
    
    Parameters
    ----------
    data: string, stream, array
        - a filename: load table from file with name `data`.
        - a stream/file handle: load table from that stream.
        - 1-D or 2-D array of data: the data of the table.
          Requires als a specified `header`.
    header: list of string
        Header labels for each column.
    units: list of string, optional
        Unit strings for each column.
    formats: string or list of string, optional
        Format strings for each column. If only a single format string is
        given, then all columns are initialized with this format string.
    missing: string
        Missing data are indicated by this string.

    Manipulate table header
    -----------------------

    Each column of the table has a label (the name of the column), a
    unit, and a format specifier. Sections group columns into a hierarchy.

    - `__init__()`: initialize a TableData from data or a file.
    - `append()`: append column to the table.
    - `insert()`: insert a table column at a given position.
    - `remove()`: remove columns from the table.
    - `section()`: the section name of a specified column.
    - `set_section()`: set a section name.
    - `append_section()`: add sections to the table header.
    - `insert_section()`: insert a section at a given position of the table header.
    - `label()`: the name of a column.
    - `set_label()`: set the name of a column.
    - `unit()`: the unit of a column.
    - `set_unit()`: set the unit of a column.
    - `set_units()`: set the units of all columns.
    - `format()`: the format string of the column.
    - `set_format()`: set the format string of a column.
    - `set_formats()`: set the format strings of all columns.

    For example:
    ```
    tf = TableData(&#39;data.csv&#39;)
    ```
    loads a table directly from a file. See `load()` for details.
    ```
    tf = TableData(np.random.randn(4,3), header=[&#39;aaa&#39;, &#39;bbb&#39;, &#39;ccc&#39;], units=[&#39;m&#39;, &#39;s&#39;, &#39;g&#39;], formats=&#39;%.2f&#39;)    
    ```
    results in
    ``` plain
    aaa    bbb    ccc
    m      s      g    
     1.45   0.01   0.16
    -0.74  -0.58  -1.34
    -2.06   0.08   1.47
    -0.43   0.60   1.38
    ```

    A more elaborate way to construct a table is:
    ```
    df = TableData()
    # first column with section names and 3 data values:
    df.append([&#34;data&#34;, &#34;partial information&#34;, &#34;size&#34;], &#34;m&#34;, &#34;%6.2f&#34;,
              [2.34, 56.7, 8.9])
    # next columns with single data values:
    df.append(&#34;full weight&#34;, &#34;kg&#34;, &#34;%.0f&#34;, 122.8)
    df.append_section(&#34;complete reaction&#34;)
    df.append(&#34;speed&#34;, &#34;m/s&#34;, &#34;%.3g&#34;, 98.7)
    df.append(&#34;median jitter&#34;, &#34;mm&#34;, &#34;%.1f&#34;, 23)
    df.append(&#34;size&#34;, &#34;g&#34;, &#34;%.2e&#34;, 1.234)
    # add a missing value to the second column:
    df.append_data(np.nan, 1)
    # fill up the remaining columns of the row:
    df.append_data((0.543, 45, 1.235e2))
    # append data to the next row starting at the second column:
    df.append_data((43.21, 6789.1, 3405, 1.235e-4), 1) # next row
    ```
    results in
    ``` plain
    data
    partial information  complete reaction
    size    full weight  speed     median jitter  size
    m       kg           m/s       mm             g       
      2.34          123      98.7           23.0  1.23e+00
     56.70            -     0.543           45.0  1.24e+02
      8.90           43  6.79e+03         3405.0  1.23e-04
    ```
    
    Table columns
    -------------

    Columns can be specified by an index or by the name of a column. In
    table headers with sections the colum can be specified by the
    section names and the column name separated by &#39;&gt;&#39;.
    
    - `index()`: the index of a column.
    - `__contains__()`: check for existence of a column.
    - `find_col()`: find the start and end index of a column specification.
    - `column_spec()`: full specification of a column with all its section names.
    - `column_head()`: the name, unit, and format of a column.
    - `table_header()`: the header of the table without content.

    For example:
    ```
    df.index(&#39;complete reaction&gt;size)   # returns 4
    &#39;speed&#39; in df                       # is True
    ```

    Iterating over columns
    ----------------------

    A table behaves like an ordered dictionary with column names as
    keys and the data of each column as values.
    Iterating over a table goes over columns.
    
    - `keys()`: list of unique column keys for all available columns.
    - `values()`: list of column data corresponding to keys().
    - `items()`: list of tuples with unique column specifications and the corresponding data.
    - `__len__()`: the number of columns.
    - `__iter__()`: initialize iteration over data columns.
    - `__next__()`: return data of next column as a list.
    - `data`: the table data as a list over columns each containing a list of data elements.

    For example:
    ```
    print(&#39;column specifications:&#39;)
    for c in range(df.columns()):
        print(df.column_spec(c))
    print(&#39;keys():&#39;)
    for c, k in enumerate(df.keys()):
        print(&#39;%d: %s&#39; % (c, k))
    print(&#39;values():&#39;)
    for c, v in enumerate(df.values()):
        print(v)
    print(&#39;iterating over the table:&#39;)
    for v in df:
        print(v)
    ```
    results in
    ``` plain
    column specifications:
    data&gt;partial information&gt;size
    data&gt;partial information&gt;full weight
    data&gt;complete reaction&gt;speed
    data&gt;complete reaction&gt;median jitter
    data&gt;complete reaction&gt;size
    keys():
    0: data&gt;partial information&gt;size
    1: data&gt;partial information&gt;full weight
    2: data&gt;complete reaction&gt;speed
    3: data&gt;complete reaction&gt;median jitter
    4: data&gt;complete reaction&gt;size
    values():
    [2.34, 56.7, 8.9]
    [122.8, nan, 43.21]
    [98.7, 0.543, 6789.1]
    [23, 45, 3405]
    [1.234, 123.5, 0.0001235]
    iterating over the table:
    [2.34, 56.7, 8.9]
    [122.8, nan, 43.21]
    [98.7, 0.543, 6789.1]
    [23, 45, 3405]
    [1.234, 123.5, 0.0001235]
    ```

    Accessing data
    --------------

    In contrast to the iterator functions the [] operator treats the table as a
    2D-array where the first index indicates the row and the second index the column.

    Like a numpy aray the table can be sliced, and logical indexing can
    be used to select specific parts of the table.
    
    As for any function, columns can be specified as indices or strings.
    
    - `rows()`: the number of rows.
    - `columns()`: the number of columns.
    - `shape`: number of rows and columns.
    - `row()`: a single row of the table as TableData.
    - `row_dict()`: a single row of the table as dictionary.
    - `col()`: a single column of the table as TableData.
    - `__call__()`: a single column of the table as numpy array.
    - `__getitem__()`: data elements specified by slice.
    - `__setitem__()`: assign values to data elements specified by slice.
    - `__delitem__()`: delete data elements or whole columns or rows.
    - `array()`: the table data as a numpy array.
    - `data_frame()`: the table data as a pandas DataFrame.
    - `dicts()`: the table as a list of dictionaries.
    - `dict()`: the table as a dictionary.
    - `append_data()`: append data elements to successive columns.
    - `append_data_column()`: append data elements to a column.
    - `set_column()`: set the column where to add data.
    - `fill_data()`: fill up all columns with missing data.
    - `clear_data()`: clear content of the table but keep header.
    - `key_value()`: a data element returned as a key-value pair.
    
    - `sort()`: sort the table rows in place.
    - `statistics()`: descriptive statistics of each column.

    For example:
    ```
    # single column:    
    df(&#39;size&#39;)     # data of &#39;size&#39; column as numpy array
    df[:,&#39;size&#39;]   # data of &#39;size&#39; column as numpy array
    df.col(&#39;size&#39;) # table with the single column &#39;size&#39;

    # single row:    
    df[2,:]    # table with data of only the third row
    df.row(2)  # table with data of only the third row

    # slices:
    df[2:5,[&#39;size&#39;,&#39;jitter&#39;]]          # sub-table
    df[2:5,[&#39;size&#39;,&#39;jitter&#39;]].array()  # numpy array with data only

    # logical indexing:
    df[df(&#39;speed&#39;) &gt; 100.0, &#39;size&#39;] = 0.0 # set size to 0 if speed is &gt; 100

    # delete:
    del df[3:6, &#39;weight&#39;]  # delete rows 3-6 from column &#39;weight&#39;
    del df[3:5,:]          # delete rows 3-5 completeley
    del df[:,&#39;speed&#39;]      # remove column &#39;speed&#39; from table
    df.remove(&#39;weight&#39;)    # remove column &#39;weigth&#39; from table

    # sort and statistics:
    df.sort([&#39;weight&#39;, &#39;jitter&#39;])
    df.statistics()
    ```
    statistics() returns a table with standard descriptive statistics:
    ``` plain
    statistics  data
    -           partial information  complete reaction
    -           size    full weight  speed     median jitter  size
    -           m       kg           m/s       mm             g       
    mean         22.65           83   2.3e+03         1157.7  4.16e+01
    std          24.23           40  3.18e+03         1589.1  5.79e+01
    min           2.34           43     0.543           23.0  1.23e-04
    quartile1     5.62           83      49.6           34.0  6.17e-01
    median        8.90          123      98.7           45.0  1.23e+00
    quartile3    32.80            -  3.44e+03         1725.0  6.24e+01
    max          56.70          123  6.79e+03         3405.0  1.24e+02
    count         3.00            2         3            3.0  3.00e+00
    ```

    Write and load tables
    ---------------------

    Table data can be written to a variety of text-based formats
    including comma separated values, latex and html files.  Which
    columns are written can be controlled by the hide() and show()
    functions. TableData can be loaded from all the written file formats
    (except html), also directly via the constructor.
    
    - `hide()`: hide a column or a range of columns.
    - `hide_all()`: hide all columns.
    - `hide_empty_columns()`: hide all columns that do not contain data.
    - `show()`: show a column or a range of columns.
    - `write()`: write the table to a file or stream.
    - `__str__()`: write table to a string.
    - `load()`: load table from file or stream.
    - `formats`: list of supported file formats for writing.
    - `descriptions`: dictionary with descriptions of the supported file formats.
    - `extensions`: dictionary with default filename extensions for each of the file formats.
    - `ext_formats`: dictionary mapping filename extensions to file formats.

    See documentation of the `write()` function for examples of the supported file formats.
    &#34;&#34;&#34;
    
    formats = [&#39;dat&#39;, &#39;ascii&#39;, &#39;csv&#39;, &#39;rtai&#39;, &#39;md&#39;, &#39;tex&#39;, &#39;html&#39;]
    &#34;&#34;&#34;list of strings: Supported output formats.&#34;&#34;&#34;
    descriptions = {&#39;dat&#39;: &#39;data text file&#39;, &#39;ascii&#39;: &#39;ascii-art table&#39;,
                    &#39;csv&#39;: &#39;comma separated values&#39;, &#39;rtai&#39;: &#39;rtai-style table&#39;,
                    &#39;md&#39;: &#39;markdown&#39;, &#39;tex&#39;: &#39;latex tabular&#39;,
                    &#39;html&#39;: &#39;html markup&#39;}
    &#34;&#34;&#34;dict: Decription of output formats corresponding to `formats`.&#34;&#34;&#34;
    extensions = {&#39;dat&#39;: &#39;dat&#39;, &#39;ascii&#39;: &#39;txt&#39;, &#39;csv&#39;: &#39;csv&#39;, &#39;rtai&#39;: &#39;dat&#39;,
                  &#39;md&#39;: &#39;md&#39;, &#39;tex&#39;: &#39;tex&#39;, &#39;html&#39;: &#39;html&#39;}
    &#34;&#34;&#34;dict: Default file extensions for the output `formats`. &#34;&#34;&#34;
    ext_formats = {&#39;dat&#39;: &#39;dat&#39;, &#39;DAT&#39;: &#39;dat&#39;, &#39;txt&#39;: &#39;dat&#39;, &#39;TXT&#39;: &#39;dat&#39;,
                   &#39;csv&#39;: &#39;csv&#39;, &#39;CSV&#39;: &#39;csv&#39;, &#39;md&#39;: &#39;md&#39;, &#39;MD&#39;: &#39;md&#39;,
                   &#39;tex&#39;: &#39;tex&#39;, &#39;TEX&#39;: &#39;tex&#39;, &#39;html&#39;: &#39;html&#39;, &#39;HTML&#39;: &#39;html&#39;}
    &#34;&#34;&#34;dict: Mapping of file extensions to the output formats.&#34;&#34;&#34;

    def __init__(self, data=None, header=None, units=None, formats=None,
                 missing=&#39;-&#39;):
        self.data = []
        self.shape = (0, 0)
        self.header = []
        self.nsecs = 0
        self.units = []
        self.formats = []
        self.hidden = []
        self.setcol = 0
        self.addcol = 0
        if header is not None:
            if units is None:
                units = [&#39;&#39;]*len(header)
            if formats is None:
                formats = [&#39;%g&#39;]*len(header)
            elif not isinstance(formats, (list, tuple, np.ndarray)):
                formats = [formats]*len(header)
            for h, u, f in zip(header, units, formats):
                self.append(h, u, f)            
        if data is not None:
            if isinstance(data, TableData):
                self.shape = data.shape
                self.nsecs = data.nsecs
                self.setcol = data.setcol
                self.addcol = data.addcol
                for c in range(data.columns()):
                    self.header.append([])
                    for h in data.header[c]:
                        self.header[c].append(h)
                    self.units.append(data.units[c])
                    self.formats.append(data.formats[c])
                    self.hidden.append(data.hidden[c])
                    self.data.append([])
                    for d in data.data[c]:
                        self.data[c].append(d)
            elif isinstance(data, (list, tuple, np.ndarray)):
                if isinstance(data[0], (list, tuple, np.ndarray)):
                    # 2D list, rows first:
                    for row in data:
                        for c, val in enumerate(row):
                            self.data[c].append(val)
                else:
                    # 1D list:
                    for c, val in enumerate(data):
                        self.data[c].append(val)
            else:
                self.load(data, missing)
        
    def append(self, label, unit=None, formats=None, value=None, key=None, fac=None):
        &#34;&#34;&#34;Append column to the table.

        Parameters
        ----------
        label: string or list of string
            Optional section titles and the name of the column.
        unit: string or None
            The unit of the column contents.
        formats: string or None
            The C-style format string used for printing out the column content, e.g.
            &#39;%g&#39;, &#39;%.2f&#39;, &#39;%s&#39;, etc.
            If None, the format is set to &#39;%g&#39;.
        value: None, float, int, string, etc. or list thereof, or list of dict
            If not None, data for the column.
        key: None or key of a dictionary
            If not None and `value` is a list of dictionaries,
            extract from each dictionary in the list the value specified
            by `key` and assign the resulting list as data to the column.
        fac: float
            If not None, multiply the data values by this number.

        Returns
        -------
        index: int
            The index of the new column.
        &#34;&#34;&#34;
        if self.addcol &gt;= len(self.data):
            if isinstance(label, (list, tuple, np.ndarray)):
                self.header.append(list(reversed(label)))
            else:
                self.header.append([label])
            self.formats.append(formats or &#39;%g&#39;)
            self.units.append(unit or &#39;&#39;)
            self.hidden.append(False)
            self.data.append([])
            if self.nsecs &lt; len(self.header[-1])-1:
                self.nsecs = len(self.header[-1])-1
        else:
            if isinstance(label, (list, tuple, np.ndarray)):
                self.header[self.addcol] = list(reversed(label)) + self.header[self.addcol]
            else:
                self.header[self.addcol] = [label] + self.header[self.addcol]
            self.units[self.addcol] = unit or &#39;&#39;
            self.formats[self.addcol] = formats or &#39;%g&#39;
            if self.nsecs &lt; len(self.header[self.addcol])-1:
                self.nsecs = len(self.header[self.addcol])-1
        if value is not None:
            if isinstance(value, (list, tuple, np.ndarray)):
                if key and value and isinstance(value[0], dict):
                    value = [d[key] if key in d else float(&#39;nan&#39;) for d in value]
                self.data[-1].extend(value)
            else:
                self.data[-1].append(value)
        if fac:
            for k in range(len(self.data[-1])):
                self.data[-1][k] *= fac
        self.addcol = len(self.data)
        self.shape = (self.rows(), self.columns())
        return self.addcol-1
        
    def insert(self, column, label, unit=None, formats=None, value=None):
        &#34;&#34;&#34;Insert a table column at a given position.

        .. WARNING::
           If no `value` is given, the inserted column is an empty list.

        Parameters
        ----------
        columns int or string
            Column before which to insert the new column.
            Column can be specified by index or name,
            see `index()` for details.
        label: string or list of string
            Optional section titles and the name of the column.
        unit: string or None
            The unit of the column contents.
        formats: string or None
            The C-style format string used for printing out the column content, e.g.
            &#39;%g&#39;, &#39;%.2f&#39;, &#39;%s&#39;, etc.
            If None, the format is set to &#39;%g&#39;.
        value: None, float, int, string, etc. or list thereof
            If not None, data for the column.

        Returns
        -------
        index: int
            The index of the inserted column.
            
        Raises
        ------
        IndexError:
            If an invalid column was specified.
        &#34;&#34;&#34;
        col = self.index(column)
        if col is None:
            if isinstance(column, (int, np.integer)):
                column = &#39;%d&#39; % column
            raise IndexError(&#39;Cannot insert before non-existing column &#39; + column)
        if isinstance(label, (list, tuple, np.ndarray)):
            self.header.insert(col, list(reversed(label)))
        else:
            self.header.insert(col, [label])
        self.formats.insert(col, formats or &#39;%g&#39;)
        self.units.insert(col, unit or &#39;&#39;)
        self.hidden.insert(col, False)
        self.data.insert(col, [])
        if self.nsecs &lt; len(self.header[col])-1:
            self.nsecs = len(self.header[col])-1
        if value is not None:
            if isinstance(value, (list, tuple, np.ndarray)):
                self.data[col].extend(value)
            else:
                self.data[col].append(value)
        self.addcol = len(self.data)
        self.shape = (self.rows(), self.columns())
        return col

    def remove(self, columns):
        &#34;&#34;&#34;Remove columns from the table.

        Parameters
        -----------
        columns: int or string or list of int or string
            Columns can be specified by index or name,
            see `index()` for details.

        Raises
        ------
        IndexError:
            If an invalid column was specified.
        &#34;&#34;&#34;
        # fix columns:
        if not isinstance(columns, (list, tuple, np.ndarray)):
            columns = [ columns ]
        if not columns:
            return
        # remove:
        for col in columns:
            c = self.index(col)
            if c is None:
                if isinstance(col, (int, np.integer)):
                    col = &#39;%d&#39; % col
                raise IndexError(&#39;Cannot remove non-existing column &#39; + col)
                continue
            if c+1 &lt; len(self.header):
                self.header[c+1].extend(self.header[c][len(self.header[c+1]):])
            del self.header[c]
            del self.units[c]
            del self.formats[c]
            del self.hidden[c]
            del self.data[c]
        if self.setcol &gt; len(self.data):
            self.setcol = len(self.data)
        self.shape = (self.rows(), self.columns())

    def section(self, column, level):
        &#34;&#34;&#34;The section name of a specified column.

        Parameters
        ----------
        column: None, int, or string
            A specification of a column.
            See self.index() for more information on how to specify a column.
        level: int
            The level of the section to be returned. The column label itself is level=0.

        Returns
        -------
        name: string
            The name of the section at the specified level containing the column.
        index: int
            The column index that contains this section (equal or smaller thant `column`).

        Raises
        ------
        IndexError:
            If `level` exceeds the maximum possible level.
        &#34;&#34;&#34;
        if level &lt; 0 or level &gt; self.nsecs:
            raise IndexError(&#39;Invalid section level&#39;)
        column = self.index(column)
        while len(self.header[column]) &lt;= level:
            column -= 1
        return self.header[column][level], column
    
    def set_section(self, label, column, level):
        &#34;&#34;&#34;Set a section name.

        Parameters
        ----------
        label: string
            The new name to be used for the section.
        column: None, int, or string
            A specification of a column.
            See self.index() for more information on how to specify a column.
        level: int
            The level of the section to be set. The column label itself is level=0.
        &#34;&#34;&#34;
        column = self.index(column)
        self.header[column][level] = label
        return column

    def append_section(self, label):
        &#34;&#34;&#34;Add sections to the table header.

        Each column of the table has a header label. Columns can be
        grouped into sections. Sections can be nested arbitrarily.

        Parameters
        ----------
        label: string or list of string
            The name(s) of the section(s).

        Returns
        -------
        index: int
            The column index where the section was appended.
        &#34;&#34;&#34;
        if self.addcol &gt;= len(self.data):
            if isinstance(label, (list, tuple, np.ndarray)):
                self.header.append(list(reversed(label)))
            else:
                self.header.append([label])
            self.units.append(&#39;&#39;)
            self.formats.append(&#39;&#39;)
            self.hidden.append(False)
            self.data.append([])
        else:
            if isinstance(label, (list, tuple, np.ndarray)):
                self.header[self.addcol] = list(reversed(label)) + self.header[self.addcol]
            else:
                self.header[self.addcol] = [label] + self.header[self.addcol]
        if self.nsecs &lt; len(self.header[self.addcol]):
            self.nsecs = len(self.header[self.addcol])
        self.addcol = len(self.data)-1
        self.shape = (self.rows(), self.columns())
        return self.addcol
        
    def insert_section(self, column, section):
        &#34;&#34;&#34;Insert a section at a given position of the table header.

        Parameters
        ----------
        columns int or string
            Column before which to insert the new section.
            Column can be specified by index or name,
            see `index()` for details.
        section: string
            The name of the section.

        Returns
        -------
        index: int
            The index of the column where the section was inserted.
            
        Raises
        ------
        IndexError:
            If an invalid column was specified.
        &#34;&#34;&#34;
        col = self.index(column)
        if col is None:
            if isinstance(column, (int, np.integer)):
                column = &#39;%d&#39; % column
            raise IndexError(&#39;Cannot insert at non-existing column &#39; + column)
        self.header[col].append(section)
        if self.nsecs &lt; len(self.header[col])-1:
            self.nsecs = len(self.header[col])-1
        return col

    def label(self, column):
        &#34;&#34;&#34;The name of a column.

        Parameters
        ----------
        column: None, int, or string
            A specification of a column.
            See self.index() for more information on how to specify a column.

        Returns
        -------
        name: string
            The column label.
        &#34;&#34;&#34;
        column = self.index(column)
        return self.header[column][0]

    def set_label(self, label, column):
        &#34;&#34;&#34;Set the name of a column.

        Parameters
        ----------
        label: string
            The new name to be used for the column.
        column: None, int, or string
            A specification of a column.
            See self.index() for more information on how to specify a column.
        &#34;&#34;&#34;        
        column = self.index(column)
        self.header[column][0] = label
        return column

    def unit(self, column):
        &#34;&#34;&#34;The unit of a column.

        Parameters
        ----------
        column: None, int, or string
            A specification of a column.
            See self.index() for more information on how to specify a column.

        Returns
        -------
        unit: string
            The unit.
        &#34;&#34;&#34;
        column = self.index(column)
        return self.units[column]

    def set_unit(self, unit, column):
        &#34;&#34;&#34;Set the unit of a column.

        Parameters
        ----------
        unit: string
            The new unit to be used for the column.
        column: None, int, or string
            A specification of a column.
            See self.index() for more information on how to specify a column.
        &#34;&#34;&#34;
        column = self.index(column)
        self.units[column] = unit
        return column

    def set_units(self, units):
        &#34;&#34;&#34;Set the units of all columns.

        Parameters
        ----------
        units: list of string
            The new units to be used.
        &#34;&#34;&#34;
        for c, u in enumerate(units):
            self.units[c] = u

    def format(self, column):
        &#34;&#34;&#34;The format string of the column.

        Parameters
        ----------
        column: None, int, or string
            A specification of a column.
            See self.index() for more information on how to specify a column.

        Returns
        -------
        format: string
            The format string.
        &#34;&#34;&#34;
        column = self.index(column)
        return self.formats[column]

    def set_format(self, format, column):
        &#34;&#34;&#34;Set the format string of a column.

        Parameters
        ----------
        format: string
            The new format string to be used for the column.
        column: None, int, or string
            A specification of a column.
            See self.index() for more information on how to specify a column.
        &#34;&#34;&#34;
        column = self.index(column)
        self.formats[column] = format
        return column

    def set_formats(self, formats):
        &#34;&#34;&#34;Set the format strings of all columns.

        Parameters
        ----------
        formats: string or list of string
            The new format strings to be used.
            If only a single format is specified,
            then all columns get the same format.
        &#34;&#34;&#34;
        if isinstance(formats, (list, tuple, np.ndarray)):
            for c, f in enumerate(formats):
                self.formats[c] = f or &#39;%g&#39;
        else:
            for c in range(len(self.formats)):
                self.formats[c] = formats or &#39;%g&#39;

    def table_header(self):
        &#34;&#34;&#34;The header of the table without content.

        Returns
        -------
        data: TableData
            A TableData object with the same header but empty data.
        &#34;&#34;&#34;
        data = TableData()
        sec_indices = [-1] * self.nsecs
        for c in range(self.columns()):
            data.append(*self.column_head(c))
            for l in range(self.nsecs):
                s, i = self.section(c, l+1)
                if i != sec_indices[l]:
                    data.header[-1].append(s)
                    sec_indices[l] = i
        data.nsecs = self.nsecs
        return data

    def column_head(self, column):
        &#34;&#34;&#34;The name, unit, and format of a column.

        Parameters
        ----------
        column: None, int, or string
            A specification of a column.
            See self.index() for more information on how to specify a column.

        Returns
        -------
        name: string
            The column label.
        unit: string
            The unit.
        format: string
            The format string.
        &#34;&#34;&#34;
        column = self.index(column)
        return self.header[column][0], self.units[column], self.formats[column]

    def column_spec(self, column):
        &#34;&#34;&#34;Full specification of a column with all its section names.

        Parameters
        ----------
        column: int or string
            Specifies the column.
            See self.index() for more information on how to specify a column.

        Returns
        -------
        s: string
            Full specification of the column by all its section names and its header name.
        &#34;&#34;&#34;
        c = self.index(column)
        fh = [self.header[c][0]]
        for l in range(self.nsecs):
            fh.append(self.section(c, l+1)[0])
        return &#39;&gt;&#39;.join(reversed(fh))
    
    def find_col(self, column):
        &#34;&#34;&#34;Find the start and end index of a column specification.
        
        Parameters
        ----------
        column: None, int, or string
            A specification of a column.
            See self.index() for more information on how to specify a column.

        Returns
        -------
        c0: int or None
            A valid column index or None that is specified by `column`.
        c1: int or None
            A valid column index or None of the column following the range specified
            by `column`.
        &#34;&#34;&#34;

        def find_column_indices(ss, si, minns, maxns, c0, strict=True):
            if si &gt;= len(ss):
                return None, None, None, None
            ns0 = 0
            for ns in range(minns, maxns+1):
                nsec = maxns-ns
                if ss[si] == &#39;&#39;:
                    si += 1
                    continue
                for c in range(c0, len(self.header)):
                    if nsec &lt; len(self.header[c]) and \
                        ( ( strict and self.header[c][nsec] == ss[si] ) or
                          ( not strict and ss[si] in self.header[c][nsec] ) ):
                        ns0 = ns
                        c0 = c
                        si += 1
                        if si &gt;= len(ss):
                            c1 = len(self.header)
                            for c in range(c0+1, len(self.header)):
                                if nsec &lt; len(self.header[c]):
                                    c1 = c
                                    break
                            return c0, c1, ns0, None
                        elif nsec &gt; 0:
                            break
            return None, c0, ns0, si

        if column is None:
            return None, None
        if not isinstance(column, (int, np.integer)) and column.isdigit():
            column = int(column)
        if isinstance(column, (int, np.integer)):
            if column &gt;= 0 and column &lt; len(self.header):
                return column, column+1
            else:
                return None, None
        # find column by header:
        ss = column.rstrip(&#39;&gt;&#39;).split(&#39;&gt;&#39;)
        maxns = self.nsecs
        si0 = 0
        while si0 &lt; len(ss) and ss[si0] == &#39;&#39;:
            maxns -= 1
            si0 += 1
        if maxns &lt; 0:
            maxns = 0
        c0, c1, ns, si = find_column_indices(ss, si0, 0, maxns, 0, True)
        if c0 is None and c1 is not None:
            c0, c1, ns, si = find_column_indices(ss, si, ns, maxns, c1, False)
        return c0, c1

    def index(self, column):
        &#34;&#34;&#34;The index of a column.
        
        Parameters
        ----------
        column: None, int, or string
            A specification of a column.
            - None: no column is specified
            - int: the index of the column (first column is zero), e.g. `index(2)`.
            - a string representing an integer is converted into the column index,
              e.g. `index(&#39;2&#39;)`
            - a string specifying a column by its header.
              Header names of descending hierarchy are separated by &#39;&gt;&#39;.

        Returns
        -------
        index: int or None
            A valid column index or None.
        &#34;&#34;&#34;
        c0, c1 = self.find_col(column)
        return c0

    def __contains__(self, column):
        &#34;&#34;&#34;Check for existence of a column.

        Parameters
        ----------
        column: None, int, or string
            The column to be checked.
            See self.index() for more information on how to specify a column.

        Returns
        -------
        contains: bool
            True if `column` specifies an existing column key.
        &#34;&#34;&#34;
        return self.index(column) is not None

    def keys(self):
        &#34;&#34;&#34;List of unique column keys for all available columns.

        Returns
        -------
        keys: list of strings
            List of unique column specifications.
        &#34;&#34;&#34;
        return [self.column_spec(c) for c in range(self.columns())]

    def values(self):
        &#34;&#34;&#34;List of column data corresponding to keys().

        Returns
        -------
        data: list of list of values
            The data of the table. First index is columns!
        &#34;&#34;&#34;
        return self.data

    def items(self):
        &#34;&#34;&#34;Column names and corresponding data.

        Returns
        -------
        items: list of tuples
            Unique column specifications and the corresponding data.
        &#34;&#34;&#34;
        return [(self.column_spec(c), self.data[c]) for c in range(self.columns())]
        
    def __len__(self):
        &#34;&#34;&#34;The number of columns.
        
        Returns
        -------
        columns: int
            The number of columns contained in the table.
        &#34;&#34;&#34;
        return self.columns()

    def __iter__(self):
        &#34;&#34;&#34;Initialize iteration over data columns.
        &#34;&#34;&#34;
        self.iter_counter = -1
        return self

    def __next__(self):
        &#34;&#34;&#34;Next column of data.

        Returns
        -------
        data: list of values
            Table data of next column.
        &#34;&#34;&#34;
        self.iter_counter += 1
        if self.iter_counter &gt;= self.columns():
            raise StopIteration
        else:
            return self.data[self.iter_counter]

    def next(self):
        &#34;&#34;&#34;Return next data columns.  (python2 syntax)

        See also:
        ---------
        `__next__()`
        &#34;&#34;&#34;
        return self.__next__()

    def rows(self):
        &#34;&#34;&#34;The number of rows.
        
        Returns
        -------
        rows: int
            The number of rows contained in the table.
        &#34;&#34;&#34;
        return max(map(len, self.data)) if self.data else 0
    
    def columns(self):
        &#34;&#34;&#34;The number of columns.
        
        Returns
        -------
        columns: int
            The number of columns contained in the table.
        &#34;&#34;&#34;
        return len(self.header)

    def row(self, index):
        &#34;&#34;&#34;A single row of the table.

        Parameters
        ----------
        index: int
            The index of the row to be returned.

        Returns
        -------
        data: TableData
            A TableData object with a single row.
        &#34;&#34;&#34;
        data = TableData()
        sec_indices = [-1] * self.nsecs
        for c in range(self.columns()):
            data.append(*self.column_head(c))
            for l in range(self.nsecs):
                s, i = self.section(c, l+1)
                if i != sec_indices[l]:
                    data.header[-1].append(s)
                    sec_indices[l] = i
            data.data[-1] = [self.data[c][index]]
        data.nsecs = self.nsecs
        return data

    def row_dict(self, index):
        &#34;&#34;&#34;A single row of the table.

        Parameters
        ----------
        index: int
            The index of the row to be returned.

        Returns
        -------
        data: dict
            A dictionary with column header as key and corresponding data value of row `index`
            as value.
        &#34;&#34;&#34;
        data = {}
        for c in range(self.columns()):
            data[self.label(c)] = self.data[c][index]
        return data

    def col(self, column):
        &#34;&#34;&#34;A single column of the table.

        Parameters
        ----------
        column: None, int, or string
            The column to be returned.
            See self.index() for more information on how to specify a column.

        Returns
        -------
        table: TableData
            A TableData object with a single column.
        &#34;&#34;&#34;
        data = TableData()
        c = self.index(column)
        data.append(*self.column_head(c))
        data.data = [self.data[c]]
        data.nsecs = 0
        return data

    def __call__(self, column):
        &#34;&#34;&#34;A single column of the table as a numpy array.

        Parameters
        ----------
        column: None, int, or string
            The column to be returned.
            See self.index() for more information on how to specify a column.

        Returns
        -------
        data: 1-D array
            Content of the specified column as a numpy array.
        &#34;&#34;&#34;
        c = self.index(column)
        return np.asarray(self.data[c])

    def __setupkey(self, key):
        &#34;&#34;&#34;Helper function that turns a key into row and column indices.

        Returns
        -------
        rows: list of int, slice, None
            Indices of selected rows.
        cols: list of int
            Indices of selected columns.

        Raises
        ------
        IndexError:
            If an invalid column was specified.
        &#34;&#34;&#34;
        if type(key) is not tuple:
            rows = key
            cols = range(self.columns())
        else:
            rows = key[0]
            cols = key[1]
        if isinstance(cols, slice):
            start = cols.start
            if start is not None:
                start = self.index(start)
                if start is None:
                    raise IndexError(&#39;&#34;%s&#34; is not a valid column index&#39; % cols.start)
            stop = cols.stop
            if stop is not None:
                stop = self.index(stop)
                if stop is None:
                    raise IndexError(&#39;&#34;%s&#34; is not a valid column index&#39; % cols.stop)
            cols = slice(start, stop, cols.step)
            cols = range(self.columns())[cols]
        else:
            if not isinstance(cols, (list, tuple, np.ndarray)):
                cols = [cols]
            c = [self.index(inx) for inx in cols]
            if None in c:
                raise IndexError(&#39;&#34;%s&#34; is not a valid column index&#39; % cols[c.index(None)])
            cols = c
        if isinstance(rows, np.ndarray) and rows.dtype == np.dtype(bool):
            rows = np.where(rows)[0]
            if len(rows) == 0:
                rows = None
        return rows, cols

    def __getitem__(self, key):
        &#34;&#34;&#34;Data elements specified by slice.

        Parameters
        -----------
        key:
            First key specifies row, (optional) second one the column.
            Columns can be specified by index or name,
            see `index()` for details.

        Returns
        -------
        data:
            - A single data value if a single row and a single column is specified.
            - An array of data elements if a single single column is specified.
            - A TableData object for multiple columns.
            - None if no row is selected (e.g. by a logical index that nowhere is True)

        Raises
        ------
        IndexError:
            If an invalid column was specified.
        &#34;&#34;&#34;
        rows, cols = self.__setupkey(key)
        if len(cols) == 1:
            if rows is None:
                return None
            elif isinstance(rows, slice):
                return np.asarray(self.data[cols[0]][rows])
            elif isinstance(rows, (list, tuple, np.ndarray)):
                return np.asarray([self.data[cols[0]][r] for r in rows])
            else:
                return self.data[cols[0]][rows]
        else:
            data = TableData()
            sec_indices = [-1] * self.nsecs
            for c in cols:
                data.append(*self.column_head(c))
                for l in range(self.nsecs):
                    s, i = self.section(c, l+1)
                    if i != sec_indices[l]:
                        data.header[-1].append(s)
                        sec_indices[l] = i
                if rows is None:
                    continue
                if isinstance(rows, (list, tuple, np.ndarray)):
                    for r in rows:
                        data.data[-1].append(self.data[c][r])
                else:
                    if isinstance(self.data[c][rows], (list, tuple, np.ndarray)):
                        data.data[-1].extend(self.data[c][rows])
                    else:
                        data.data[-1].append(self.data[c][rows])
            data.nsecs = self.nsecs
            return data

    def __setitem__(self, key, value):
        &#34;&#34;&#34;Assign values to data elements specified by slice.

        Parameters
        -----------
        key:
            First key specifies row, (optional) second one the column.
            Columns can be specified by index or name,
            see `index()` for details.
        value: TableData, list, ndarray, float, ...
            Value(s) used to assing to the table elements as specified by `key`.

        Raises
        ------
        IndexError:
            If an invalid column was specified.
        &#34;&#34;&#34;
        rows, cols = self.__setupkey(key)
        if rows is None:
            return
        if isinstance(value, TableData):
            if isinstance(self.data[cols[0]][rows], (list, tuple, np.ndarray)):
                for k, c in enumerate(cols):
                    self.data[c][rows] = value.data[k]
            else:
                for k, c in enumerate(cols):
                    self.data[c][rows] = value.data[k][0]
        else:
            if len(cols) == 1:
                if isinstance(rows, (list, tuple, np.ndarray)):
                    if len(rows) == 1:
                        self.data[cols[0]][rows[0]] = value
                    elif isinstance(value, (list, tuple, np.ndarray)):
                        for k, r in enumerate(rows):
                            self.data[cols[0]][r] = value[k]
                    else:
                        for r in rows:
                            self.data[cols[0]][r] = value
                elif isinstance(value, (list, tuple, np.ndarray)):
                    self.data[cols[0]][rows] = value
                elif isinstance(rows, (int, np.integer)):
                    self.data[cols[0]][rows] = value
                else:
                    n = len(self.data[cols[0]][rows])
                    if n &gt; 1:
                        self.data[cols[0]][rows] = [value]*n
                    else:
                        self.data[cols[0]][rows] = value
            else:
                if isinstance(self.data[0][rows], (list, tuple, np.ndarray)):
                    for k, c in enumerate(cols):
                        self.data[c][rows] = value[:,k]
                elif isinstance(value, (list, tuple, np.ndarray)):
                    for k, c in enumerate(cols):
                        self.data[c][rows] = value[k]
                else:
                    for k, c in enumerate(cols):
                        self.data[c][rows] = value

    def __delitem__(self, key):
        &#34;&#34;&#34;Delete data elements or whole columns or rows.

        Parameters
        -----------
        key:
            First key specifies row, (optional) second one the column.
            Columns can be specified by index or name,
            see `index()` for details.
            If all rows are selected, then the specified columns are removed from the table.
            Otherwise only data values are removed.
            If all columns are selected than entire rows of data values are removed.
            Otherwise only data values in the specified rows are removed.

        Raises
        ------
        IndexError:
            If an invalid column was specified.
        &#34;&#34;&#34;
        rows, cols = self.__setupkey(key)
        if rows is None:
            return
        row_indices = np.arange(self.rows(), dtype=np.int)[rows]
        if isinstance(row_indices, np.ndarray):
            if len(row_indices) == self.rows():
                # delete whole columns:
                self.remove(cols)
            elif len(row_indices) &gt; 0:
                for r in reversed(sorted(row_indices)):
                    for c in cols:
                        del self.data[c][r]
                self.shape = (self.rows(), self.columns())
        else:
            for c in cols:
                del self.data[c][row_indices]
            self.shape = (self.rows(), self.columns())

    def array(self, row=None):
        &#34;&#34;&#34;The table data as a numpy array.

        Parameters
        ----------
        row: int or None
            If specified, a 1D array of that row will be returned.

        Returns
        -------
        data: 2D or 1D ndarray
            If no row is specified, the data content of the entire table
            as a 2D numpy array (rows first).
            If a row is specified, a 1D array of that row.
        &#34;&#34;&#34;
        if row is None:
            return np.array(self.data).T
        else:
            return np.array([d[row] for d in self.data])

    def data_frame(self):
        &#34;&#34;&#34;The table data as a pandas DataFrame.

        Returns
        -------
        data: pandas.DataFrame
            A pandas DataFrame of the whole table.
        &#34;&#34;&#34;
        return pd.DataFrame(self.dict())

    def dicts(self, raw_values=True, missing=&#39;-&#39;):
        &#34;&#34;&#34;The table as a list of dictionaries.

        Parameters
        ----------
        raw_values: bool
            If True, use raw table values as values,
            else format the values and add unit string.
        missing: string
            String indicating non-existing data elements.

        Returns
        -------
        table: list of dict
            For each row of the table a dictionary with header as key.
        &#34;&#34;&#34;
        table = []
        for row in range(self.rows()):
            data = {}
            for col in range(len(self.header)):
                if raw_values:
                    v = self.data[col][row];
                else:
                    if isinstance(self.data[col][row], float) and m.isnan(self.data[col][row]):
                        v = missing
                    else:
                        u = &#39;&#39;
                        if not self.units[col] in &#39;1-&#39; and self.units[col] != &#39;a.u.&#39;:
                            u = self.units[col]
                        v = (self.formats[col] % self.data[col][row]) + u
                data[self.header[col][0]] = v
            table.append(data)
        return table

    def dict(self):
        &#34;&#34;&#34;The table as a dictionary.

        Returns
        -------
        table: dict
            A dictionary with keys being the column headers and
            values the list of data elements of the corresponding column.
        &#34;&#34;&#34;
        table = {k: v for k, v in self.items()}
        return table

    def append_data(self, data, column=None):
        &#34;&#34;&#34;Append data elements to successive columns.

        The current column is set behid the added columns.

        Parameters
        ----------
        data: float, int, string, etc. or list thereof or list of list thereof
            Data values to be appended to successive column.
            - A single value is simply appened to the specified column of the table.
            - A 1D-list of values is appended to successive columns of the table
              starting with the specified column.
            - The columns of a 2D-list of values (second index) are appended
              to successive columns of the table starting with the specified column.
        column: None, int, or string
            The first column to which the data should be appended.
            If None, append to the current column.
            See self.index() for more information on how to specify a column.
        &#34;&#34;&#34;
        column = self.index(column)
        if column is None:
            column = self.setcol
        if isinstance(data, (list, tuple, np.ndarray)):
            if isinstance(data[0], (list, tuple, np.ndarray)):
                # 2D list, rows first:
                for row in data:
                    for i, val in enumerate(row):
                        self.data[column+i].append(val)
                self.setcol = column + len(data[0])
            else:
                # 1D list:
                for val in data:
                    self.data[column].append(val)
                    column += 1
                self.setcol = column
        else:
            # single value:
            self.data[column].append(data)
            self.setcol = column+1
        self.shape = (self.rows(), self.columns())

    def append_data_column(self, data, column=None):
        &#34;&#34;&#34;Append data elements to a column.

        The current column is incremented by one.

        Parameters
        ----------
        data: float, int, string, etc. or list thereof
            Data values to be appended to a column.
        column: None, int, or string
            The column to which the data should be appended.
            If None, append to the current column.
            See self.index() for more information on how to specify a column.
        &#34;&#34;&#34;
        column = self.index(column)
        if column is None:
            column = self.setcol
        if isinstance(data, (list, tuple, np.ndarray)):
            self.data[column].extend(data)
            column += 1
            self.setcol = column
        else:
            self.data[column].append(data)
            self.setcol = column+1
        self.shape = (self.rows(), self.columns())

    def set_column(self, column):
        &#34;&#34;&#34;Set the column where to add data.

        Parameters
        ----------
        column: int or string
            The column to which data elements should be appended.
            See self.index() for more information on how to specify a column.

        Raises
        ------
        IndexError:
            If an invalid column was specified.
        &#34;&#34;&#34;
        col = self.index(column)
        if col is None:
            if isinstance(column, (int, np.integer)):
                column = &#39;%d&#39; % column
            raise IndexError(&#39;column &#39; + column + &#39; not found or invalid&#39;)
        self.setcol = col
        return col

    def fill_data(self):
        &#34;&#34;&#34;Fill up all columns with missing data to have the same number of
        data elements.
        &#34;&#34;&#34;
        # maximum rows:
        maxr = self.rows()
        # fill up:
        for c in range(len(self.data)):
            while len(self.data[c]) &lt; maxr:
                self.data[c].append(np.nan)
        self.setcol = 0
        self.shape = (self.rows(), self.columns())

    def clear_data(self):
        &#34;&#34;&#34;Clear content of the table but keep header.
        &#34;&#34;&#34;
        for c in range(len(self.data)):
            self.data[c] = []
        self.setcol = 0
        self.shape = (self.rows(), self.columns())
                
    def sort(self, columns, reverse=False):
        &#34;&#34;&#34;Sort the table rows in place.

        Parameters
        ----------
        columns: int or string or list of int or string
            A column specifier or a list of column specifiers of the columns
            to be sorted.
        reverse: boolean
            If `True` sort in descending order.

        Raises
        ------
        IndexError:
            If an invalid column was specified.
        &#34;&#34;&#34;
        # fix columns:
        if not isinstance(columns, (list, tuple, np.ndarray)):
            columns = [ columns ]
        if not columns:
            return
        cols = []
        for col in columns:
            c = self.index(col)
            if c is None:
                if isinstance(col, (int, np.integer)):
                    col = &#39;%d&#39; % col
                raise IndexError(&#39;sort column &#39; + col + &#39; not found&#39;)
                continue
            cols.append(c)
        # get sorted row indices:
        row_inx = range(self.rows())
        row_inx = sorted(row_inx, key=lambda x : [float(&#39;-inf&#39;) if self.data[c][x] is np.nan \
                         or self.data[c][x] != self.data[c][x] \
                         else self.data[c][x] for c in cols], reverse=reverse)
        # sort table according to indices:
        for c in range(self.columns()):
            self.data[c] = [self.data[c][r] for r in row_inx]

    def statistics(self):
        &#34;&#34;&#34;Descriptive statistics of each column.
        &#34;&#34;&#34;
        ds = TableData()
        if self.nsecs &gt; 0:
            ds.append_section(&#39;statistics&#39;)
            for l in range(1,self.nsecs):
                ds.append_section(&#39;-&#39;)
            ds.append(&#39;-&#39;, &#39;-&#39;, &#39;%-10s&#39;)
        else:
            ds.append(&#39;statistics&#39;, &#39;-&#39;, &#39;%-10s&#39;)
        ds.append_data(&#39;mean&#39;, 0)
        ds.append_data(&#39;std&#39;, 0)
        ds.append_data(&#39;min&#39;, 0)
        ds.append_data(&#39;quartile1&#39;, 0)
        ds.append_data(&#39;median&#39;, 0)
        ds.append_data(&#39;quartile3&#39;, 0)
        ds.append_data(&#39;max&#39;, 0)
        ds.append_data(&#39;count&#39;, 0)
        dc = 1
        for c in range(self.columns()):
            if len(self.data[c]) &gt; 0 and isinstance(self.data[c][0], (float, int)):
                ds.hidden.append(False)
                ds.header.append(self.header[c])
                ds.units.append(self.units[c])
                # integer data still make floating point statistics:
                if isinstance(self.data[c][0], float):
                    f = self.formats[c]
                    i0 = f.find(&#39;.&#39;)
                    if i0 &gt; 0:
                        p = int(f[i0+1:-1])
                        if p &lt;= 0:
                            f = &#39;%.1f&#39;
                    ds.formats.append(f)
                else:
                    ds.formats.append(&#39;%.1f&#39;)
                # remove nans:
                data = np.asarray(self.data[c], np.float)
                data = data[np.isfinite(data)]
                # compute statistics:
                ds.data.append([])
                ds.append_data(np.mean(data), dc)
                ds.append_data(np.std(data), dc)
                ds.append_data(np.min(data), dc)
                q1, m, q3 = np.percentile(data, [25., 50., 75.])
                ds.append_data(q1, dc)
                ds.append_data(m, dc)
                ds.append_data(q3, dc)
                ds.append_data(np.max(data), dc)
                ds.append_data(len(data), dc)
                dc += 1
        ds.nsecs = self.nsecs
        ds.shape = (ds.rows(), ds.columns())
        return ds

    def key_value(self, row, col, missing=&#39;-&#39;):
        &#34;&#34;&#34;A data element returned as a key-value pair.

        Parameters
        ----------
        row: int
            Specifies the row from which the data element should be retrieved.
        col: None, int, or string
            A specification of a column.
            See self.index() for more information on how to specify a column.
        missing: string
            String indicating non-existing data elements.

        Returns
        -------
        key: string
            Header label of the column
        value: string
            A textual representation of the data element according to the format
            of the column, followed by the unit of the column.
        &#34;&#34;&#34;
        col = self.index(col)
        if col is None:
            return &#39;&#39;
        if isinstance(self.data[col][row], float) and m.isnan(self.data[col][row]):
            v = missing
        else:
            u = &#39;&#39;
            if not self.units[col] in &#39;1-&#39; and self.units[col] != &#39;a.u.&#39;:
                u = self.units[col]
            v = (self.formats[col] % self.data[col][row]) + u
        return self.header[col][0], v

    def hide(self, column):
        &#34;&#34;&#34;Hide a column or a range of columns.

        Hidden columns will not be printed out by the write() function.

        Parameters
        ----------
        column: int or string
            The column to be hidden.
            See self.index() for more information on how to specify a column.
        &#34;&#34;&#34;
        c0, c1 = self.find_col(column)
        if c0 is not None:
            for c in range(c0, c1):
                self.hidden[c] = True

    def hide_all(self):
        &#34;&#34;&#34;Hide all columns.

        Hidden columns will not be printed out by the write() function.
        &#34;&#34;&#34;
        for c in range(len(self.hidden)):
            self.hidden[c] = True

    def hide_empty_columns(self, missing=&#39;-&#39;):
        &#34;&#34;&#34;Hide all columns that do not contain data.

        Hidden columns will not be printed out by the write() function.

        Parameters
        ----------
        missing: string
            String indicating missing data.
        &#34;&#34;&#34;
        for c in range(len(self.data)):
            # check for empty column:
            isempty = True
            for v in self.data[c]:
                if isinstance(v, float):
                    if not m.isnan(v):
                        isempty = False
                        break
                else:
                    if v != missing:
                        isempty = False
                        break
            if isempty:
                self.hidden[c] = True

    def show(self, column):
        &#34;&#34;&#34;Show a column or a range of columns.

        Undoes hiding of a column.

        Parameters
        ----------
        column: int or string
            The column to be shown.
            See self.index() for more information on how to specify a column.
        &#34;&#34;&#34;
        c0, c1 = self.find_col(column)
        if c0 is not None:
            for c in range(c0, c1):
                self.hidden[c] = False

    def write(self, fh=sys.stdout, table_format=None, delimiter=None,
              unit_style=None, column_numbers=None, sections=None,
              align_columns=None, shrink_width=True, missing=&#39;-&#39;,
              center_columns=False, latex_label_command=&#39;&#39;, latex_merge_std=False):
        &#34;&#34;&#34;Write the table to a file or stream.

        Parameters
        ----------
        fh: filename or stream
            If not a stream, the file with name `fh` is opened.
            If `fh` does not have an extension,
            the `table_format` is appended as an extension.
            Otherwise `fh` is used as a stream for writing.
        table_format: None or string
            The format to be used for output.
            One of &#39;out&#39;, &#39;dat&#39;, &#39;ascii&#39;, &#39;csv&#39;, &#39;rtai&#39;, &#39;md&#39;, &#39;tex&#39;, &#39;html&#39;.
            If None or &#39;auto&#39; then the format is set to the extension of the filename given by `fh`.
            If `fh` is a stream the format is set to &#39;dat&#39;.
        delimiter: string
            String or character separating columns, if supported by the `table_format`.
            If None or &#39;auto&#39; use the default for the specified `table_format`.
        unit_style: None or string
            - None or &#39;auto&#39;: use default of the specified `table_format`.
            - &#39;row&#39;: write an extra row to the table header specifying the units of the columns.
            - &#39;header&#39;: add the units to the column headers.
            - &#39;none&#39;: do not specify the units.
        column_numbers: string or None
            Add a row specifying the column index:
            - &#39;index&#39;: indices are integers, first column is 0.
            - &#39;num&#39;: indices are integers, first column is 1.
            - &#39;aa&#39;: use &#39;a&#39;, &#39;b&#39;, &#39;c&#39;, ..., &#39;z&#39;, &#39;aa&#39;, &#39;ab&#39;, ... for indexing
            - &#39;aa&#39;: use &#39;A&#39;, &#39;B&#39;, &#39;C&#39;, ..., &#39;Z&#39;, &#39;AA&#39;, &#39;AB&#39;, ... for indexing
            - None or &#39;none&#39;: do not add a row with column indices
            TableData.column_numbering is a list with the supported styles.
        sections: None or int
            Number of section levels to be printed.
            If `None` or &#39;auto&#39; use default of selected `table_format`.
        align_columns: boolean
            - `True`: set width of column formats to make them align.
            - `False`: set width of column formats to 0 - no unnecessary spaces.
            - None or &#39;auto&#39;: Use default of the selected `table_format`.
        shrink_width: boolean
            If `True` disregard width specified by the format strings,
            such that columns can become narrower.
        missing: string
            Indicate missing data by this string.
        center_columns: boolean
            If True center all columns (markdown, html, and latex).
        latex_label_command: string
            LaTeX command for formatting header labels.
            E.g. &#39;textbf&#39; for making the header labels bold.
        latex_merge_std: string
            Merge header of columns with standard deviations with previous column
            (LaTeX tables only).

        Returns
        -------
        file_name: string or None
            The full name of the file into which the data were written.

        Supported file formats
        ----------------------
        
        ## `dat`: data text file
        ``` plain
        # info           reaction     
        # size   weight  delay  jitter
        # m      kg      ms     mm    
           2.34     123   98.7      23
          56.70    3457   54.3      45
           8.90      43   67.9     345
        ```

        ## `ascii`: ascii-art table
        ``` plain
        |---------------------------------|
        | info           | reaction       |
        | size  | weight | delay | jitter |
        | m     | kg     | ms    | mm     |
        |-------|--------|-------|--------|
        |  2.34 |    123 |  98.7 |     23 |
        | 56.70 |   3457 |  54.3 |     45 |
        |  8.90 |     43 |  67.9 |    345 |
        |---------------------------------|
        ```

        ## `csv`: comma separated values
        ``` plain
        size/m,weight/kg,delay/ms,jitter/mm
        2.34,123,98.7,23
        56.70,3457,54.3,45
        8.90,43,67.9,345
        ```

        ## `rtai`: rtai-style table
        ``` plain
        RTH| info         | reaction     
        RTH| size | weight| delay| jitter
        RTH| m    | kg    | ms   | mm    
        RTD|  2.34|    123|  98.7|     23
        RTD| 56.70|   3457|  54.3|     45
        RTD|  8.90|     43|  67.9|    345
        ```

        ## `md`: markdown
        ``` plain
        | size/m | weight/kg | delay/ms | jitter/mm |
        |------:|-------:|------:|-------:|
        |  2.34 |    123 |  98.7 |     23 |
        | 56.70 |   3457 |  54.3 |     45 |
        |  8.90 |     43 |  67.9 |    345 |
        ```

        ## `tex`: latex tabular
        ``` tex
        \\begin{tabular}{rrrr}
          \\hline
          \\multicolumn{2}{l}{info} &amp; \\multicolumn{2}{l}{reaction} \\
          \\multicolumn{1}{l}{size} &amp; \\multicolumn{1}{l}{weight} &amp; \\multicolumn{1}{l}{delay} &amp; \\multicolumn{1}{l}{jitter} \\
          \\multicolumn{1}{l}{m} &amp; \\multicolumn{1}{l}{kg} &amp; \\multicolumn{1}{l}{ms} &amp; \\multicolumn{1}{l}{mm} \\
          \\hline
          2.34 &amp; 123 &amp; 98.7 &amp; 23 \\
          56.70 &amp; 3457 &amp; 54.3 &amp; 45 \\
          8.90 &amp; 43 &amp; 67.9 &amp; 345 \\
          \\hline
        \\end{tabular}
        ```

        ## `html`: html
        ``` html
        &lt;table&gt;
        &lt;thead&gt;
          &lt;tr class=&#34;header&#34;&gt;
            &lt;th align=&#34;left&#34; colspan=&#34;2&#34;&gt;info&lt;/th&gt;
            &lt;th align=&#34;left&#34; colspan=&#34;2&#34;&gt;reaction&lt;/th&gt;
          &lt;/tr&gt;
          &lt;tr class=&#34;header&#34;&gt;
            &lt;th align=&#34;left&#34;&gt;size&lt;/th&gt;
            &lt;th align=&#34;left&#34;&gt;weight&lt;/th&gt;
            &lt;th align=&#34;left&#34;&gt;delay&lt;/th&gt;
            &lt;th align=&#34;left&#34;&gt;jitter&lt;/th&gt;
          &lt;/tr&gt;
          &lt;tr class=&#34;header&#34;&gt;
            &lt;th align=&#34;left&#34;&gt;m&lt;/th&gt;
            &lt;th align=&#34;left&#34;&gt;kg&lt;/th&gt;
            &lt;th align=&#34;left&#34;&gt;ms&lt;/th&gt;
            &lt;th align=&#34;left&#34;&gt;mm&lt;/th&gt;
          &lt;/tr&gt;
        &lt;/thead&gt;
        &lt;tbody&gt;
          &lt;tr class&#34;odd&#34;&gt;
            &lt;td align=&#34;right&#34;&gt;2.34&lt;/td&gt;
            &lt;td align=&#34;right&#34;&gt;123&lt;/td&gt;
            &lt;td align=&#34;right&#34;&gt;98.7&lt;/td&gt;
            &lt;td align=&#34;right&#34;&gt;23&lt;/td&gt;
          &lt;/tr&gt;
          &lt;tr class&#34;even&#34;&gt;
            &lt;td align=&#34;right&#34;&gt;56.70&lt;/td&gt;
            &lt;td align=&#34;right&#34;&gt;3457&lt;/td&gt;
            &lt;td align=&#34;right&#34;&gt;54.3&lt;/td&gt;
            &lt;td align=&#34;right&#34;&gt;45&lt;/td&gt;
          &lt;/tr&gt;
          &lt;tr class&#34;odd&#34;&gt;
            &lt;td align=&#34;right&#34;&gt;8.90&lt;/td&gt;
            &lt;td align=&#34;right&#34;&gt;43&lt;/td&gt;
            &lt;td align=&#34;right&#34;&gt;67.9&lt;/td&gt;
            &lt;td align=&#34;right&#34;&gt;345&lt;/td&gt;
          &lt;/tr&gt;
        &lt;/tbody&gt;
        &lt;/table&gt;
        ```
        &#34;&#34;&#34;
        # fix parameter:
        if table_format == &#39;auto&#39;:
            table_format = None
        if delimiter == &#39;auto&#39;:
            delimiter = None
        if unit_style == &#39;auto&#39;:
            unit_style = None
        if column_numbers == &#39;none&#39;:
            column_numbers = None
        if sections == &#39;auto&#39;:
            sections = None
        if align_columns == &#39;auto&#39;:
            align_columns = None
        # open file:
        own_file = False
        file_name = None
        if not hasattr(fh, &#39;write&#39;):
            _, ext = os.path.splitext(fh)
            if table_format is None:
                if len(ext) &gt; 1 and ext[1:] in self.ext_formats:
                    table_format = self.ext_formats[ext[1:]]
            elif not ext or not ext[1:].lower() in self.ext_formats:
                fh += &#39;.&#39; + self.extensions[table_format]
            file_name = fh
            fh = open(fh, &#39;w&#39;)
            own_file = True
        if table_format is None:
            table_format = &#39;dat&#39;
        # set style:        
        if table_format[0] == &#39;d&#39;:
            align_columns = True
            begin_str = &#39;&#39;
            end_str = &#39;&#39;
            header_start = &#39;# &#39;
            header_sep = &#39;  &#39;
            header_close = &#39;&#39;
            header_end = &#39;\n&#39;
            data_start = &#39;  &#39;
            data_sep = &#39;  &#39;
            data_close = &#39;&#39;
            data_end = &#39;\n&#39;
            top_line = False
            header_line = False
            bottom_line = False
            if delimiter is not None:
                header_sep = delimiter
                data_sep = delimiter
            if sections is None:
                sections = 1000
        elif table_format[0] == &#39;a&#39;:
            align_columns = True
            begin_str = &#39;&#39;
            end_str = &#39;&#39;
            header_start = &#39;| &#39;
            header_sep = &#39; | &#39;
            header_close = &#39;&#39;
            header_end = &#39; |\n&#39;
            data_start = &#39;| &#39;
            data_sep = &#39; | &#39;
            data_close = &#39;&#39;
            data_end = &#39; |\n&#39;
            top_line = True
            header_line = True
            bottom_line = True
            if delimiter is not None:
                header_sep = delimiter
                data_sep = delimiter
            if sections is None:
                sections = 1000
        elif table_format[0] == &#39;c&#39;:
            # csv according to http://www.ietf.org/rfc/rfc4180.txt :
            column_numbers=None
            if unit_style is None:
                unit_style = &#39;header&#39;
            if align_columns is None:
                align_columns = False
            begin_str = &#39;&#39;
            end_str = &#39;&#39;
            header_start=&#39;&#39;
            header_sep = &#39;,&#39;
            header_close = &#39;&#39;
            header_end=&#39;\n&#39;
            data_start=&#39;&#39;
            data_sep = &#39;,&#39;
            data_close = &#39;&#39;
            data_end=&#39;\n&#39;
            top_line = False
            header_line = False
            bottom_line = False
            if delimiter is not None:
                header_sep = delimiter
                data_sep = delimiter
            if sections is None:
                sections = 0
        elif table_format[0] == &#39;r&#39;:
            align_columns = True
            begin_str = &#39;&#39;
            end_str = &#39;&#39;
            header_start = &#39;RTH| &#39;
            header_sep = &#39;| &#39;
            header_close = &#39;&#39;
            header_end = &#39;\n&#39;
            data_start = &#39;RTD| &#39;
            data_sep = &#39;| &#39;
            data_close = &#39;&#39;
            data_end = &#39;\n&#39;
            top_line = False
            header_line = False
            bottom_line = False
            if sections is None:
                sections = 1000
        elif table_format[0] == &#39;m&#39;:
            if unit_style is None or unit_style == &#39;row&#39;:
                unit_style = &#39;header&#39;
            align_columns = True
            begin_str = &#39;&#39;
            end_str = &#39;&#39;
            header_start=&#39;| &#39;
            header_sep = &#39; | &#39;
            header_close = &#39;&#39;
            header_end=&#39; |\n&#39;
            data_start=&#39;| &#39;
            data_sep = &#39; | &#39;
            data_close = &#39;&#39;
            data_end=&#39; |\n&#39;
            top_line = False
            header_line = True
            bottom_line = False
            if sections is None:
                sections = 0
        elif table_format[0] == &#39;h&#39;:
            align_columns = False
            begin_str = &#39;&lt;table&gt;\n&lt;thead&gt;\n&#39;
            end_str = &#39;&lt;/tbody&gt;\n&lt;/table&gt;\n&#39;
            if center_columns:
                header_start=&#39;  &lt;tr&gt;\n    &lt;th align=&#34;center&#34;&#39;
                header_sep = &#39;&lt;/th&gt;\n    &lt;th align=&#34;center&#34;&#39;
            else:
                header_start=&#39;  &lt;tr&gt;\n    &lt;th align=&#34;left&#34;&#39;
                header_sep = &#39;&lt;/th&gt;\n    &lt;th align=&#34;left&#34;&#39;
            header_close = &#39;&gt;&#39;
            header_end=&#39;&lt;/th&gt;\n  &lt;/tr&gt;\n&#39;
            data_start=&#39;  &lt;tr&gt;\n    &lt;td&#39;
            data_sep = &#39;&lt;/td&gt;\n    &lt;td&#39;
            data_close = &#39;&gt;&#39;
            data_end=&#39;&lt;/td&gt;\n  &lt;/tr&gt;\n&#39;
            top_line = False
            header_line = False
            bottom_line = False
            if sections is None:
                sections = 1000
        elif table_format[0] == &#39;t&#39;:
            if align_columns is None:
                align_columns = False
            begin_str = &#39;\\begin{tabular}&#39;
            end_str = &#39;\\end{tabular}\n&#39;
            header_start=&#39;  &#39;
            header_sep = &#39; &amp; &#39;
            header_close = &#39;&#39;
            header_end=&#39; \\\\\n&#39;
            data_start=&#39;  &#39;
            data_sep = &#39; &amp; &#39;
            data_close = &#39;&#39;
            data_end=&#39; \\\\\n&#39;
            top_line = True
            header_line = True
            bottom_line = True
            if sections is None:
                sections = 1000
        else:
            if align_columns is None:
                align_columns = True
            begin_str = &#39;&#39;
            end_str = &#39;&#39;
            header_start = &#39;&#39;
            header_sep = &#39;  &#39;
            header_close = &#39;&#39;
            header_end = &#39;\n&#39;
            data_start = &#39;&#39;
            data_sep = &#39;  &#39;
            data_close = &#39;&#39;
            data_end = &#39;\n&#39;
            top_line = False
            header_line = False
            bottom_line = False
            if sections is None:
                sections = 1000
        # check units:
        if unit_style is None:
            unit_style = &#39;row&#39;
        have_units = False
        for u in self.units:
            if u and u != &#39;1&#39; and u != &#39;-&#39;:
                have_units = True
                break
        if not have_units:
            unit_style = &#39;none&#39;
        # find std columns:
        stdev_col = np.zeros(len(self.header), dtype=np.bool)
        for c in range(len(self.header)-1):
            if self.header[c+1][0].lower() in [&#39;sd&#39;, &#39;std&#39;, &#39;s.d.&#39;, &#39;stdev&#39;] and \
               not self.hidden[c+1]:
                stdev_col[c] = True
        # begin table:
        fh.write(begin_str)
        if table_format[0] == &#39;t&#39;:
            fh.write(&#39;{&#39;)
            merged = False
            for h, f, s in zip(self.hidden, self.formats, stdev_col):
                if merged:
                    fh.write(&#39;l&#39;)
                    merged = False
                    continue
                if h:
                    continue
                if latex_merge_std and s:
                    fh.write(&#39;r@{$\\,\\pm\\,$}&#39;)
                    merged = True
                elif center_columns:
                    fh.write(&#39;c&#39;)
                elif f[1] == &#39;-&#39;:
                    fh.write(&#39;l&#39;)
                else:
                    fh.write(&#39;r&#39;)
            fh.write(&#39;}\n&#39;)
        # retrieve column formats and widths:
        widths = []
        widths_pos = []
        for c, f in enumerate(self.formats):
            w = 0
            # position of width specification:
            i0 = 1
            if f[1] == &#39;-&#39; :
                i0 = 2
            i1 = f.find(&#39;.&#39;)
            if not shrink_width:
                if f[i0:i1]:
                    w = int(f[i0:i1])
            widths_pos.append((i0, i1))
            # adapt width to header label:
            hw = len(self.header[c][0])
            if unit_style == &#39;header&#39; and self.units[c] and\
               self.units[c] != &#39;1&#39; and self.units[c] != &#39;-&#39;:
                hw += 1 + len(self.units[c])
            if w &lt; hw:
                w = hw
            # adapt width to data:
            if f[-1] == &#39;s&#39;:
                for v in self.data[c]:
                    if not isinstance(v, float) and w &lt; len(v):
                        w = len(v)
            else:
                fs = f[:i0] + str(0) + f[i1:]
                for v in self.data[c]:
                    if isinstance(v, float) and m.isnan(v):
                        s = missing
                    else:
                        s = fs % v
                    if w &lt; len(s):
                        w = len(s)
            widths.append(w)
        # adapt width to sections:
        sec_indices = [0] * self.nsecs
        sec_widths = [0] * self.nsecs
        sec_columns = [0] * self.nsecs
        for c in range(len(self.header)):
            w = widths[c]
            for l in range(min(self.nsecs, sections)):
                if 1+l &lt; len(self.header[c]):
                    if c &gt; 0 and sec_columns[l] &gt; 0 and \
                       1+l &lt; len(self.header[sec_indices[l]]) and \
                       len(self.header[sec_indices[l]][1+l]) &gt; sec_widths[l]:
                        dw = len(self.header[sec_indices[l]][1+l]) - sec_widths[l]
                        nc = sec_columns[l]
                        ddw = np.zeros(nc, dtype=int) + dw // nc
                        ddw[:dw % nc] += 1
                        wk = 0
                        for ck in range(sec_indices[l], c):
                            if not self.hidden[ck]:
                                widths[ck] += ddw[wk]
                                wk += 1
                    sec_widths[l] = 0
                    sec_indices[l] = c
                if not self.hidden[c]:
                    if sec_widths[l] &gt; 0:
                        sec_widths[l] += len(header_sep)
                    sec_widths[l] += w
                    sec_columns[l] += 1
        # set width of format string:
        formats = []
        for c, (f, w) in enumerate(zip(self.formats, widths)):
            formats.append(f[:widths_pos[c][0]] + str(w) + f[widths_pos[c][1]:])
        # top line:
        if top_line:
            if table_format[0] == &#39;t&#39;:
                fh.write(&#39;  \\hline \\\\[-2ex]\n&#39;)
            else:
                first = True
                fh.write(header_start.replace(&#39; &#39;, &#39;-&#39;))
                for c in range(len(self.header)):
                    if self.hidden[c]:
                        continue
                    if not first:
                        fh.write(&#39;-&#39;*len(header_sep))
                    first = False
                    fh.write(header_close)
                    w = widths[c]
                    fh.write(w*&#39;-&#39;)
                fh.write(header_end.replace(&#39; &#39;, &#39;-&#39;))
        # section and column headers:
        nsec0 = self.nsecs-sections
        if nsec0 &lt; 0:
            nsec0 = 0
        for ns in range(nsec0, self.nsecs+1):
            nsec = self.nsecs-ns
            first = True
            last = False
            merged = False
            fh.write(header_start)
            for c in range(len(self.header)):
                if nsec &lt; len(self.header[c]):
                    # section width and column count:
                    sw = -len(header_sep)
                    columns = 0
                    if not self.hidden[c]:
                        sw = widths[c]
                        columns = 1
                    for k in range(c+1, len(self.header)):
                        if nsec &lt; len(self.header[k]):
                            break
                        if self.hidden[k]:
                            continue
                        sw += len(header_sep) + widths[k]
                        columns += 1
                    else:
                        last = True
                        if len(header_end.strip()) == 0:
                            sw = 0  # last entry needs no width
                    if columns == 0:
                        continue
                    if not first and not merged:
                        fh.write(header_sep)
                    first = False
                    if table_format[0] == &#39;c&#39;:
                        sw -= len(header_sep)*(columns-1)
                    elif table_format[0] == &#39;h&#39;:
                        if columns&gt;1:
                            fh.write(&#39; colspan=&#34;%d&#34;&#39; % columns)
                    elif table_format[0] == &#39;t&#39;:
                        if merged:
                            merged = False
                            continue
                        if latex_merge_std and nsec == 0 and stdev_col[c]:
                            merged = True
                            fh.write(&#39;\\multicolumn{%d}{c}{&#39; % (columns+1))
                        elif center_columns:
                            fh.write(&#39;\\multicolumn{%d}{c}{&#39; % columns)
                        else:
                            fh.write(&#39;\\multicolumn{%d}{l}{&#39; % columns)
                        if latex_label_command:
                            fh.write(&#39;\\%s{&#39; % latex_label_command)
                    fh.write(header_close)
                    hs = self.header[c][nsec]
                    if nsec == 0 and unit_style == &#39;header&#39;:
                        if self.units[c] and self.units[c] != &#39;1&#39; and self.units[c] != &#39;-&#39;:
                            hs += &#39;/&#39; + self.units[c]
                    if align_columns and not table_format[0] in &#39;th&#39;:
                        f = &#39;%%-%ds&#39; % sw
                        fh.write(f % hs)
                    else:
                        fh.write(hs)
                    if table_format[0] == &#39;c&#39;:
                        if not last:
                            fh.write(header_sep*(columns-1))
                    elif table_format[0] == &#39;t&#39;:
                        if latex_label_command:
                            fh.write(&#39;}&#39;)
                        fh.write(&#39;}&#39;)
            fh.write(header_end)
        # units:
        if unit_style == &#39;row&#39;:
            first = True
            merged = False
            fh.write(header_start)
            for c in range(len(self.header)):
                if self.hidden[c] or merged:
                    merged = False
                    continue
                if not first:
                    fh.write(header_sep)
                first = False
                fh.write(header_close)
                unit = self.units[c]
                if not unit:
                    unit = &#39;-&#39;
                if table_format[0] == &#39;t&#39;:
                    if latex_merge_std and stdev_col[c]:
                        merged = True
                        fh.write(&#39;\\multicolumn{2}{c}{%s}&#39; % latex_unit(unit))
                    elif center_columns:
                        fh.write(&#39;\\multicolumn{1}{c}{%s}&#39; % latex_unit(unit))
                    else:
                        fh.write(&#39;\\multicolumn{1}{l}{%s}&#39; % latex_unit(unit))
                else:
                    if align_columns and not table_format[0] in &#39;h&#39;:
                        f = &#39;%%-%ds&#39; % widths[c]
                        fh.write(f % unit)
                    else:
                        fh.write(unit)
            fh.write(header_end)
        # column numbers:
        if column_numbers is not None:
            first = True
            fh.write(header_start)
            for c in range(len(self.header)):
                if self.hidden[c]:
                    continue
                if not first:
                    fh.write(header_sep)
                first = False
                fh.write(header_close)
                i = c
                if column_numbers == &#39;num&#39;:
                    i = c+1
                aa = index2aa(c, &#39;a&#39;)
                if column_numbers == &#39;AA&#39;:
                    aa = index2aa(c, &#39;A&#39;)
                if table_format[0] == &#39;t&#39;:
                    if column_numbers == &#39;num&#39; or column_numbers == &#39;index&#39;:
                        fh.write(&#39;\\multicolumn{1}{l}{%d}&#39; % i)
                    else:
                        fh.write(&#39;\\multicolumn{1}{l}{%s}&#39; % aa)
                else:
                    if column_numbers == &#39;num&#39; or column_numbers == &#39;index&#39;:
                        if align_columns:
                            f = &#39;%%%dd&#39; % widths[c]
                            fh.write(f % i)
                        else:
                            fh.write(&#39;%d&#39; % i)
                    else:
                        if align_columns:
                            f = &#39;%%-%ds&#39; % widths[c]
                            fh.write(f % aa)
                        else:
                            fh.write(aa)
            fh.write(header_end)
        # header line:
        if header_line:
            if table_format[0] == &#39;m&#39;:
                fh.write(&#39;|&#39;)
                for c in range(len(self.header)):
                    if self.hidden[c]:
                        continue
                    w = widths[c]+2
                    if center_columns:
                        fh.write(&#39;:&#39; + (w-2)*&#39;-&#39; + &#39;:|&#39;)
                    elif formats[c][1] == &#39;-&#39;:
                        fh.write(w*&#39;-&#39; + &#39;|&#39;)
                    else:
                        fh.write((w-1)*&#39;-&#39; + &#39;:|&#39;)
                fh.write(&#39;\n&#39;)
            elif table_format[0] == &#39;t&#39;:
                fh.write(&#39;  \\hline \\\\[-2ex]\n&#39;)
            else:
                first = True
                fh.write(header_start.replace(&#39; &#39;, &#39;-&#39;))
                for c in range(len(self.header)):
                    if self.hidden[c]:
                        continue
                    if not first:
                        fh.write(header_sep.replace(&#39; &#39;, &#39;-&#39;))
                    first = False
                    fh.write(header_close)
                    w = widths[c]
                    fh.write(w*&#39;-&#39;)
                fh.write(header_end.replace(&#39; &#39;, &#39;-&#39;))
        # start table data:
        if table_format[0] == &#39;h&#39;:
            fh.write(&#39;&lt;/thead&gt;\n&lt;tbody&gt;\n&#39;)
        # data:
        for k in range(self.rows()):
            first = True
            merged = False
            fh.write(data_start)
            for c, f in enumerate(formats):
                if self.hidden[c] or merged:
                    merged = False
                    continue
                if not first:
                    fh.write(data_sep)
                first = False
                if table_format[0] == &#39;h&#39;:
                    if center_columns:
                        fh.write(&#39; align=&#34;center&#34;&#39;)
                    elif f[1] == &#39;-&#39;:
                        fh.write(&#39; align=&#34;left&#34;&#39;)
                    else:
                        fh.write(&#39; align=&#34;right&#34;&#39;)
                fh.write(data_close)
                if k &gt;= len(self.data[c]) or \
                   (isinstance(self.data[c][k], float) and m.isnan(self.data[c][k])):
                    # missing data:
                    if table_format[0] == &#39;t&#39; and latex_merge_std and stdev_col[c]:
                        merged = True
                        fh.write(&#39;\\multicolumn{2}{c}{%s}&#39; % missing)
                    elif align_columns:
                        if f[1] == &#39;-&#39;:
                            fn = &#39;%%-%ds&#39; % widths[c]
                        else:
                            fn = &#39;%%%ds&#39; % widths[c]
                        fh.write(fn % missing)
                    else:
                        fh.write(missing)
                else:
                    # data value:
                    ds = f % self.data[c][k]
                    if not align_columns:
                        ds = ds.strip()
                    fh.write(ds)
            fh.write(data_end)
        # bottom line:
        if bottom_line:
            if table_format[0] == &#39;t&#39;:
                fh.write(&#39;  \\hline\n&#39;)
            else:
                first = True
                fh.write(header_start.replace(&#39; &#39;, &#39;-&#39;))
                for c in range(len(self.header)):
                    if self.hidden[c]:
                        continue
                    if not first:
                        fh.write(&#39;-&#39;*len(header_sep))
                    first = False
                    fh.write(header_close)
                    w = widths[c]
                    fh.write(w*&#39;-&#39;)
                fh.write(header_end.replace(&#39; &#39;, &#39;-&#39;))
        # end table:
        fh.write(end_str)
        # close file:
        if own_file:
            fh.close()
        # return file name:
        return file_name

            
    def __str__(self):
        &#34;&#34;&#34;Write table to a string.
        &#34;&#34;&#34;
        stream = StringIO()
        self.write(stream, table_format=&#39;out&#39;)
        return stream.getvalue()
                

    def load(self, fh, missing=&#39;-&#39;):
        &#34;&#34;&#34;Load table from file or stream.

        File type and properties are automatically inferred.

        Parameters
        ----------
        fh: filename or stream
            If not a stream, the file with name `fh` is opened for reading.
        missing: string
            Missing data are indicated by this string.

        Raises
        ------
        FileNotFoundError:
            If `fh` is a path that does not exist.
        &#34;&#34;&#34;

        def read_key_line(line, sep, table_format):
            if sep is None:
                cols, indices = zip(*[(m.group(0), m.start()) for m in re.finditer(r&#39;( ?[\S]+)+(?=[ ][ ]+|\Z)&#39;, line.strip())])
            elif table_format == &#39;csv&#39;:
                cols, indices = zip(*[(c.strip(), i) for i, c in enumerate(line.strip().split(sep)) if c.strip()])
                return cols, indices
            else:
                seps = r&#39;[^&#39;+re.escape(sep)+&#39;]+&#39;
                cols, indices = zip(*[(m.group(0), m.start()) for m in re.finditer(seps, line.strip())])
            colss = []
            indicess = []
            if table_format == &#39;tex&#39;:
                i = 0
                for c in cols:
                    if &#39;multicolumn&#39; in c:
                        fields = c.split(&#39;{&#39;)
                        n = int(fields[1].strip().rstrip(&#39;}&#39;).rstrip())
                        colss.append(fields[3].strip().rstrip(&#39;}&#39;).rstrip())
                        indicess.append(i)
                        i += n
                    else:
                        colss.append(c.strip())
                        indicess.append(i)
                        i += 1
            else:
                for k, (c, i) in enumerate(zip(cols, indices)):
                    if k == 0:
                        c = c.lstrip(&#39;|&#39;)
                    if k == len(cols)-1:
                        c = c.rstrip(&#39;|&#39;)
                    cs = c.strip()
                    colss.append(cs)
                    indicess.append(i)
            return colss, indicess

        def read_data_line(line, sep, post, precd, alld, numc, exped, fixed, strf, missing):
            # read line:
            cols = []
            if sep is None:
                cols = [m.group(0) for m in re.finditer(r&#39;\S+&#39;, line.strip())]
            else:
                seps = r&#39;[^&#39;+re.escape(sep)+&#39;]+&#39;
                cols = [m.group(0).strip() for m in re.finditer(seps, line.strip())]
                cols[0] = cols[0].lstrip(&#39;|&#39;).lstrip()
                cols[-1] = cols[-1].rstrip(&#39;|&#39;).rstrip()
            cols = [c for c in cols if c not in &#39;|&#39;]
            # read columns:
            for k, c in enumerate(cols):
                c = c.strip()
                try:
                    v = float(c)
                    ad = 0
                    ve = c.split(&#39;e&#39;)
                    if len(ve) &lt;= 1:
                        exped[k] = False
                    else:
                        ad = len(ve[1])+1
                    vc = ve[0].split(&#39;.&#39;)
                    ad += len(vc[0])
                    prec = len(vc[0].lstrip(&#39;-&#39;).lstrip(&#39;+&#39;).lstrip(&#39;0&#39;)) 
                    if len(vc) == 2:
                        if numc[k] and post[k] != len(vc[1]):
                            fixed[k] = False
                        if post[k] &lt; len(vc[1]):
                            post[k] = len(vc[1])
                        ad += len(vc[1])+1
                        prec += len(vc[1].rstrip(&#39;0&#39;))
                    if precd[k] &lt; prec:
                        precd[k] = prec
                    if alld[k] &lt; ad:
                        alld[k] = ad
                    numc[k] = True
                except ValueError:
                    if c == missing:
                        v = np.nan
                    else:
                        strf[k] = True
                        if alld[k] &lt; len(c):
                            alld[k] = len(c)
                        v = c
                self.append_data(v, k)

        # initialize:
        self.data = []
        self.shape = (0, 0)
        self.header = []
        self.nsecs = 0
        self.units = []
        self.formats = []
        self.hidden = []
        self.setcol = 0
        self.addcol = 0
        # open file:
        own_file = False
        if not hasattr(fh, &#39;readline&#39;):
            fh = open(fh, &#39;r&#39;)
            own_file = True
        # read inital lines of file:
        key = []
        data = []
        target = data
        comment = False
        table_format=&#39;dat&#39;        
        for line in fh:
            line = line.rstrip()
            if line:
                if r&#39;\begin{tabular&#39; in line:
                    table_format=&#39;tex&#39;
                    target = key
                    continue
                if table_format == &#39;tex&#39;:
                    if r&#39;\end{tabular&#39; in line:
                        break
                    if r&#39;\hline&#39; in line:
                        if key:
                            target = data
                        continue
                    line = line.rstrip(r&#39;\\&#39;)
                if line[0] == &#39;#&#39;:
                    comment = True
                    table_format=&#39;dat&#39;        
                    target = key
                    line = line.lstrip(&#39;#&#39;)
                elif comment:
                    target = data
                if line[0:3] == &#39;RTH&#39;:
                    target = key
                    line = line[3:]
                    table_format=&#39;rtai&#39;
                elif line[0:3] == &#39;RTD&#39;:
                    target = data
                    line = line[3:]
                    table_format=&#39;rtai&#39;        
                if (line[0:3] == &#39;|--&#39; or line[0:3] == &#39;|:-&#39;) and \
                   (line[-3:] == &#39;--|&#39; or line[-3:] == &#39;-:|&#39;):
                    if not data and not key:
                        table_format=&#39;ascii&#39;
                        target = key
                        continue
                    elif not key:
                        table_format=&#39;md&#39;
                        key = data
                        data = []
                        target = data
                        continue
                    elif not data:
                        target = data
                        continue
                    else:
                        break
                target.append(line)
            else:
                break
            if len(data) &gt; 5:
                break
        # find column separator of data and number of columns:
        col_seps = [&#39;|&#39;, &#39;,&#39;, &#39;;&#39;, &#39;:&#39;, &#39;\t&#39;, &#39;&amp;&#39;, None]
        colstd = np.zeros(len(col_seps))
        colnum = np.zeros(len(col_seps), dtype=int)
        for k, sep in enumerate(col_seps):
            cols = []
            s = 5 if len(data) &gt;= 8 else len(data) - 3
            if s &lt; 0 or key:
                s = 0
            for line in data[s:]:
                cs = line.strip().split(sep)
                if not cs[0]:
                    cs = cs[1:]
                if cs and not cs[-1]:
                    cs = cs[:-1]
                cols.append(len(cs))
            colstd[k] = np.std(cols)
            colnum[k] = np.median(cols)
        if np.max(colnum) &lt; 2:
            sep = None
            colnum = 1
        else:
            ci = np.where(np.array(colnum)&gt;1.5)[0]
            ci = ci[np.argmin(colstd[ci])]
            sep = col_seps[ci]
            colnum = int(colnum[ci])
        # fix key:
        if not key and sep is not None and sep in &#39;,;:\t|&#39;:
            table_format = &#39;csv&#39;
        # read key:
        key_cols = []
        key_indices = []
        for line in key:
            cols, indices = read_key_line(line, sep, table_format)
            key_cols.append(cols)
            key_indices.append(indices)
        if not key_cols:
            # no obviously marked table key:
            key_num = 0
            for line in data:
                cols, indices = read_key_line(line, sep, table_format)
                numbers = 0
                for c in cols:
                    try:
                        v = float(c)
                        numbers += 1
                    except ValueError:
                        pass
                if numbers == 0:
                    key_cols.append(cols)
                    key_indices.append(indices)
                    key_num += 1
                else:
                    break
            data = data[key_num:]
        kr = len(key_cols)-1
        # check for key with column indices:
        if kr &gt;= 0:
            cols = key_cols[kr]
            numrow = True
            try:
                pv = int(cols[0])
                for c in cols[1:]:
                    v = int(c)
                    if v != pv+1:
                        numrow = False
                        break
                    pv = v
            except ValueError:
                try:
                    pv = aa2index(cols[0])
                    for c in cols[1:]:
                        v = aa2index(c)
                        if v != pv+1:
                            numrow = False
                            break
                        pv = v
                except ValueError:
                    numrow = False
            if numrow:
                kr -= 1
        # check for unit line:
        units = None
        if kr &gt; 0 and len(key_cols[kr]) == len(key_cols[kr-1]):
            units = key_cols[kr]
            kr -= 1
        # column labels:
        if kr &gt;= 0:
            if units is None:
                # units may be part of the label:
                labels = []
                units = []
                for c in key_cols[kr]:
                    if c[-1] == &#39;)&#39;:
                        lu = c[:-1].split(&#39;(&#39;)
                        if len(lu) &gt;= 2:
                            labels.append(lu[0].strip())
                            units.append(&#39;(&#39;.join(lu[1:]).strip())
                            continue
                    lu = c.split(&#39;/&#39;)
                    if len(lu) &gt;= 2:
                        labels.append(lu[0].strip())
                        units.append(&#39;/&#39;.join(lu[1:]).strip())
                    else:
                        labels.append(c)
                        units.append(&#39;&#39;)
            else:
                labels = key_cols[kr]
            indices = key_indices[kr]
            # init table columns:
            for k in range(colnum):
                self.append(labels[k], units[k], &#39;%g&#39;)
        # read in sections:
        while kr &gt; 0:
            kr -= 1
            for sec_label, sec_inx in zip(key_cols[kr], key_indices[kr]):
                col_inx = indices.index(sec_inx)
                self.header[col_inx].append(sec_label)
                if self.nsecs &lt; len(self.header[col_inx])-1:
                    self.nsecs = len(self.header[col_inx])-1
        # read data:
        post = np.zeros(colnum)
        precd = np.zeros(colnum)
        alld = np.zeros(colnum)
        numc = [False] * colnum
        exped = [True] * colnum
        fixed = [True] * colnum
        strf = [False] * colnum
        for line in data:
            read_data_line(line, sep, post, precd, alld, numc, exped, fixed, strf, missing)
        # read remaining data:
        for line in fh:
            line = line.rstrip()
            if table_format == &#39;tex&#39;:
                if r&#39;\end{tabular&#39; in line or r&#39;\hline&#39; in line:
                    break
                line = line.rstrip(r&#39;\\&#39;)
            if (line[0:3] == &#39;|--&#39; or line[0:3] == &#39;|:-&#39;) and \
                (line[-3:] == &#39;--|&#39; or line[-3:] == &#39;-:|&#39;):
                break
            if line[0:3] == &#39;RTD&#39;:
                line = line[3:]
            read_data_line(line, sep, post, precd, alld, numc, exped, fixed, strf, missing)
        # set formats:
        for k in range(len(alld)):
            if strf[k]:
                self.set_format(&#39;%%-%ds&#39; % alld[k], k)
            elif exped[k]:
                self.set_format(&#39;%%%d.%de&#39; % (alld[k], post[k]), k)
            elif fixed[k]:
                self.set_format(&#39;%%%d.%df&#39; % (alld[k], post[k]), k)
            else:
                self.set_format(&#39;%%%d.%dg&#39; % (alld[k], precd[k]), k)
        # close file:
        if own_file:
            fh.close()


def write(fh, data, header, units=None, formats=None, table_format=None, delimiter=None,
              unit_style=None, column_numbers=None, sections=None,
              align_columns=None, shrink_width=True, missing=&#39;-&#39;,
              center_columns=False, latex_label_command=&#39;&#39;, latex_merge_std=False):
    &#34;&#34;&#34;Construct table and write to file.

    Parameters
    ----------
    fh: filename or stream
        If not a stream, the file with name `fh` is opened.
        If `fh` does not have an extension,
        the `table_format` is appended as an extension.
        Otherwise `fh` is used as a stream for writing.
    data: 1-D or 2-D array of data
          The data of the table.
    header: list of string
        Header labels for each column.
    units: list of string, optional
        Unit strings for each column.
    formats: string or list of string, optional
        Format strings for each column. If only a single format string is
        given, then all columns are initialized with this format string.

    See `TableData.write()` for a description of all other parameters.

    Example
    -------
    ```
    write(sys.stdout, np.random.randn(4,3), [&#39;aaa&#39;, &#39;bbb&#39;, &#39;ccc&#39;], units=[&#39;m&#39;, &#39;s&#39;, &#39;g&#39;], formats=&#39;%.2f&#39;)
    ```
    &#34;&#34;&#34;
    td = TableData(data, header, units, formats)
    td.write(fh, table_format=table_format, unit_style=unit_style,
             column_numbers=column_numbers, missing=missing, shrink_width=shrink_width,
             delimiter=delimiter, align_columns=align_columns, sections=sections,
             latex_label_command=latex_label_command, latex_merge_std=latex_merge_std)

    
def add_write_table_config(cfg, table_format=None, delimiter=None,
                           unit_style=None, column_numbers=None, sections=None,
                           align_columns=None, shrink_width=True, missing=&#39;-&#39;,
                           center_columns=False, latex_label_command=&#39;&#39;, latex_merge_std=False):
    &#34;&#34;&#34;Add parameter specifying how to write a table to a file as a new
section to a configuration.

    Parameters
    ----------
    cfg: ConfigFile
        The configuration.
    &#34;&#34;&#34;

    cfg.add_section(&#39;File format for storing analysis results:&#39;)
    cfg.add(&#39;fileFormat&#39;, table_format or &#39;auto&#39;, &#39;&#39;, &#39;Default file format used to store analysis results.\nOne of %s.&#39; % &#39;, &#39;.join(TableData.formats))
    cfg.add(&#39;fileDelimiter&#39;, delimiter or &#39;auto&#39;, &#39;&#39;, &#39;String used to separate columns or &#34;auto&#34;.&#39;)
    cfg.add(&#39;fileUnitStyle&#39;, unit_style or &#39;auto&#39;, &#39;&#39;, &#39;Add units as extra row (&#34;row&#34;), add units to header label separated by &#34;/&#34; (&#34;header&#34;), do not print out units (&#34;none&#34;), or &#34;auto&#34;.&#39;)
    cfg.add(&#39;fileColumnNumbers&#39;, column_numbers or &#39;none&#39;, &#39;&#39;, &#39;Add line with column indices (&#34;index&#34;, &#34;num&#34;, &#34;aa&#34;, &#34;AA&#34;, or &#34;none&#34;)&#39;)
    cfg.add(&#39;fileSections&#39;, sections or &#39;auto&#39;, &#39;&#39;, &#39;Maximum number of section levels or &#34;auto&#34;&#39;)
    cfg.add(&#39;fileAlignColumns&#39;, align_columns or &#39;auto&#39;, &#39;&#39;, &#39;If True, write all data of a column using the same width, if False write the data without any white space, or &#34;auto&#34;.&#39;)
    cfg.add(&#39;fileShrinkColumnWidth&#39;, shrink_width, &#39;&#39;, &#39;Allow to make columns narrower than specified by the corresponding format strings.&#39;)
    cfg.add(&#39;fileMissing&#39;, missing, &#39;&#39;, &#39;String used to indicate missing data values.&#39;)
    cfg.add(&#39;fileCenterColumns&#39;, center_columns, &#39;&#39;, &#39;Center content of all columns instead of left align columns of strings and right align numbers (markdown, html, and latex).&#39;)
    cfg.add(&#39;fileLaTeXLabelCommand&#39;, latex_label_command, &#39;&#39;, &#39;LaTeX command name for formatting column labels of the table header.&#39;)
    cfg.add(&#39;fileLaTeXMergeStd&#39;, latex_merge_std, &#39;&#39;, &#39;Merge header of columns with standard deviations with previous column (LaTeX tables only).&#39;)


def write_table_args(cfg):
    &#34;&#34;&#34;Translates a configuration to the respective parameter names for
writing a table to a file.
    
    The return value can then be passed as key-word arguments to TableData.write().

    Parameters
    ----------
    cfg: ConfigFile
        The configuration.

    Returns
    -------
    a: dict
        Dictionary with names of arguments of the `TableData.write` function
        and their values as supplied by `cfg`.
    &#34;&#34;&#34;
    d = cfg.map({&#39;table_format&#39;: &#39;fileFormat&#39;,
                 &#39;delimiter&#39;: &#39;fileDelimiter&#39;,
                 &#39;unit_style&#39;: &#39;fileUnitStyle&#39;,
                 &#39;column_numbers&#39;: &#39;fileColumnNumbers&#39;,
                 &#39;sections&#39;: &#39;fileSections&#39;,
                 &#39;align_columns&#39;: &#39;fileAlignColumns&#39;,
                 &#39;shrink_width&#39;: &#39;fileShrinkColumnWidth&#39;,
                 &#39;missing&#39;: &#39;fileMissing&#39;,
                 &#39;center_columns&#39;: &#39;fileCenterColumns&#39;,
                 &#39;latex_label_command&#39;: &#39;fileLaTeXLabelCommand&#39;,
                 &#39;latex_merge_std&#39;: &#39;fileLaTeXMergeStd&#39;})
    if &#39;sections&#39; in d:
        if d[&#39;sections&#39;] != &#39;auto&#39;:
            d[&#39;sections&#39;] = int(d[&#39;sections&#39;])
    return d


def latex_unit(unit):
    &#34;&#34;&#34;Translate unit string into SIunit LaTeX code.
    
    Parameters
    ----------
    unit: string
        String enoting a unit.
        
    Returns
    -------
    unit: string
        Unit string as valid LaTeX code.
    &#34;&#34;&#34;
    si_prefixes = {&#39;y&#39;: &#39;\\yocto&#39;,
                  &#39;z&#39;: &#39;\\zepto&#39;,
                  &#39;a&#39;: &#39;\\atto&#39;,
                  &#39;f&#39;: &#39;\\femto&#39;,
                  &#39;p&#39;: &#39;\\pico&#39;,
                  &#39;n&#39;: &#39;\\nano&#39;,
                  &#39;u&#39;: &#39;\\micro&#39;,
                  &#39;m&#39;: &#39;\\milli&#39;,
                  &#39;c&#39;: &#39;\\centi&#39;,
                  &#39;d&#39;: &#39;\\deci&#39;,
                  &#39;h&#39;: &#39;\\hecto&#39;,
                  &#39;k&#39;: &#39;\\kilo&#39;,
                  &#39;M&#39;: &#39;\\mega&#39;,
                  &#39;G&#39;: &#39;\\giga&#39;,
                  &#39;T&#39;: &#39;\\tera&#39;,
                  &#39;P&#39;: &#39;\\peta&#39;,
                  &#39;E&#39;: &#39;\\exa&#39;,
                  &#39;Z&#39;: &#39;\\zetta&#39;,
                  &#39;Y&#39;: &#39;\\yotta&#39; }
    si_units = {&#39;m&#39;: &#39;\\metre&#39;,
               &#39;g&#39;: &#39;\\gram&#39;,
               &#39;s&#39;: &#39;\\second&#39;,
               &#39;A&#39;: &#39;\\ampere&#39;,
               &#39;K&#39;: &#39;\\kelvin&#39;,
               &#39;mol&#39;: &#39;\\mole&#39;,
               &#39;cd&#39;: &#39;\\candela&#39;,
               &#39;Hz&#39;: &#39;\\hertz&#39;,
               &#39;N&#39;: &#39;\\newton&#39;,
               &#39;Pa&#39;: &#39;\\pascal&#39;,
               &#39;J&#39;: &#39;\\joule&#39;,
               &#39;W&#39;: &#39;\\watt&#39;,
               &#39;C&#39;: &#39;\\coulomb&#39;,
               &#39;V&#39;: &#39;\\volt&#39;,
               &#39;F&#39;: &#39;\\farad&#39;,
               &#39;O&#39;: &#39;\\ohm&#39;,
               &#39;S&#39;: &#39;\\siemens&#39;,
               &#39;Wb&#39;: &#39;\\weber&#39;,
               &#39;T&#39;: &#39;\\tesla&#39;,
               &#39;H&#39;: &#39;\\henry&#39;,
               &#39;C&#39;: &#39;\\celsius&#39;,
               &#39;lm&#39;: &#39;\\lumen&#39;,
               &#39;lx&#39;: &#39;\\lux&#39;,
               &#39;Bq&#39;: &#39;\\becquerel&#39;,
               &#39;Gv&#39;: &#39;\\gray&#39;,
               &#39;Sv&#39;: &#39;\\sievert&#39;}
    other_units = {&#34;&#39;&#34;: &#39;\\arcminute&#39;,
               &#34;&#39;&#39;&#34;: &#39;\\arcsecond&#39;,
               &#39;a&#39;: &#39;\\are&#39;,
               &#39;d&#39;: &#39;\\dday&#39;,
               &#39;eV&#39;: &#39;\\electronvolt&#39;,
               &#39;ha&#39;: &#39;\\hectare&#39;,
               &#39;h&#39;: &#39;\\hour&#39;,
               &#39;L&#39;: &#39;\\liter&#39;,
               &#39;l&#39;: &#39;\\litre&#39;,
               &#39;min&#39;: &#39;\\minute&#39;,
               &#39;Np&#39;: &#39;\\neper&#39;,
               &#39;rad&#39;: &#39;\\rad&#39;,
               &#39;t&#39;: &#39;\\ton&#39;,
               &#39;%&#39;: &#39;\\%&#39;}
    unit_powers = {&#39;^2&#39;: &#39;\\squared&#39;,
              &#39;^3&#39;: &#39;\\cubed&#39;,
              &#39;/&#39;: &#39;\\per&#39;,
              &#39;^-1&#39;: &#39;\\power{}{-1}&#39;,
              &#39;^-2&#39;: &#39;\\rpsquared&#39;,
              &#39;^-3&#39;: &#39;\\rpcubed&#39;}
    if &#39;\\&#39; in unit:   # this string is already translated!
        return unit
    units = &#39;&#39;
    j = len(unit)
    while j &gt;= 0:
        for k in range(-3, 0):
            if j+k &lt; 0:
                continue
            uss = unit[j+k:j]
            if uss in unit_powers:
                units = unit_powers[uss] + units
                break
            elif uss in other_units:
                units = other_units[uss] + units
                break
            elif uss in si_units:
                units = si_units[uss] + units
                j = j+k
                k = 0
                if j-1 &gt;= 0:
                    uss = unit[j-1:j]
                    if uss in si_prefixes:
                        units = si_prefixes[uss] + units
                        k = -1
                break
        else:
            k = -1
            units = unit[j+k:j] + units
        j = j + k
    return units


def index2aa(n, a=&#39;a&#39;):
    &#34;&#34;&#34;Convert an integer into an alphabetical representation.

    The integer number is converted into &#39;a&#39;, &#39;b&#39;, &#39;c&#39;, ..., &#39;z&#39;,
    &#39;aa&#39;, &#39;ab&#39;, &#39;ac&#39;, ..., &#39;az&#39;, &#39;ba&#39;, &#39;bb&#39;, ...

    Inspired by https://stackoverflow.com/a/37604105

    Parameters
    ----------
    n: int
        An integer to be converted into alphabetical representation.
    a: string (&#39;a&#39; or &#39;A&#39;)
        Use upper or lower case characters.

    Returns
    -------
    ns: string
        Alphabetical represtnation of an integer.
    &#34;&#34;&#34;
    d, m = divmod(n, 26)
    bm = chr(ord(a)+m)
    return index2aa(d-1, a) + bm if d else bm


def aa2index(s):
    &#34;&#34;&#34;Convert an alphabetical representation to an index.

    The alphabetical representation &#39;a&#39;, &#39;b&#39;, &#39;c&#39;, ..., &#39;z&#39;,
    &#39;aa&#39;, &#39;ab&#39;, &#39;ac&#39;, ..., &#39;az&#39;, &#39;ba&#39;, &#39;bb&#39;, ...
    is converted to an index starting with 0.

    Parameters
    ----------
    s: string
        Alphabetical representation of an index.

    Returns
    -------
    index: int
        The corresponding index.

    Raises
    ------
    ValueError:
        Invalid character in input string.
    &#34;&#34;&#34;
    index = 0
    maxc = ord(&#39;z&#39;) - ord(&#39;a&#39;) + 1
    for c in s.lower():
        index *= maxc
        if ord(c) &lt; ord(&#39;a&#39;) or ord(c) &gt; ord(&#39;z&#39;):
            raise ValueError(&#39;invalid character &#34;%s&#34; in string.&#39; % c)
        index += ord(c) - ord(&#39;a&#39;) + 1
    return index-1

        
class IndentStream(object):
    &#34;&#34;&#34;Filter an output stream and start each newline with a number of
    spaces.
    &#34;&#34;&#34;
    def __init__(self, stream, indent=4):
        self.stream = stream
        self.indent = indent
        self.pending = True

    def __getattr__(self, attr_name):
        return getattr(self.stream, attr_name)

    def write(self, data):
        if not data:
            return
        if self.pending:
            self.stream.write(&#39; &#39;*self.indent)
            self.pending = False
        substr = data.rstrip(&#39;\n&#39;)
        rn = len(data) - len(substr)
        if len(substr) &gt; 0:
            self.stream.write(substr.replace(&#39;\n&#39;, &#39;\n&#39;+&#39; &#39;*self.indent))
        if rn &gt; 0:
            self.stream.write(&#39;\n&#39;*rn)
            self.pending = True

    def flush(self):
        self.stream.flush()

        
if __name__ == &#34;__main__&#34;:
    import os
    
    print(&#34;Checking tabledata module ...&#34;)
    print(&#39;&#39;)

    # setup a table:
    df = TableData()
    df.append([&#34;data&#34;, &#34;partial information&#34;, &#34;ID&#34;], &#34;&#34;, &#34;%-s&#34;, list(&#39;ABCDEFGH&#39;))
    df.append(&#34;size&#34;, &#34;m&#34;, &#34;%6.2f&#34;, [2.34, 56.7, 8.9])
    df.append(&#34;full weight&#34;, &#34;kg&#34;, &#34;%.0f&#34;, 122.8)
    df.append_section(&#34;complete reaction&#34;)
    df.append(&#34;speed&#34;, &#34;m/s&#34;, &#34;%.3g&#34;, 98.7)
    df.append(&#34;median jitter&#34;, &#34;mm&#34;, &#34;%.1f&#34;, 23)
    df.append(&#34;size&#34;, &#34;g&#34;, &#34;%.2e&#34;, 1.234)
    df.append_data(np.nan, 2)  # single value
    df.append_data((0.543, 45, 1.235e2)) # remaining row
    df.append_data((43.21, 6789.1, 3405, 1.235e-4), 2) # next row
    a = 0.5*np.arange(1, 6)*np.random.randn(5, 5) + 10.0 + np.arange(5)
    df.append_data(a.T, 1) # rest of table
    df[3:6,&#39;weight&#39;] = [11.0]*3
    
    # write out in all formats:
    for tf in TableData.formats:
        print(&#39;    - `%s`: %s&#39; % (tf, TableData.descriptions[tf]))
        print(&#39;      ```&#39;)
        iout = IndentStream(sys.stdout, 4+2)
        df.write(iout, table_format=tf)
        print(&#39;      ```&#39;)
        print(&#39;&#39;)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="thunderfish.tabledata.aa2index"><code class="name flex">
<span>def <span class="ident">aa2index</span></span>(<span>s)</span>
</code></dt>
<dd>
<div class="desc"><p>Convert an alphabetical representation to an index.</p>
<p>The alphabetical representation 'a', 'b', 'c', &hellip;, 'z',
'aa', 'ab', 'ac', &hellip;, 'az', 'ba', 'bb', &hellip;
is converted to an index starting with 0.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>s</code></strong> :&ensp;<code>string</code></dt>
<dd>Alphabetical representation of an index.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>index</code></strong> :&ensp;<code>int</code></dt>
<dd>The corresponding index.</dd>
</dl>
<h2 id="raises">Raises</h2>
<h2 id="valueerror">Valueerror</h2>
<p>Invalid character in input string.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def aa2index(s):
    &#34;&#34;&#34;Convert an alphabetical representation to an index.

    The alphabetical representation &#39;a&#39;, &#39;b&#39;, &#39;c&#39;, ..., &#39;z&#39;,
    &#39;aa&#39;, &#39;ab&#39;, &#39;ac&#39;, ..., &#39;az&#39;, &#39;ba&#39;, &#39;bb&#39;, ...
    is converted to an index starting with 0.

    Parameters
    ----------
    s: string
        Alphabetical representation of an index.

    Returns
    -------
    index: int
        The corresponding index.

    Raises
    ------
    ValueError:
        Invalid character in input string.
    &#34;&#34;&#34;
    index = 0
    maxc = ord(&#39;z&#39;) - ord(&#39;a&#39;) + 1
    for c in s.lower():
        index *= maxc
        if ord(c) &lt; ord(&#39;a&#39;) or ord(c) &gt; ord(&#39;z&#39;):
            raise ValueError(&#39;invalid character &#34;%s&#34; in string.&#39; % c)
        index += ord(c) - ord(&#39;a&#39;) + 1
    return index-1</code></pre>
</details>
</dd>
<dt id="thunderfish.tabledata.add_write_table_config"><code class="name flex">
<span>def <span class="ident">add_write_table_config</span></span>(<span>cfg, table_format=None, delimiter=None, unit_style=None, column_numbers=None, sections=None, align_columns=None, shrink_width=True, missing='-', center_columns=False, latex_label_command='', latex_merge_std=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Add parameter specifying how to write a table to a file as a new
section to a configuration.</p>
<pre><code>Parameters
----------
cfg: ConfigFile
    The configuration.
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_write_table_config(cfg, table_format=None, delimiter=None,
                           unit_style=None, column_numbers=None, sections=None,
                           align_columns=None, shrink_width=True, missing=&#39;-&#39;,
                           center_columns=False, latex_label_command=&#39;&#39;, latex_merge_std=False):
    &#34;&#34;&#34;Add parameter specifying how to write a table to a file as a new
section to a configuration.

    Parameters
    ----------
    cfg: ConfigFile
        The configuration.
    &#34;&#34;&#34;

    cfg.add_section(&#39;File format for storing analysis results:&#39;)
    cfg.add(&#39;fileFormat&#39;, table_format or &#39;auto&#39;, &#39;&#39;, &#39;Default file format used to store analysis results.\nOne of %s.&#39; % &#39;, &#39;.join(TableData.formats))
    cfg.add(&#39;fileDelimiter&#39;, delimiter or &#39;auto&#39;, &#39;&#39;, &#39;String used to separate columns or &#34;auto&#34;.&#39;)
    cfg.add(&#39;fileUnitStyle&#39;, unit_style or &#39;auto&#39;, &#39;&#39;, &#39;Add units as extra row (&#34;row&#34;), add units to header label separated by &#34;/&#34; (&#34;header&#34;), do not print out units (&#34;none&#34;), or &#34;auto&#34;.&#39;)
    cfg.add(&#39;fileColumnNumbers&#39;, column_numbers or &#39;none&#39;, &#39;&#39;, &#39;Add line with column indices (&#34;index&#34;, &#34;num&#34;, &#34;aa&#34;, &#34;AA&#34;, or &#34;none&#34;)&#39;)
    cfg.add(&#39;fileSections&#39;, sections or &#39;auto&#39;, &#39;&#39;, &#39;Maximum number of section levels or &#34;auto&#34;&#39;)
    cfg.add(&#39;fileAlignColumns&#39;, align_columns or &#39;auto&#39;, &#39;&#39;, &#39;If True, write all data of a column using the same width, if False write the data without any white space, or &#34;auto&#34;.&#39;)
    cfg.add(&#39;fileShrinkColumnWidth&#39;, shrink_width, &#39;&#39;, &#39;Allow to make columns narrower than specified by the corresponding format strings.&#39;)
    cfg.add(&#39;fileMissing&#39;, missing, &#39;&#39;, &#39;String used to indicate missing data values.&#39;)
    cfg.add(&#39;fileCenterColumns&#39;, center_columns, &#39;&#39;, &#39;Center content of all columns instead of left align columns of strings and right align numbers (markdown, html, and latex).&#39;)
    cfg.add(&#39;fileLaTeXLabelCommand&#39;, latex_label_command, &#39;&#39;, &#39;LaTeX command name for formatting column labels of the table header.&#39;)
    cfg.add(&#39;fileLaTeXMergeStd&#39;, latex_merge_std, &#39;&#39;, &#39;Merge header of columns with standard deviations with previous column (LaTeX tables only).&#39;)</code></pre>
</details>
</dd>
<dt id="thunderfish.tabledata.index2aa"><code class="name flex">
<span>def <span class="ident">index2aa</span></span>(<span>n, a='a')</span>
</code></dt>
<dd>
<div class="desc"><p>Convert an integer into an alphabetical representation.</p>
<p>The integer number is converted into 'a', 'b', 'c', &hellip;, 'z',
'aa', 'ab', 'ac', &hellip;, 'az', 'ba', 'bb', &hellip;</p>
<p>Inspired by <a href="https://stackoverflow.com/a/37604105">https://stackoverflow.com/a/37604105</a></p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>n</code></strong> :&ensp;<code>int</code></dt>
<dd>An integer to be converted into alphabetical representation.</dd>
<dt><strong><code>a</code></strong> :&ensp;<code>string ('a'</code> or <code>'A')</code></dt>
<dd>Use upper or lower case characters.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>ns</code></strong> :&ensp;<code>string</code></dt>
<dd>Alphabetical represtnation of an integer.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def index2aa(n, a=&#39;a&#39;):
    &#34;&#34;&#34;Convert an integer into an alphabetical representation.

    The integer number is converted into &#39;a&#39;, &#39;b&#39;, &#39;c&#39;, ..., &#39;z&#39;,
    &#39;aa&#39;, &#39;ab&#39;, &#39;ac&#39;, ..., &#39;az&#39;, &#39;ba&#39;, &#39;bb&#39;, ...

    Inspired by https://stackoverflow.com/a/37604105

    Parameters
    ----------
    n: int
        An integer to be converted into alphabetical representation.
    a: string (&#39;a&#39; or &#39;A&#39;)
        Use upper or lower case characters.

    Returns
    -------
    ns: string
        Alphabetical represtnation of an integer.
    &#34;&#34;&#34;
    d, m = divmod(n, 26)
    bm = chr(ord(a)+m)
    return index2aa(d-1, a) + bm if d else bm</code></pre>
</details>
</dd>
<dt id="thunderfish.tabledata.latex_unit"><code class="name flex">
<span>def <span class="ident">latex_unit</span></span>(<span>unit)</span>
</code></dt>
<dd>
<div class="desc"><p>Translate unit string into SIunit LaTeX code.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>unit</code></strong> :&ensp;<code>string</code></dt>
<dd>String enoting a unit.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>unit</code></strong> :&ensp;<code>string</code></dt>
<dd>Unit string as valid LaTeX code.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def latex_unit(unit):
    &#34;&#34;&#34;Translate unit string into SIunit LaTeX code.
    
    Parameters
    ----------
    unit: string
        String enoting a unit.
        
    Returns
    -------
    unit: string
        Unit string as valid LaTeX code.
    &#34;&#34;&#34;
    si_prefixes = {&#39;y&#39;: &#39;\\yocto&#39;,
                  &#39;z&#39;: &#39;\\zepto&#39;,
                  &#39;a&#39;: &#39;\\atto&#39;,
                  &#39;f&#39;: &#39;\\femto&#39;,
                  &#39;p&#39;: &#39;\\pico&#39;,
                  &#39;n&#39;: &#39;\\nano&#39;,
                  &#39;u&#39;: &#39;\\micro&#39;,
                  &#39;m&#39;: &#39;\\milli&#39;,
                  &#39;c&#39;: &#39;\\centi&#39;,
                  &#39;d&#39;: &#39;\\deci&#39;,
                  &#39;h&#39;: &#39;\\hecto&#39;,
                  &#39;k&#39;: &#39;\\kilo&#39;,
                  &#39;M&#39;: &#39;\\mega&#39;,
                  &#39;G&#39;: &#39;\\giga&#39;,
                  &#39;T&#39;: &#39;\\tera&#39;,
                  &#39;P&#39;: &#39;\\peta&#39;,
                  &#39;E&#39;: &#39;\\exa&#39;,
                  &#39;Z&#39;: &#39;\\zetta&#39;,
                  &#39;Y&#39;: &#39;\\yotta&#39; }
    si_units = {&#39;m&#39;: &#39;\\metre&#39;,
               &#39;g&#39;: &#39;\\gram&#39;,
               &#39;s&#39;: &#39;\\second&#39;,
               &#39;A&#39;: &#39;\\ampere&#39;,
               &#39;K&#39;: &#39;\\kelvin&#39;,
               &#39;mol&#39;: &#39;\\mole&#39;,
               &#39;cd&#39;: &#39;\\candela&#39;,
               &#39;Hz&#39;: &#39;\\hertz&#39;,
               &#39;N&#39;: &#39;\\newton&#39;,
               &#39;Pa&#39;: &#39;\\pascal&#39;,
               &#39;J&#39;: &#39;\\joule&#39;,
               &#39;W&#39;: &#39;\\watt&#39;,
               &#39;C&#39;: &#39;\\coulomb&#39;,
               &#39;V&#39;: &#39;\\volt&#39;,
               &#39;F&#39;: &#39;\\farad&#39;,
               &#39;O&#39;: &#39;\\ohm&#39;,
               &#39;S&#39;: &#39;\\siemens&#39;,
               &#39;Wb&#39;: &#39;\\weber&#39;,
               &#39;T&#39;: &#39;\\tesla&#39;,
               &#39;H&#39;: &#39;\\henry&#39;,
               &#39;C&#39;: &#39;\\celsius&#39;,
               &#39;lm&#39;: &#39;\\lumen&#39;,
               &#39;lx&#39;: &#39;\\lux&#39;,
               &#39;Bq&#39;: &#39;\\becquerel&#39;,
               &#39;Gv&#39;: &#39;\\gray&#39;,
               &#39;Sv&#39;: &#39;\\sievert&#39;}
    other_units = {&#34;&#39;&#34;: &#39;\\arcminute&#39;,
               &#34;&#39;&#39;&#34;: &#39;\\arcsecond&#39;,
               &#39;a&#39;: &#39;\\are&#39;,
               &#39;d&#39;: &#39;\\dday&#39;,
               &#39;eV&#39;: &#39;\\electronvolt&#39;,
               &#39;ha&#39;: &#39;\\hectare&#39;,
               &#39;h&#39;: &#39;\\hour&#39;,
               &#39;L&#39;: &#39;\\liter&#39;,
               &#39;l&#39;: &#39;\\litre&#39;,
               &#39;min&#39;: &#39;\\minute&#39;,
               &#39;Np&#39;: &#39;\\neper&#39;,
               &#39;rad&#39;: &#39;\\rad&#39;,
               &#39;t&#39;: &#39;\\ton&#39;,
               &#39;%&#39;: &#39;\\%&#39;}
    unit_powers = {&#39;^2&#39;: &#39;\\squared&#39;,
              &#39;^3&#39;: &#39;\\cubed&#39;,
              &#39;/&#39;: &#39;\\per&#39;,
              &#39;^-1&#39;: &#39;\\power{}{-1}&#39;,
              &#39;^-2&#39;: &#39;\\rpsquared&#39;,
              &#39;^-3&#39;: &#39;\\rpcubed&#39;}
    if &#39;\\&#39; in unit:   # this string is already translated!
        return unit
    units = &#39;&#39;
    j = len(unit)
    while j &gt;= 0:
        for k in range(-3, 0):
            if j+k &lt; 0:
                continue
            uss = unit[j+k:j]
            if uss in unit_powers:
                units = unit_powers[uss] + units
                break
            elif uss in other_units:
                units = other_units[uss] + units
                break
            elif uss in si_units:
                units = si_units[uss] + units
                j = j+k
                k = 0
                if j-1 &gt;= 0:
                    uss = unit[j-1:j]
                    if uss in si_prefixes:
                        units = si_prefixes[uss] + units
                        k = -1
                break
        else:
            k = -1
            units = unit[j+k:j] + units
        j = j + k
    return units</code></pre>
</details>
</dd>
<dt id="thunderfish.tabledata.write"><code class="name flex">
<span>def <span class="ident">write</span></span>(<span>fh, data, header, units=None, formats=None, table_format=None, delimiter=None, unit_style=None, column_numbers=None, sections=None, align_columns=None, shrink_width=True, missing='-', center_columns=False, latex_label_command='', latex_merge_std=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Construct table and write to file.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>fh</code></strong> :&ensp;<code>filename</code> or <code>stream</code></dt>
<dd>If not a stream, the file with name <code>fh</code> is opened.
If <code>fh</code> does not have an extension,
the <code>table_format</code> is appended as an extension.
Otherwise <code>fh</code> is used as a stream for writing.</dd>
<dt><strong><code>data</code></strong> :&ensp;<code>1-D</code> or <code>2-D array</code> of <code>data</code></dt>
<dd>The data of the table.</dd>
<dt><strong><code>header</code></strong> :&ensp;<code>list</code> of <code>string</code></dt>
<dd>Header labels for each column.</dd>
<dt><strong><code>units</code></strong> :&ensp;<code>list</code> of <code>string</code>, optional</dt>
<dd>Unit strings for each column.</dd>
<dt><strong><code>formats</code></strong> :&ensp;<code>string</code> or <code>list</code> of <code>string</code>, optional</dt>
<dd>Format strings for each column. If only a single format string is
given, then all columns are initialized with this format string.</dd>
</dl>
<p>See <code><a title="thunderfish.tabledata.TableData.write" href="#thunderfish.tabledata.TableData.write">TableData.write()</a></code> for a description of all other parameters.</p>
<h2 id="example">Example</h2>
<pre><code>write(sys.stdout, np.random.randn(4,3), ['aaa', 'bbb', 'ccc'], units=['m', 's', 'g'], formats='%.2f')
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def write(fh, data, header, units=None, formats=None, table_format=None, delimiter=None,
              unit_style=None, column_numbers=None, sections=None,
              align_columns=None, shrink_width=True, missing=&#39;-&#39;,
              center_columns=False, latex_label_command=&#39;&#39;, latex_merge_std=False):
    &#34;&#34;&#34;Construct table and write to file.

    Parameters
    ----------
    fh: filename or stream
        If not a stream, the file with name `fh` is opened.
        If `fh` does not have an extension,
        the `table_format` is appended as an extension.
        Otherwise `fh` is used as a stream for writing.
    data: 1-D or 2-D array of data
          The data of the table.
    header: list of string
        Header labels for each column.
    units: list of string, optional
        Unit strings for each column.
    formats: string or list of string, optional
        Format strings for each column. If only a single format string is
        given, then all columns are initialized with this format string.

    See `TableData.write()` for a description of all other parameters.

    Example
    -------
    ```
    write(sys.stdout, np.random.randn(4,3), [&#39;aaa&#39;, &#39;bbb&#39;, &#39;ccc&#39;], units=[&#39;m&#39;, &#39;s&#39;, &#39;g&#39;], formats=&#39;%.2f&#39;)
    ```
    &#34;&#34;&#34;
    td = TableData(data, header, units, formats)
    td.write(fh, table_format=table_format, unit_style=unit_style,
             column_numbers=column_numbers, missing=missing, shrink_width=shrink_width,
             delimiter=delimiter, align_columns=align_columns, sections=sections,
             latex_label_command=latex_label_command, latex_merge_std=latex_merge_std)</code></pre>
</details>
</dd>
<dt id="thunderfish.tabledata.write_table_args"><code class="name flex">
<span>def <span class="ident">write_table_args</span></span>(<span>cfg)</span>
</code></dt>
<dd>
<div class="desc"><p>Translates a configuration to the respective parameter names for
writing a table to a file.</p>
<pre><code>The return value can then be passed as key-word arguments to TableData.write().

Parameters
----------
cfg: ConfigFile
    The configuration.

Returns
-------
a: dict
    Dictionary with names of arguments of the &lt;code&gt;&lt;a title="thunderfish.tabledata.TableData.write" href="#thunderfish.tabledata.TableData.write"&gt;TableData.write()&lt;/a&gt;&lt;/code&gt; function
    and their values as supplied by &lt;code&gt;cfg&lt;/code&gt;.
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def write_table_args(cfg):
    &#34;&#34;&#34;Translates a configuration to the respective parameter names for
writing a table to a file.
    
    The return value can then be passed as key-word arguments to TableData.write().

    Parameters
    ----------
    cfg: ConfigFile
        The configuration.

    Returns
    -------
    a: dict
        Dictionary with names of arguments of the `TableData.write` function
        and their values as supplied by `cfg`.
    &#34;&#34;&#34;
    d = cfg.map({&#39;table_format&#39;: &#39;fileFormat&#39;,
                 &#39;delimiter&#39;: &#39;fileDelimiter&#39;,
                 &#39;unit_style&#39;: &#39;fileUnitStyle&#39;,
                 &#39;column_numbers&#39;: &#39;fileColumnNumbers&#39;,
                 &#39;sections&#39;: &#39;fileSections&#39;,
                 &#39;align_columns&#39;: &#39;fileAlignColumns&#39;,
                 &#39;shrink_width&#39;: &#39;fileShrinkColumnWidth&#39;,
                 &#39;missing&#39;: &#39;fileMissing&#39;,
                 &#39;center_columns&#39;: &#39;fileCenterColumns&#39;,
                 &#39;latex_label_command&#39;: &#39;fileLaTeXLabelCommand&#39;,
                 &#39;latex_merge_std&#39;: &#39;fileLaTeXMergeStd&#39;})
    if &#39;sections&#39; in d:
        if d[&#39;sections&#39;] != &#39;auto&#39;:
            d[&#39;sections&#39;] = int(d[&#39;sections&#39;])
    return d</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="thunderfish.tabledata.IndentStream"><code class="flex name class">
<span>class <span class="ident">IndentStream</span></span>
<span>(</span><span>stream, indent=4)</span>
</code></dt>
<dd>
<div class="desc"><p>Filter an output stream and start each newline with a number of
spaces.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class IndentStream(object):
    &#34;&#34;&#34;Filter an output stream and start each newline with a number of
    spaces.
    &#34;&#34;&#34;
    def __init__(self, stream, indent=4):
        self.stream = stream
        self.indent = indent
        self.pending = True

    def __getattr__(self, attr_name):
        return getattr(self.stream, attr_name)

    def write(self, data):
        if not data:
            return
        if self.pending:
            self.stream.write(&#39; &#39;*self.indent)
            self.pending = False
        substr = data.rstrip(&#39;\n&#39;)
        rn = len(data) - len(substr)
        if len(substr) &gt; 0:
            self.stream.write(substr.replace(&#39;\n&#39;, &#39;\n&#39;+&#39; &#39;*self.indent))
        if rn &gt; 0:
            self.stream.write(&#39;\n&#39;*rn)
            self.pending = True

    def flush(self):
        self.stream.flush()</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="thunderfish.tabledata.IndentStream.flush"><code class="name flex">
<span>def <span class="ident">flush</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def flush(self):
    self.stream.flush()</code></pre>
</details>
</dd>
<dt id="thunderfish.tabledata.IndentStream.write"><code class="name flex">
<span>def <span class="ident">write</span></span>(<span>self, data)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def write(self, data):
    if not data:
        return
    if self.pending:
        self.stream.write(&#39; &#39;*self.indent)
        self.pending = False
    substr = data.rstrip(&#39;\n&#39;)
    rn = len(data) - len(substr)
    if len(substr) &gt; 0:
        self.stream.write(substr.replace(&#39;\n&#39;, &#39;\n&#39;+&#39; &#39;*self.indent))
    if rn &gt; 0:
        self.stream.write(&#39;\n&#39;*rn)
        self.pending = True</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="thunderfish.tabledata.TableData"><code class="flex name class">
<span>class <span class="ident">TableData</span></span>
<span>(</span><span>data=None, header=None, units=None, formats=None, missing='-')</span>
</code></dt>
<dd>
<div class="desc"><p>Table with numpy-style indexing and a rich hierarchical header including units and formats.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>data</code></strong> :&ensp;<code>string, stream, array</code></dt>
<dd>
<ul>
<li>a filename: load table from file with name <code>data</code>.</li>
<li>a stream/file handle: load table from that stream.</li>
<li>1-D or 2-D array of data: the data of the table.
Requires als a specified <code>header</code>.</li>
</ul>
</dd>
<dt><strong><code>header</code></strong> :&ensp;<code>list</code> of <code>string</code></dt>
<dd>Header labels for each column.</dd>
<dt><strong><code>units</code></strong> :&ensp;<code>list</code> of <code>string</code>, optional</dt>
<dd>Unit strings for each column.</dd>
<dt><strong><code>formats</code></strong> :&ensp;<code>string</code> or <code>list</code> of <code>string</code>, optional</dt>
<dd>Format strings for each column. If only a single format string is
given, then all columns are initialized with this format string.</dd>
<dt><strong><code>missing</code></strong> :&ensp;<code>string</code></dt>
<dd>Missing data are indicated by this string.</dd>
</dl>
<h2 id="manipulate-table-header">Manipulate Table Header</h2>
<p>Each column of the table has a label (the name of the column), a
unit, and a format specifier. Sections group columns into a hierarchy.</p>
<ul>
<li><code>__init__()</code>: initialize a TableData from data or a file.</li>
<li><code>append()</code>: append column to the table.</li>
<li><code>insert()</code>: insert a table column at a given position.</li>
<li><code>remove()</code>: remove columns from the table.</li>
<li><code>section()</code>: the section name of a specified column.</li>
<li><code>set_section()</code>: set a section name.</li>
<li><code>append_section()</code>: add sections to the table header.</li>
<li><code>insert_section()</code>: insert a section at a given position of the table header.</li>
<li><code>label()</code>: the name of a column.</li>
<li><code>set_label()</code>: set the name of a column.</li>
<li><code>unit()</code>: the unit of a column.</li>
<li><code>set_unit()</code>: set the unit of a column.</li>
<li><code>set_units()</code>: set the units of all columns.</li>
<li><code>format()</code>: the format string of the column.</li>
<li><code>set_format()</code>: set the format string of a column.</li>
<li><code>set_formats()</code>: set the format strings of all columns.</li>
</ul>
<p>For example:</p>
<pre><code>tf = TableData('data.csv')
</code></pre>
<p>loads a table directly from a file. See <code>load()</code> for details.</p>
<pre><code>tf = TableData(np.random.randn(4,3), header=['aaa', 'bbb', 'ccc'], units=['m', 's', 'g'], formats='%.2f')    
</code></pre>
<p>results in</p>
<pre><code class="language-plain">aaa    bbb    ccc
m      s      g    
 1.45   0.01   0.16
-0.74  -0.58  -1.34
-2.06   0.08   1.47
-0.43   0.60   1.38
</code></pre>
<p>A more elaborate way to construct a table is:</p>
<pre><code>df = TableData()
# first column with section names and 3 data values:
df.append([&quot;data&quot;, &quot;partial information&quot;, &quot;size&quot;], &quot;m&quot;, &quot;%6.2f&quot;,
          [2.34, 56.7, 8.9])
# next columns with single data values:
df.append(&quot;full weight&quot;, &quot;kg&quot;, &quot;%.0f&quot;, 122.8)
df.append_section(&quot;complete reaction&quot;)
df.append(&quot;speed&quot;, &quot;m/s&quot;, &quot;%.3g&quot;, 98.7)
df.append(&quot;median jitter&quot;, &quot;mm&quot;, &quot;%.1f&quot;, 23)
df.append(&quot;size&quot;, &quot;g&quot;, &quot;%.2e&quot;, 1.234)
# add a missing value to the second column:
df.append_data(np.nan, 1)
# fill up the remaining columns of the row:
df.append_data((0.543, 45, 1.235e2))
# append data to the next row starting at the second column:
df.append_data((43.21, 6789.1, 3405, 1.235e-4), 1) # next row
</code></pre>
<p>results in</p>
<pre><code class="language-plain">data
partial information  complete reaction
size    full weight  speed     median jitter  size
m       kg           m/s       mm             g       
  2.34          123      98.7           23.0  1.23e+00
 56.70            -     0.543           45.0  1.24e+02
  8.90           43  6.79e+03         3405.0  1.23e-04
</code></pre>
<h2 id="table-columns">Table Columns</h2>
<p>Columns can be specified by an index or by the name of a column. In
table headers with sections the colum can be specified by the
section names and the column name separated by '&gt;'.</p>
<ul>
<li><code>index()</code>: the index of a column.</li>
<li><code>__contains__()</code>: check for existence of a column.</li>
<li><code>find_col()</code>: find the start and end index of a column specification.</li>
<li><code>column_spec()</code>: full specification of a column with all its section names.</li>
<li><code>column_head()</code>: the name, unit, and format of a column.</li>
<li><code>table_header()</code>: the header of the table without content.</li>
</ul>
<p>For example:</p>
<pre><code>df.index('complete reaction&gt;size)   # returns 4
'speed' in df                       # is True
</code></pre>
<h2 id="iterating-over-columns">Iterating Over Columns</h2>
<p>A table behaves like an ordered dictionary with column names as
keys and the data of each column as values.
Iterating over a table goes over columns.</p>
<ul>
<li><code>keys()</code>: list of unique column keys for all available columns.</li>
<li><code>values()</code>: list of column data corresponding to keys().</li>
<li><code>items()</code>: list of tuples with unique column specifications and the corresponding data.</li>
<li><code>__len__()</code>: the number of columns.</li>
<li><code>__iter__()</code>: initialize iteration over data columns.</li>
<li><code>__next__()</code>: return data of next column as a list.</li>
<li><code>data</code>: the table data as a list over columns each containing a list of data elements.</li>
</ul>
<p>For example:</p>
<pre><code>print('column specifications:')
for c in range(df.columns()):
    print(df.column_spec(c))
print('keys():')
for c, k in enumerate(df.keys()):
    print('%d: %s' % (c, k))
print('values():')
for c, v in enumerate(df.values()):
    print(v)
print('iterating over the table:')
for v in df:
    print(v)
</code></pre>
<p>results in</p>
<pre><code class="language-plain">column specifications:
data&gt;partial information&gt;size
data&gt;partial information&gt;full weight
data&gt;complete reaction&gt;speed
data&gt;complete reaction&gt;median jitter
data&gt;complete reaction&gt;size
keys():
0: data&gt;partial information&gt;size
1: data&gt;partial information&gt;full weight
2: data&gt;complete reaction&gt;speed
3: data&gt;complete reaction&gt;median jitter
4: data&gt;complete reaction&gt;size
values():
[2.34, 56.7, 8.9]
[122.8, nan, 43.21]
[98.7, 0.543, 6789.1]
[23, 45, 3405]
[1.234, 123.5, 0.0001235]
iterating over the table:
[2.34, 56.7, 8.9]
[122.8, nan, 43.21]
[98.7, 0.543, 6789.1]
[23, 45, 3405]
[1.234, 123.5, 0.0001235]
</code></pre>
<h2 id="accessing-data">Accessing Data</h2>
<p>In contrast to the iterator functions the [] operator treats the table as a
2D-array where the first index indicates the row and the second index the column.</p>
<p>Like a numpy aray the table can be sliced, and logical indexing can
be used to select specific parts of the table.</p>
<p>As for any function, columns can be specified as indices or strings.</p>
<ul>
<li><code>rows()</code>: the number of rows.</li>
<li><code>columns()</code>: the number of columns.</li>
<li><code>shape</code>: number of rows and columns.</li>
<li><code>row()</code>: a single row of the table as TableData.</li>
<li><code>row_dict()</code>: a single row of the table as dictionary.</li>
<li><code>col()</code>: a single column of the table as TableData.</li>
<li><code>__call__()</code>: a single column of the table as numpy array.</li>
<li><code>__getitem__()</code>: data elements specified by slice.</li>
<li><code>__setitem__()</code>: assign values to data elements specified by slice.</li>
<li><code>__delitem__()</code>: delete data elements or whole columns or rows.</li>
<li><code>array()</code>: the table data as a numpy array.</li>
<li><code>data_frame()</code>: the table data as a pandas DataFrame.</li>
<li><code>dicts()</code>: the table as a list of dictionaries.</li>
<li><code>dict()</code>: the table as a dictionary.</li>
<li><code>append_data()</code>: append data elements to successive columns.</li>
<li><code>append_data_column()</code>: append data elements to a column.</li>
<li><code>set_column()</code>: set the column where to add data.</li>
<li><code>fill_data()</code>: fill up all columns with missing data.</li>
<li><code>clear_data()</code>: clear content of the table but keep header.</li>
<li>
<p><code>key_value()</code>: a data element returned as a key-value pair.</p>
</li>
<li>
<p><code>sort()</code>: sort the table rows in place.</p>
</li>
<li><code>statistics()</code>: descriptive statistics of each column.</li>
</ul>
<p>For example:</p>
<pre><code># single column:    
df('size')     # data of 'size' column as numpy array
df[:,'size']   # data of 'size' column as numpy array
df.col('size') # table with the single column 'size'

# single row:    
df[2,:]    # table with data of only the third row
df.row(2)  # table with data of only the third row

# slices:
df[2:5,['size','jitter']]          # sub-table
df[2:5,['size','jitter']].array()  # numpy array with data only

# logical indexing:
df[df('speed') &gt; 100.0, 'size'] = 0.0 # set size to 0 if speed is &gt; 100

# delete:
del df[3:6, 'weight']  # delete rows 3-6 from column 'weight'
del df[3:5,:]          # delete rows 3-5 completeley
del df[:,'speed']      # remove column 'speed' from table
df.remove('weight')    # remove column 'weigth' from table

# sort and statistics:
df.sort(['weight', 'jitter'])
df.statistics()
</code></pre>
<p>statistics() returns a table with standard descriptive statistics:</p>
<pre><code class="language-plain">statistics  data
-           partial information  complete reaction
-           size    full weight  speed     median jitter  size
-           m       kg           m/s       mm             g       
mean         22.65           83   2.3e+03         1157.7  4.16e+01
std          24.23           40  3.18e+03         1589.1  5.79e+01
min           2.34           43     0.543           23.0  1.23e-04
quartile1     5.62           83      49.6           34.0  6.17e-01
median        8.90          123      98.7           45.0  1.23e+00
quartile3    32.80            -  3.44e+03         1725.0  6.24e+01
max          56.70          123  6.79e+03         3405.0  1.24e+02
count         3.00            2         3            3.0  3.00e+00
</code></pre>
<h2 id="write-and-load-tables">Write And Load Tables</h2>
<p>Table data can be written to a variety of text-based formats
including comma separated values, latex and html files.
Which
columns are written can be controlled by the hide() and show()
functions. TableData can be loaded from all the written file formats
(except html), also directly via the constructor.</p>
<ul>
<li><code>hide()</code>: hide a column or a range of columns.</li>
<li><code>hide_all()</code>: hide all columns.</li>
<li><code>hide_empty_columns()</code>: hide all columns that do not contain data.</li>
<li><code>show()</code>: show a column or a range of columns.</li>
<li><code><a title="thunderfish.tabledata.write" href="#thunderfish.tabledata.write">write()</a></code>: write the table to a file or stream.</li>
<li><code>__str__()</code>: write table to a string.</li>
<li><code>load()</code>: load table from file or stream.</li>
<li><code>formats</code>: list of supported file formats for writing.</li>
<li><code>descriptions</code>: dictionary with descriptions of the supported file formats.</li>
<li><code>extensions</code>: dictionary with default filename extensions for each of the file formats.</li>
<li><code>ext_formats</code>: dictionary mapping filename extensions to file formats.</li>
</ul>
<p>See documentation of the <code><a title="thunderfish.tabledata.write" href="#thunderfish.tabledata.write">write()</a></code> function for examples of the supported file formats.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class TableData(object):
    &#34;&#34;&#34;Table with numpy-style indexing and a rich hierarchical header including units and formats.
    
    Parameters
    ----------
    data: string, stream, array
        - a filename: load table from file with name `data`.
        - a stream/file handle: load table from that stream.
        - 1-D or 2-D array of data: the data of the table.
          Requires als a specified `header`.
    header: list of string
        Header labels for each column.
    units: list of string, optional
        Unit strings for each column.
    formats: string or list of string, optional
        Format strings for each column. If only a single format string is
        given, then all columns are initialized with this format string.
    missing: string
        Missing data are indicated by this string.

    Manipulate table header
    -----------------------

    Each column of the table has a label (the name of the column), a
    unit, and a format specifier. Sections group columns into a hierarchy.

    - `__init__()`: initialize a TableData from data or a file.
    - `append()`: append column to the table.
    - `insert()`: insert a table column at a given position.
    - `remove()`: remove columns from the table.
    - `section()`: the section name of a specified column.
    - `set_section()`: set a section name.
    - `append_section()`: add sections to the table header.
    - `insert_section()`: insert a section at a given position of the table header.
    - `label()`: the name of a column.
    - `set_label()`: set the name of a column.
    - `unit()`: the unit of a column.
    - `set_unit()`: set the unit of a column.
    - `set_units()`: set the units of all columns.
    - `format()`: the format string of the column.
    - `set_format()`: set the format string of a column.
    - `set_formats()`: set the format strings of all columns.

    For example:
    ```
    tf = TableData(&#39;data.csv&#39;)
    ```
    loads a table directly from a file. See `load()` for details.
    ```
    tf = TableData(np.random.randn(4,3), header=[&#39;aaa&#39;, &#39;bbb&#39;, &#39;ccc&#39;], units=[&#39;m&#39;, &#39;s&#39;, &#39;g&#39;], formats=&#39;%.2f&#39;)    
    ```
    results in
    ``` plain
    aaa    bbb    ccc
    m      s      g    
     1.45   0.01   0.16
    -0.74  -0.58  -1.34
    -2.06   0.08   1.47
    -0.43   0.60   1.38
    ```

    A more elaborate way to construct a table is:
    ```
    df = TableData()
    # first column with section names and 3 data values:
    df.append([&#34;data&#34;, &#34;partial information&#34;, &#34;size&#34;], &#34;m&#34;, &#34;%6.2f&#34;,
              [2.34, 56.7, 8.9])
    # next columns with single data values:
    df.append(&#34;full weight&#34;, &#34;kg&#34;, &#34;%.0f&#34;, 122.8)
    df.append_section(&#34;complete reaction&#34;)
    df.append(&#34;speed&#34;, &#34;m/s&#34;, &#34;%.3g&#34;, 98.7)
    df.append(&#34;median jitter&#34;, &#34;mm&#34;, &#34;%.1f&#34;, 23)
    df.append(&#34;size&#34;, &#34;g&#34;, &#34;%.2e&#34;, 1.234)
    # add a missing value to the second column:
    df.append_data(np.nan, 1)
    # fill up the remaining columns of the row:
    df.append_data((0.543, 45, 1.235e2))
    # append data to the next row starting at the second column:
    df.append_data((43.21, 6789.1, 3405, 1.235e-4), 1) # next row
    ```
    results in
    ``` plain
    data
    partial information  complete reaction
    size    full weight  speed     median jitter  size
    m       kg           m/s       mm             g       
      2.34          123      98.7           23.0  1.23e+00
     56.70            -     0.543           45.0  1.24e+02
      8.90           43  6.79e+03         3405.0  1.23e-04
    ```
    
    Table columns
    -------------

    Columns can be specified by an index or by the name of a column. In
    table headers with sections the colum can be specified by the
    section names and the column name separated by &#39;&gt;&#39;.
    
    - `index()`: the index of a column.
    - `__contains__()`: check for existence of a column.
    - `find_col()`: find the start and end index of a column specification.
    - `column_spec()`: full specification of a column with all its section names.
    - `column_head()`: the name, unit, and format of a column.
    - `table_header()`: the header of the table without content.

    For example:
    ```
    df.index(&#39;complete reaction&gt;size)   # returns 4
    &#39;speed&#39; in df                       # is True
    ```

    Iterating over columns
    ----------------------

    A table behaves like an ordered dictionary with column names as
    keys and the data of each column as values.
    Iterating over a table goes over columns.
    
    - `keys()`: list of unique column keys for all available columns.
    - `values()`: list of column data corresponding to keys().
    - `items()`: list of tuples with unique column specifications and the corresponding data.
    - `__len__()`: the number of columns.
    - `__iter__()`: initialize iteration over data columns.
    - `__next__()`: return data of next column as a list.
    - `data`: the table data as a list over columns each containing a list of data elements.

    For example:
    ```
    print(&#39;column specifications:&#39;)
    for c in range(df.columns()):
        print(df.column_spec(c))
    print(&#39;keys():&#39;)
    for c, k in enumerate(df.keys()):
        print(&#39;%d: %s&#39; % (c, k))
    print(&#39;values():&#39;)
    for c, v in enumerate(df.values()):
        print(v)
    print(&#39;iterating over the table:&#39;)
    for v in df:
        print(v)
    ```
    results in
    ``` plain
    column specifications:
    data&gt;partial information&gt;size
    data&gt;partial information&gt;full weight
    data&gt;complete reaction&gt;speed
    data&gt;complete reaction&gt;median jitter
    data&gt;complete reaction&gt;size
    keys():
    0: data&gt;partial information&gt;size
    1: data&gt;partial information&gt;full weight
    2: data&gt;complete reaction&gt;speed
    3: data&gt;complete reaction&gt;median jitter
    4: data&gt;complete reaction&gt;size
    values():
    [2.34, 56.7, 8.9]
    [122.8, nan, 43.21]
    [98.7, 0.543, 6789.1]
    [23, 45, 3405]
    [1.234, 123.5, 0.0001235]
    iterating over the table:
    [2.34, 56.7, 8.9]
    [122.8, nan, 43.21]
    [98.7, 0.543, 6789.1]
    [23, 45, 3405]
    [1.234, 123.5, 0.0001235]
    ```

    Accessing data
    --------------

    In contrast to the iterator functions the [] operator treats the table as a
    2D-array where the first index indicates the row and the second index the column.

    Like a numpy aray the table can be sliced, and logical indexing can
    be used to select specific parts of the table.
    
    As for any function, columns can be specified as indices or strings.
    
    - `rows()`: the number of rows.
    - `columns()`: the number of columns.
    - `shape`: number of rows and columns.
    - `row()`: a single row of the table as TableData.
    - `row_dict()`: a single row of the table as dictionary.
    - `col()`: a single column of the table as TableData.
    - `__call__()`: a single column of the table as numpy array.
    - `__getitem__()`: data elements specified by slice.
    - `__setitem__()`: assign values to data elements specified by slice.
    - `__delitem__()`: delete data elements or whole columns or rows.
    - `array()`: the table data as a numpy array.
    - `data_frame()`: the table data as a pandas DataFrame.
    - `dicts()`: the table as a list of dictionaries.
    - `dict()`: the table as a dictionary.
    - `append_data()`: append data elements to successive columns.
    - `append_data_column()`: append data elements to a column.
    - `set_column()`: set the column where to add data.
    - `fill_data()`: fill up all columns with missing data.
    - `clear_data()`: clear content of the table but keep header.
    - `key_value()`: a data element returned as a key-value pair.
    
    - `sort()`: sort the table rows in place.
    - `statistics()`: descriptive statistics of each column.

    For example:
    ```
    # single column:    
    df(&#39;size&#39;)     # data of &#39;size&#39; column as numpy array
    df[:,&#39;size&#39;]   # data of &#39;size&#39; column as numpy array
    df.col(&#39;size&#39;) # table with the single column &#39;size&#39;

    # single row:    
    df[2,:]    # table with data of only the third row
    df.row(2)  # table with data of only the third row

    # slices:
    df[2:5,[&#39;size&#39;,&#39;jitter&#39;]]          # sub-table
    df[2:5,[&#39;size&#39;,&#39;jitter&#39;]].array()  # numpy array with data only

    # logical indexing:
    df[df(&#39;speed&#39;) &gt; 100.0, &#39;size&#39;] = 0.0 # set size to 0 if speed is &gt; 100

    # delete:
    del df[3:6, &#39;weight&#39;]  # delete rows 3-6 from column &#39;weight&#39;
    del df[3:5,:]          # delete rows 3-5 completeley
    del df[:,&#39;speed&#39;]      # remove column &#39;speed&#39; from table
    df.remove(&#39;weight&#39;)    # remove column &#39;weigth&#39; from table

    # sort and statistics:
    df.sort([&#39;weight&#39;, &#39;jitter&#39;])
    df.statistics()
    ```
    statistics() returns a table with standard descriptive statistics:
    ``` plain
    statistics  data
    -           partial information  complete reaction
    -           size    full weight  speed     median jitter  size
    -           m       kg           m/s       mm             g       
    mean         22.65           83   2.3e+03         1157.7  4.16e+01
    std          24.23           40  3.18e+03         1589.1  5.79e+01
    min           2.34           43     0.543           23.0  1.23e-04
    quartile1     5.62           83      49.6           34.0  6.17e-01
    median        8.90          123      98.7           45.0  1.23e+00
    quartile3    32.80            -  3.44e+03         1725.0  6.24e+01
    max          56.70          123  6.79e+03         3405.0  1.24e+02
    count         3.00            2         3            3.0  3.00e+00
    ```

    Write and load tables
    ---------------------

    Table data can be written to a variety of text-based formats
    including comma separated values, latex and html files.  Which
    columns are written can be controlled by the hide() and show()
    functions. TableData can be loaded from all the written file formats
    (except html), also directly via the constructor.
    
    - `hide()`: hide a column or a range of columns.
    - `hide_all()`: hide all columns.
    - `hide_empty_columns()`: hide all columns that do not contain data.
    - `show()`: show a column or a range of columns.
    - `write()`: write the table to a file or stream.
    - `__str__()`: write table to a string.
    - `load()`: load table from file or stream.
    - `formats`: list of supported file formats for writing.
    - `descriptions`: dictionary with descriptions of the supported file formats.
    - `extensions`: dictionary with default filename extensions for each of the file formats.
    - `ext_formats`: dictionary mapping filename extensions to file formats.

    See documentation of the `write()` function for examples of the supported file formats.
    &#34;&#34;&#34;
    
    formats = [&#39;dat&#39;, &#39;ascii&#39;, &#39;csv&#39;, &#39;rtai&#39;, &#39;md&#39;, &#39;tex&#39;, &#39;html&#39;]
    &#34;&#34;&#34;list of strings: Supported output formats.&#34;&#34;&#34;
    descriptions = {&#39;dat&#39;: &#39;data text file&#39;, &#39;ascii&#39;: &#39;ascii-art table&#39;,
                    &#39;csv&#39;: &#39;comma separated values&#39;, &#39;rtai&#39;: &#39;rtai-style table&#39;,
                    &#39;md&#39;: &#39;markdown&#39;, &#39;tex&#39;: &#39;latex tabular&#39;,
                    &#39;html&#39;: &#39;html markup&#39;}
    &#34;&#34;&#34;dict: Decription of output formats corresponding to `formats`.&#34;&#34;&#34;
    extensions = {&#39;dat&#39;: &#39;dat&#39;, &#39;ascii&#39;: &#39;txt&#39;, &#39;csv&#39;: &#39;csv&#39;, &#39;rtai&#39;: &#39;dat&#39;,
                  &#39;md&#39;: &#39;md&#39;, &#39;tex&#39;: &#39;tex&#39;, &#39;html&#39;: &#39;html&#39;}
    &#34;&#34;&#34;dict: Default file extensions for the output `formats`. &#34;&#34;&#34;
    ext_formats = {&#39;dat&#39;: &#39;dat&#39;, &#39;DAT&#39;: &#39;dat&#39;, &#39;txt&#39;: &#39;dat&#39;, &#39;TXT&#39;: &#39;dat&#39;,
                   &#39;csv&#39;: &#39;csv&#39;, &#39;CSV&#39;: &#39;csv&#39;, &#39;md&#39;: &#39;md&#39;, &#39;MD&#39;: &#39;md&#39;,
                   &#39;tex&#39;: &#39;tex&#39;, &#39;TEX&#39;: &#39;tex&#39;, &#39;html&#39;: &#39;html&#39;, &#39;HTML&#39;: &#39;html&#39;}
    &#34;&#34;&#34;dict: Mapping of file extensions to the output formats.&#34;&#34;&#34;

    def __init__(self, data=None, header=None, units=None, formats=None,
                 missing=&#39;-&#39;):
        self.data = []
        self.shape = (0, 0)
        self.header = []
        self.nsecs = 0
        self.units = []
        self.formats = []
        self.hidden = []
        self.setcol = 0
        self.addcol = 0
        if header is not None:
            if units is None:
                units = [&#39;&#39;]*len(header)
            if formats is None:
                formats = [&#39;%g&#39;]*len(header)
            elif not isinstance(formats, (list, tuple, np.ndarray)):
                formats = [formats]*len(header)
            for h, u, f in zip(header, units, formats):
                self.append(h, u, f)            
        if data is not None:
            if isinstance(data, TableData):
                self.shape = data.shape
                self.nsecs = data.nsecs
                self.setcol = data.setcol
                self.addcol = data.addcol
                for c in range(data.columns()):
                    self.header.append([])
                    for h in data.header[c]:
                        self.header[c].append(h)
                    self.units.append(data.units[c])
                    self.formats.append(data.formats[c])
                    self.hidden.append(data.hidden[c])
                    self.data.append([])
                    for d in data.data[c]:
                        self.data[c].append(d)
            elif isinstance(data, (list, tuple, np.ndarray)):
                if isinstance(data[0], (list, tuple, np.ndarray)):
                    # 2D list, rows first:
                    for row in data:
                        for c, val in enumerate(row):
                            self.data[c].append(val)
                else:
                    # 1D list:
                    for c, val in enumerate(data):
                        self.data[c].append(val)
            else:
                self.load(data, missing)
        
    def append(self, label, unit=None, formats=None, value=None, key=None, fac=None):
        &#34;&#34;&#34;Append column to the table.

        Parameters
        ----------
        label: string or list of string
            Optional section titles and the name of the column.
        unit: string or None
            The unit of the column contents.
        formats: string or None
            The C-style format string used for printing out the column content, e.g.
            &#39;%g&#39;, &#39;%.2f&#39;, &#39;%s&#39;, etc.
            If None, the format is set to &#39;%g&#39;.
        value: None, float, int, string, etc. or list thereof, or list of dict
            If not None, data for the column.
        key: None or key of a dictionary
            If not None and `value` is a list of dictionaries,
            extract from each dictionary in the list the value specified
            by `key` and assign the resulting list as data to the column.
        fac: float
            If not None, multiply the data values by this number.

        Returns
        -------
        index: int
            The index of the new column.
        &#34;&#34;&#34;
        if self.addcol &gt;= len(self.data):
            if isinstance(label, (list, tuple, np.ndarray)):
                self.header.append(list(reversed(label)))
            else:
                self.header.append([label])
            self.formats.append(formats or &#39;%g&#39;)
            self.units.append(unit or &#39;&#39;)
            self.hidden.append(False)
            self.data.append([])
            if self.nsecs &lt; len(self.header[-1])-1:
                self.nsecs = len(self.header[-1])-1
        else:
            if isinstance(label, (list, tuple, np.ndarray)):
                self.header[self.addcol] = list(reversed(label)) + self.header[self.addcol]
            else:
                self.header[self.addcol] = [label] + self.header[self.addcol]
            self.units[self.addcol] = unit or &#39;&#39;
            self.formats[self.addcol] = formats or &#39;%g&#39;
            if self.nsecs &lt; len(self.header[self.addcol])-1:
                self.nsecs = len(self.header[self.addcol])-1
        if value is not None:
            if isinstance(value, (list, tuple, np.ndarray)):
                if key and value and isinstance(value[0], dict):
                    value = [d[key] if key in d else float(&#39;nan&#39;) for d in value]
                self.data[-1].extend(value)
            else:
                self.data[-1].append(value)
        if fac:
            for k in range(len(self.data[-1])):
                self.data[-1][k] *= fac
        self.addcol = len(self.data)
        self.shape = (self.rows(), self.columns())
        return self.addcol-1
        
    def insert(self, column, label, unit=None, formats=None, value=None):
        &#34;&#34;&#34;Insert a table column at a given position.

        .. WARNING::
           If no `value` is given, the inserted column is an empty list.

        Parameters
        ----------
        columns int or string
            Column before which to insert the new column.
            Column can be specified by index or name,
            see `index()` for details.
        label: string or list of string
            Optional section titles and the name of the column.
        unit: string or None
            The unit of the column contents.
        formats: string or None
            The C-style format string used for printing out the column content, e.g.
            &#39;%g&#39;, &#39;%.2f&#39;, &#39;%s&#39;, etc.
            If None, the format is set to &#39;%g&#39;.
        value: None, float, int, string, etc. or list thereof
            If not None, data for the column.

        Returns
        -------
        index: int
            The index of the inserted column.
            
        Raises
        ------
        IndexError:
            If an invalid column was specified.
        &#34;&#34;&#34;
        col = self.index(column)
        if col is None:
            if isinstance(column, (int, np.integer)):
                column = &#39;%d&#39; % column
            raise IndexError(&#39;Cannot insert before non-existing column &#39; + column)
        if isinstance(label, (list, tuple, np.ndarray)):
            self.header.insert(col, list(reversed(label)))
        else:
            self.header.insert(col, [label])
        self.formats.insert(col, formats or &#39;%g&#39;)
        self.units.insert(col, unit or &#39;&#39;)
        self.hidden.insert(col, False)
        self.data.insert(col, [])
        if self.nsecs &lt; len(self.header[col])-1:
            self.nsecs = len(self.header[col])-1
        if value is not None:
            if isinstance(value, (list, tuple, np.ndarray)):
                self.data[col].extend(value)
            else:
                self.data[col].append(value)
        self.addcol = len(self.data)
        self.shape = (self.rows(), self.columns())
        return col

    def remove(self, columns):
        &#34;&#34;&#34;Remove columns from the table.

        Parameters
        -----------
        columns: int or string or list of int or string
            Columns can be specified by index or name,
            see `index()` for details.

        Raises
        ------
        IndexError:
            If an invalid column was specified.
        &#34;&#34;&#34;
        # fix columns:
        if not isinstance(columns, (list, tuple, np.ndarray)):
            columns = [ columns ]
        if not columns:
            return
        # remove:
        for col in columns:
            c = self.index(col)
            if c is None:
                if isinstance(col, (int, np.integer)):
                    col = &#39;%d&#39; % col
                raise IndexError(&#39;Cannot remove non-existing column &#39; + col)
                continue
            if c+1 &lt; len(self.header):
                self.header[c+1].extend(self.header[c][len(self.header[c+1]):])
            del self.header[c]
            del self.units[c]
            del self.formats[c]
            del self.hidden[c]
            del self.data[c]
        if self.setcol &gt; len(self.data):
            self.setcol = len(self.data)
        self.shape = (self.rows(), self.columns())

    def section(self, column, level):
        &#34;&#34;&#34;The section name of a specified column.

        Parameters
        ----------
        column: None, int, or string
            A specification of a column.
            See self.index() for more information on how to specify a column.
        level: int
            The level of the section to be returned. The column label itself is level=0.

        Returns
        -------
        name: string
            The name of the section at the specified level containing the column.
        index: int
            The column index that contains this section (equal or smaller thant `column`).

        Raises
        ------
        IndexError:
            If `level` exceeds the maximum possible level.
        &#34;&#34;&#34;
        if level &lt; 0 or level &gt; self.nsecs:
            raise IndexError(&#39;Invalid section level&#39;)
        column = self.index(column)
        while len(self.header[column]) &lt;= level:
            column -= 1
        return self.header[column][level], column
    
    def set_section(self, label, column, level):
        &#34;&#34;&#34;Set a section name.

        Parameters
        ----------
        label: string
            The new name to be used for the section.
        column: None, int, or string
            A specification of a column.
            See self.index() for more information on how to specify a column.
        level: int
            The level of the section to be set. The column label itself is level=0.
        &#34;&#34;&#34;
        column = self.index(column)
        self.header[column][level] = label
        return column

    def append_section(self, label):
        &#34;&#34;&#34;Add sections to the table header.

        Each column of the table has a header label. Columns can be
        grouped into sections. Sections can be nested arbitrarily.

        Parameters
        ----------
        label: string or list of string
            The name(s) of the section(s).

        Returns
        -------
        index: int
            The column index where the section was appended.
        &#34;&#34;&#34;
        if self.addcol &gt;= len(self.data):
            if isinstance(label, (list, tuple, np.ndarray)):
                self.header.append(list(reversed(label)))
            else:
                self.header.append([label])
            self.units.append(&#39;&#39;)
            self.formats.append(&#39;&#39;)
            self.hidden.append(False)
            self.data.append([])
        else:
            if isinstance(label, (list, tuple, np.ndarray)):
                self.header[self.addcol] = list(reversed(label)) + self.header[self.addcol]
            else:
                self.header[self.addcol] = [label] + self.header[self.addcol]
        if self.nsecs &lt; len(self.header[self.addcol]):
            self.nsecs = len(self.header[self.addcol])
        self.addcol = len(self.data)-1
        self.shape = (self.rows(), self.columns())
        return self.addcol
        
    def insert_section(self, column, section):
        &#34;&#34;&#34;Insert a section at a given position of the table header.

        Parameters
        ----------
        columns int or string
            Column before which to insert the new section.
            Column can be specified by index or name,
            see `index()` for details.
        section: string
            The name of the section.

        Returns
        -------
        index: int
            The index of the column where the section was inserted.
            
        Raises
        ------
        IndexError:
            If an invalid column was specified.
        &#34;&#34;&#34;
        col = self.index(column)
        if col is None:
            if isinstance(column, (int, np.integer)):
                column = &#39;%d&#39; % column
            raise IndexError(&#39;Cannot insert at non-existing column &#39; + column)
        self.header[col].append(section)
        if self.nsecs &lt; len(self.header[col])-1:
            self.nsecs = len(self.header[col])-1
        return col

    def label(self, column):
        &#34;&#34;&#34;The name of a column.

        Parameters
        ----------
        column: None, int, or string
            A specification of a column.
            See self.index() for more information on how to specify a column.

        Returns
        -------
        name: string
            The column label.
        &#34;&#34;&#34;
        column = self.index(column)
        return self.header[column][0]

    def set_label(self, label, column):
        &#34;&#34;&#34;Set the name of a column.

        Parameters
        ----------
        label: string
            The new name to be used for the column.
        column: None, int, or string
            A specification of a column.
            See self.index() for more information on how to specify a column.
        &#34;&#34;&#34;        
        column = self.index(column)
        self.header[column][0] = label
        return column

    def unit(self, column):
        &#34;&#34;&#34;The unit of a column.

        Parameters
        ----------
        column: None, int, or string
            A specification of a column.
            See self.index() for more information on how to specify a column.

        Returns
        -------
        unit: string
            The unit.
        &#34;&#34;&#34;
        column = self.index(column)
        return self.units[column]

    def set_unit(self, unit, column):
        &#34;&#34;&#34;Set the unit of a column.

        Parameters
        ----------
        unit: string
            The new unit to be used for the column.
        column: None, int, or string
            A specification of a column.
            See self.index() for more information on how to specify a column.
        &#34;&#34;&#34;
        column = self.index(column)
        self.units[column] = unit
        return column

    def set_units(self, units):
        &#34;&#34;&#34;Set the units of all columns.

        Parameters
        ----------
        units: list of string
            The new units to be used.
        &#34;&#34;&#34;
        for c, u in enumerate(units):
            self.units[c] = u

    def format(self, column):
        &#34;&#34;&#34;The format string of the column.

        Parameters
        ----------
        column: None, int, or string
            A specification of a column.
            See self.index() for more information on how to specify a column.

        Returns
        -------
        format: string
            The format string.
        &#34;&#34;&#34;
        column = self.index(column)
        return self.formats[column]

    def set_format(self, format, column):
        &#34;&#34;&#34;Set the format string of a column.

        Parameters
        ----------
        format: string
            The new format string to be used for the column.
        column: None, int, or string
            A specification of a column.
            See self.index() for more information on how to specify a column.
        &#34;&#34;&#34;
        column = self.index(column)
        self.formats[column] = format
        return column

    def set_formats(self, formats):
        &#34;&#34;&#34;Set the format strings of all columns.

        Parameters
        ----------
        formats: string or list of string
            The new format strings to be used.
            If only a single format is specified,
            then all columns get the same format.
        &#34;&#34;&#34;
        if isinstance(formats, (list, tuple, np.ndarray)):
            for c, f in enumerate(formats):
                self.formats[c] = f or &#39;%g&#39;
        else:
            for c in range(len(self.formats)):
                self.formats[c] = formats or &#39;%g&#39;

    def table_header(self):
        &#34;&#34;&#34;The header of the table without content.

        Returns
        -------
        data: TableData
            A TableData object with the same header but empty data.
        &#34;&#34;&#34;
        data = TableData()
        sec_indices = [-1] * self.nsecs
        for c in range(self.columns()):
            data.append(*self.column_head(c))
            for l in range(self.nsecs):
                s, i = self.section(c, l+1)
                if i != sec_indices[l]:
                    data.header[-1].append(s)
                    sec_indices[l] = i
        data.nsecs = self.nsecs
        return data

    def column_head(self, column):
        &#34;&#34;&#34;The name, unit, and format of a column.

        Parameters
        ----------
        column: None, int, or string
            A specification of a column.
            See self.index() for more information on how to specify a column.

        Returns
        -------
        name: string
            The column label.
        unit: string
            The unit.
        format: string
            The format string.
        &#34;&#34;&#34;
        column = self.index(column)
        return self.header[column][0], self.units[column], self.formats[column]

    def column_spec(self, column):
        &#34;&#34;&#34;Full specification of a column with all its section names.

        Parameters
        ----------
        column: int or string
            Specifies the column.
            See self.index() for more information on how to specify a column.

        Returns
        -------
        s: string
            Full specification of the column by all its section names and its header name.
        &#34;&#34;&#34;
        c = self.index(column)
        fh = [self.header[c][0]]
        for l in range(self.nsecs):
            fh.append(self.section(c, l+1)[0])
        return &#39;&gt;&#39;.join(reversed(fh))
    
    def find_col(self, column):
        &#34;&#34;&#34;Find the start and end index of a column specification.
        
        Parameters
        ----------
        column: None, int, or string
            A specification of a column.
            See self.index() for more information on how to specify a column.

        Returns
        -------
        c0: int or None
            A valid column index or None that is specified by `column`.
        c1: int or None
            A valid column index or None of the column following the range specified
            by `column`.
        &#34;&#34;&#34;

        def find_column_indices(ss, si, minns, maxns, c0, strict=True):
            if si &gt;= len(ss):
                return None, None, None, None
            ns0 = 0
            for ns in range(minns, maxns+1):
                nsec = maxns-ns
                if ss[si] == &#39;&#39;:
                    si += 1
                    continue
                for c in range(c0, len(self.header)):
                    if nsec &lt; len(self.header[c]) and \
                        ( ( strict and self.header[c][nsec] == ss[si] ) or
                          ( not strict and ss[si] in self.header[c][nsec] ) ):
                        ns0 = ns
                        c0 = c
                        si += 1
                        if si &gt;= len(ss):
                            c1 = len(self.header)
                            for c in range(c0+1, len(self.header)):
                                if nsec &lt; len(self.header[c]):
                                    c1 = c
                                    break
                            return c0, c1, ns0, None
                        elif nsec &gt; 0:
                            break
            return None, c0, ns0, si

        if column is None:
            return None, None
        if not isinstance(column, (int, np.integer)) and column.isdigit():
            column = int(column)
        if isinstance(column, (int, np.integer)):
            if column &gt;= 0 and column &lt; len(self.header):
                return column, column+1
            else:
                return None, None
        # find column by header:
        ss = column.rstrip(&#39;&gt;&#39;).split(&#39;&gt;&#39;)
        maxns = self.nsecs
        si0 = 0
        while si0 &lt; len(ss) and ss[si0] == &#39;&#39;:
            maxns -= 1
            si0 += 1
        if maxns &lt; 0:
            maxns = 0
        c0, c1, ns, si = find_column_indices(ss, si0, 0, maxns, 0, True)
        if c0 is None and c1 is not None:
            c0, c1, ns, si = find_column_indices(ss, si, ns, maxns, c1, False)
        return c0, c1

    def index(self, column):
        &#34;&#34;&#34;The index of a column.
        
        Parameters
        ----------
        column: None, int, or string
            A specification of a column.
            - None: no column is specified
            - int: the index of the column (first column is zero), e.g. `index(2)`.
            - a string representing an integer is converted into the column index,
              e.g. `index(&#39;2&#39;)`
            - a string specifying a column by its header.
              Header names of descending hierarchy are separated by &#39;&gt;&#39;.

        Returns
        -------
        index: int or None
            A valid column index or None.
        &#34;&#34;&#34;
        c0, c1 = self.find_col(column)
        return c0

    def __contains__(self, column):
        &#34;&#34;&#34;Check for existence of a column.

        Parameters
        ----------
        column: None, int, or string
            The column to be checked.
            See self.index() for more information on how to specify a column.

        Returns
        -------
        contains: bool
            True if `column` specifies an existing column key.
        &#34;&#34;&#34;
        return self.index(column) is not None

    def keys(self):
        &#34;&#34;&#34;List of unique column keys for all available columns.

        Returns
        -------
        keys: list of strings
            List of unique column specifications.
        &#34;&#34;&#34;
        return [self.column_spec(c) for c in range(self.columns())]

    def values(self):
        &#34;&#34;&#34;List of column data corresponding to keys().

        Returns
        -------
        data: list of list of values
            The data of the table. First index is columns!
        &#34;&#34;&#34;
        return self.data

    def items(self):
        &#34;&#34;&#34;Column names and corresponding data.

        Returns
        -------
        items: list of tuples
            Unique column specifications and the corresponding data.
        &#34;&#34;&#34;
        return [(self.column_spec(c), self.data[c]) for c in range(self.columns())]
        
    def __len__(self):
        &#34;&#34;&#34;The number of columns.
        
        Returns
        -------
        columns: int
            The number of columns contained in the table.
        &#34;&#34;&#34;
        return self.columns()

    def __iter__(self):
        &#34;&#34;&#34;Initialize iteration over data columns.
        &#34;&#34;&#34;
        self.iter_counter = -1
        return self

    def __next__(self):
        &#34;&#34;&#34;Next column of data.

        Returns
        -------
        data: list of values
            Table data of next column.
        &#34;&#34;&#34;
        self.iter_counter += 1
        if self.iter_counter &gt;= self.columns():
            raise StopIteration
        else:
            return self.data[self.iter_counter]

    def next(self):
        &#34;&#34;&#34;Return next data columns.  (python2 syntax)

        See also:
        ---------
        `__next__()`
        &#34;&#34;&#34;
        return self.__next__()

    def rows(self):
        &#34;&#34;&#34;The number of rows.
        
        Returns
        -------
        rows: int
            The number of rows contained in the table.
        &#34;&#34;&#34;
        return max(map(len, self.data)) if self.data else 0
    
    def columns(self):
        &#34;&#34;&#34;The number of columns.
        
        Returns
        -------
        columns: int
            The number of columns contained in the table.
        &#34;&#34;&#34;
        return len(self.header)

    def row(self, index):
        &#34;&#34;&#34;A single row of the table.

        Parameters
        ----------
        index: int
            The index of the row to be returned.

        Returns
        -------
        data: TableData
            A TableData object with a single row.
        &#34;&#34;&#34;
        data = TableData()
        sec_indices = [-1] * self.nsecs
        for c in range(self.columns()):
            data.append(*self.column_head(c))
            for l in range(self.nsecs):
                s, i = self.section(c, l+1)
                if i != sec_indices[l]:
                    data.header[-1].append(s)
                    sec_indices[l] = i
            data.data[-1] = [self.data[c][index]]
        data.nsecs = self.nsecs
        return data

    def row_dict(self, index):
        &#34;&#34;&#34;A single row of the table.

        Parameters
        ----------
        index: int
            The index of the row to be returned.

        Returns
        -------
        data: dict
            A dictionary with column header as key and corresponding data value of row `index`
            as value.
        &#34;&#34;&#34;
        data = {}
        for c in range(self.columns()):
            data[self.label(c)] = self.data[c][index]
        return data

    def col(self, column):
        &#34;&#34;&#34;A single column of the table.

        Parameters
        ----------
        column: None, int, or string
            The column to be returned.
            See self.index() for more information on how to specify a column.

        Returns
        -------
        table: TableData
            A TableData object with a single column.
        &#34;&#34;&#34;
        data = TableData()
        c = self.index(column)
        data.append(*self.column_head(c))
        data.data = [self.data[c]]
        data.nsecs = 0
        return data

    def __call__(self, column):
        &#34;&#34;&#34;A single column of the table as a numpy array.

        Parameters
        ----------
        column: None, int, or string
            The column to be returned.
            See self.index() for more information on how to specify a column.

        Returns
        -------
        data: 1-D array
            Content of the specified column as a numpy array.
        &#34;&#34;&#34;
        c = self.index(column)
        return np.asarray(self.data[c])

    def __setupkey(self, key):
        &#34;&#34;&#34;Helper function that turns a key into row and column indices.

        Returns
        -------
        rows: list of int, slice, None
            Indices of selected rows.
        cols: list of int
            Indices of selected columns.

        Raises
        ------
        IndexError:
            If an invalid column was specified.
        &#34;&#34;&#34;
        if type(key) is not tuple:
            rows = key
            cols = range(self.columns())
        else:
            rows = key[0]
            cols = key[1]
        if isinstance(cols, slice):
            start = cols.start
            if start is not None:
                start = self.index(start)
                if start is None:
                    raise IndexError(&#39;&#34;%s&#34; is not a valid column index&#39; % cols.start)
            stop = cols.stop
            if stop is not None:
                stop = self.index(stop)
                if stop is None:
                    raise IndexError(&#39;&#34;%s&#34; is not a valid column index&#39; % cols.stop)
            cols = slice(start, stop, cols.step)
            cols = range(self.columns())[cols]
        else:
            if not isinstance(cols, (list, tuple, np.ndarray)):
                cols = [cols]
            c = [self.index(inx) for inx in cols]
            if None in c:
                raise IndexError(&#39;&#34;%s&#34; is not a valid column index&#39; % cols[c.index(None)])
            cols = c
        if isinstance(rows, np.ndarray) and rows.dtype == np.dtype(bool):
            rows = np.where(rows)[0]
            if len(rows) == 0:
                rows = None
        return rows, cols

    def __getitem__(self, key):
        &#34;&#34;&#34;Data elements specified by slice.

        Parameters
        -----------
        key:
            First key specifies row, (optional) second one the column.
            Columns can be specified by index or name,
            see `index()` for details.

        Returns
        -------
        data:
            - A single data value if a single row and a single column is specified.
            - An array of data elements if a single single column is specified.
            - A TableData object for multiple columns.
            - None if no row is selected (e.g. by a logical index that nowhere is True)

        Raises
        ------
        IndexError:
            If an invalid column was specified.
        &#34;&#34;&#34;
        rows, cols = self.__setupkey(key)
        if len(cols) == 1:
            if rows is None:
                return None
            elif isinstance(rows, slice):
                return np.asarray(self.data[cols[0]][rows])
            elif isinstance(rows, (list, tuple, np.ndarray)):
                return np.asarray([self.data[cols[0]][r] for r in rows])
            else:
                return self.data[cols[0]][rows]
        else:
            data = TableData()
            sec_indices = [-1] * self.nsecs
            for c in cols:
                data.append(*self.column_head(c))
                for l in range(self.nsecs):
                    s, i = self.section(c, l+1)
                    if i != sec_indices[l]:
                        data.header[-1].append(s)
                        sec_indices[l] = i
                if rows is None:
                    continue
                if isinstance(rows, (list, tuple, np.ndarray)):
                    for r in rows:
                        data.data[-1].append(self.data[c][r])
                else:
                    if isinstance(self.data[c][rows], (list, tuple, np.ndarray)):
                        data.data[-1].extend(self.data[c][rows])
                    else:
                        data.data[-1].append(self.data[c][rows])
            data.nsecs = self.nsecs
            return data

    def __setitem__(self, key, value):
        &#34;&#34;&#34;Assign values to data elements specified by slice.

        Parameters
        -----------
        key:
            First key specifies row, (optional) second one the column.
            Columns can be specified by index or name,
            see `index()` for details.
        value: TableData, list, ndarray, float, ...
            Value(s) used to assing to the table elements as specified by `key`.

        Raises
        ------
        IndexError:
            If an invalid column was specified.
        &#34;&#34;&#34;
        rows, cols = self.__setupkey(key)
        if rows is None:
            return
        if isinstance(value, TableData):
            if isinstance(self.data[cols[0]][rows], (list, tuple, np.ndarray)):
                for k, c in enumerate(cols):
                    self.data[c][rows] = value.data[k]
            else:
                for k, c in enumerate(cols):
                    self.data[c][rows] = value.data[k][0]
        else:
            if len(cols) == 1:
                if isinstance(rows, (list, tuple, np.ndarray)):
                    if len(rows) == 1:
                        self.data[cols[0]][rows[0]] = value
                    elif isinstance(value, (list, tuple, np.ndarray)):
                        for k, r in enumerate(rows):
                            self.data[cols[0]][r] = value[k]
                    else:
                        for r in rows:
                            self.data[cols[0]][r] = value
                elif isinstance(value, (list, tuple, np.ndarray)):
                    self.data[cols[0]][rows] = value
                elif isinstance(rows, (int, np.integer)):
                    self.data[cols[0]][rows] = value
                else:
                    n = len(self.data[cols[0]][rows])
                    if n &gt; 1:
                        self.data[cols[0]][rows] = [value]*n
                    else:
                        self.data[cols[0]][rows] = value
            else:
                if isinstance(self.data[0][rows], (list, tuple, np.ndarray)):
                    for k, c in enumerate(cols):
                        self.data[c][rows] = value[:,k]
                elif isinstance(value, (list, tuple, np.ndarray)):
                    for k, c in enumerate(cols):
                        self.data[c][rows] = value[k]
                else:
                    for k, c in enumerate(cols):
                        self.data[c][rows] = value

    def __delitem__(self, key):
        &#34;&#34;&#34;Delete data elements or whole columns or rows.

        Parameters
        -----------
        key:
            First key specifies row, (optional) second one the column.
            Columns can be specified by index or name,
            see `index()` for details.
            If all rows are selected, then the specified columns are removed from the table.
            Otherwise only data values are removed.
            If all columns are selected than entire rows of data values are removed.
            Otherwise only data values in the specified rows are removed.

        Raises
        ------
        IndexError:
            If an invalid column was specified.
        &#34;&#34;&#34;
        rows, cols = self.__setupkey(key)
        if rows is None:
            return
        row_indices = np.arange(self.rows(), dtype=np.int)[rows]
        if isinstance(row_indices, np.ndarray):
            if len(row_indices) == self.rows():
                # delete whole columns:
                self.remove(cols)
            elif len(row_indices) &gt; 0:
                for r in reversed(sorted(row_indices)):
                    for c in cols:
                        del self.data[c][r]
                self.shape = (self.rows(), self.columns())
        else:
            for c in cols:
                del self.data[c][row_indices]
            self.shape = (self.rows(), self.columns())

    def array(self, row=None):
        &#34;&#34;&#34;The table data as a numpy array.

        Parameters
        ----------
        row: int or None
            If specified, a 1D array of that row will be returned.

        Returns
        -------
        data: 2D or 1D ndarray
            If no row is specified, the data content of the entire table
            as a 2D numpy array (rows first).
            If a row is specified, a 1D array of that row.
        &#34;&#34;&#34;
        if row is None:
            return np.array(self.data).T
        else:
            return np.array([d[row] for d in self.data])

    def data_frame(self):
        &#34;&#34;&#34;The table data as a pandas DataFrame.

        Returns
        -------
        data: pandas.DataFrame
            A pandas DataFrame of the whole table.
        &#34;&#34;&#34;
        return pd.DataFrame(self.dict())

    def dicts(self, raw_values=True, missing=&#39;-&#39;):
        &#34;&#34;&#34;The table as a list of dictionaries.

        Parameters
        ----------
        raw_values: bool
            If True, use raw table values as values,
            else format the values and add unit string.
        missing: string
            String indicating non-existing data elements.

        Returns
        -------
        table: list of dict
            For each row of the table a dictionary with header as key.
        &#34;&#34;&#34;
        table = []
        for row in range(self.rows()):
            data = {}
            for col in range(len(self.header)):
                if raw_values:
                    v = self.data[col][row];
                else:
                    if isinstance(self.data[col][row], float) and m.isnan(self.data[col][row]):
                        v = missing
                    else:
                        u = &#39;&#39;
                        if not self.units[col] in &#39;1-&#39; and self.units[col] != &#39;a.u.&#39;:
                            u = self.units[col]
                        v = (self.formats[col] % self.data[col][row]) + u
                data[self.header[col][0]] = v
            table.append(data)
        return table

    def dict(self):
        &#34;&#34;&#34;The table as a dictionary.

        Returns
        -------
        table: dict
            A dictionary with keys being the column headers and
            values the list of data elements of the corresponding column.
        &#34;&#34;&#34;
        table = {k: v for k, v in self.items()}
        return table

    def append_data(self, data, column=None):
        &#34;&#34;&#34;Append data elements to successive columns.

        The current column is set behid the added columns.

        Parameters
        ----------
        data: float, int, string, etc. or list thereof or list of list thereof
            Data values to be appended to successive column.
            - A single value is simply appened to the specified column of the table.
            - A 1D-list of values is appended to successive columns of the table
              starting with the specified column.
            - The columns of a 2D-list of values (second index) are appended
              to successive columns of the table starting with the specified column.
        column: None, int, or string
            The first column to which the data should be appended.
            If None, append to the current column.
            See self.index() for more information on how to specify a column.
        &#34;&#34;&#34;
        column = self.index(column)
        if column is None:
            column = self.setcol
        if isinstance(data, (list, tuple, np.ndarray)):
            if isinstance(data[0], (list, tuple, np.ndarray)):
                # 2D list, rows first:
                for row in data:
                    for i, val in enumerate(row):
                        self.data[column+i].append(val)
                self.setcol = column + len(data[0])
            else:
                # 1D list:
                for val in data:
                    self.data[column].append(val)
                    column += 1
                self.setcol = column
        else:
            # single value:
            self.data[column].append(data)
            self.setcol = column+1
        self.shape = (self.rows(), self.columns())

    def append_data_column(self, data, column=None):
        &#34;&#34;&#34;Append data elements to a column.

        The current column is incremented by one.

        Parameters
        ----------
        data: float, int, string, etc. or list thereof
            Data values to be appended to a column.
        column: None, int, or string
            The column to which the data should be appended.
            If None, append to the current column.
            See self.index() for more information on how to specify a column.
        &#34;&#34;&#34;
        column = self.index(column)
        if column is None:
            column = self.setcol
        if isinstance(data, (list, tuple, np.ndarray)):
            self.data[column].extend(data)
            column += 1
            self.setcol = column
        else:
            self.data[column].append(data)
            self.setcol = column+1
        self.shape = (self.rows(), self.columns())

    def set_column(self, column):
        &#34;&#34;&#34;Set the column where to add data.

        Parameters
        ----------
        column: int or string
            The column to which data elements should be appended.
            See self.index() for more information on how to specify a column.

        Raises
        ------
        IndexError:
            If an invalid column was specified.
        &#34;&#34;&#34;
        col = self.index(column)
        if col is None:
            if isinstance(column, (int, np.integer)):
                column = &#39;%d&#39; % column
            raise IndexError(&#39;column &#39; + column + &#39; not found or invalid&#39;)
        self.setcol = col
        return col

    def fill_data(self):
        &#34;&#34;&#34;Fill up all columns with missing data to have the same number of
        data elements.
        &#34;&#34;&#34;
        # maximum rows:
        maxr = self.rows()
        # fill up:
        for c in range(len(self.data)):
            while len(self.data[c]) &lt; maxr:
                self.data[c].append(np.nan)
        self.setcol = 0
        self.shape = (self.rows(), self.columns())

    def clear_data(self):
        &#34;&#34;&#34;Clear content of the table but keep header.
        &#34;&#34;&#34;
        for c in range(len(self.data)):
            self.data[c] = []
        self.setcol = 0
        self.shape = (self.rows(), self.columns())
                
    def sort(self, columns, reverse=False):
        &#34;&#34;&#34;Sort the table rows in place.

        Parameters
        ----------
        columns: int or string or list of int or string
            A column specifier or a list of column specifiers of the columns
            to be sorted.
        reverse: boolean
            If `True` sort in descending order.

        Raises
        ------
        IndexError:
            If an invalid column was specified.
        &#34;&#34;&#34;
        # fix columns:
        if not isinstance(columns, (list, tuple, np.ndarray)):
            columns = [ columns ]
        if not columns:
            return
        cols = []
        for col in columns:
            c = self.index(col)
            if c is None:
                if isinstance(col, (int, np.integer)):
                    col = &#39;%d&#39; % col
                raise IndexError(&#39;sort column &#39; + col + &#39; not found&#39;)
                continue
            cols.append(c)
        # get sorted row indices:
        row_inx = range(self.rows())
        row_inx = sorted(row_inx, key=lambda x : [float(&#39;-inf&#39;) if self.data[c][x] is np.nan \
                         or self.data[c][x] != self.data[c][x] \
                         else self.data[c][x] for c in cols], reverse=reverse)
        # sort table according to indices:
        for c in range(self.columns()):
            self.data[c] = [self.data[c][r] for r in row_inx]

    def statistics(self):
        &#34;&#34;&#34;Descriptive statistics of each column.
        &#34;&#34;&#34;
        ds = TableData()
        if self.nsecs &gt; 0:
            ds.append_section(&#39;statistics&#39;)
            for l in range(1,self.nsecs):
                ds.append_section(&#39;-&#39;)
            ds.append(&#39;-&#39;, &#39;-&#39;, &#39;%-10s&#39;)
        else:
            ds.append(&#39;statistics&#39;, &#39;-&#39;, &#39;%-10s&#39;)
        ds.append_data(&#39;mean&#39;, 0)
        ds.append_data(&#39;std&#39;, 0)
        ds.append_data(&#39;min&#39;, 0)
        ds.append_data(&#39;quartile1&#39;, 0)
        ds.append_data(&#39;median&#39;, 0)
        ds.append_data(&#39;quartile3&#39;, 0)
        ds.append_data(&#39;max&#39;, 0)
        ds.append_data(&#39;count&#39;, 0)
        dc = 1
        for c in range(self.columns()):
            if len(self.data[c]) &gt; 0 and isinstance(self.data[c][0], (float, int)):
                ds.hidden.append(False)
                ds.header.append(self.header[c])
                ds.units.append(self.units[c])
                # integer data still make floating point statistics:
                if isinstance(self.data[c][0], float):
                    f = self.formats[c]
                    i0 = f.find(&#39;.&#39;)
                    if i0 &gt; 0:
                        p = int(f[i0+1:-1])
                        if p &lt;= 0:
                            f = &#39;%.1f&#39;
                    ds.formats.append(f)
                else:
                    ds.formats.append(&#39;%.1f&#39;)
                # remove nans:
                data = np.asarray(self.data[c], np.float)
                data = data[np.isfinite(data)]
                # compute statistics:
                ds.data.append([])
                ds.append_data(np.mean(data), dc)
                ds.append_data(np.std(data), dc)
                ds.append_data(np.min(data), dc)
                q1, m, q3 = np.percentile(data, [25., 50., 75.])
                ds.append_data(q1, dc)
                ds.append_data(m, dc)
                ds.append_data(q3, dc)
                ds.append_data(np.max(data), dc)
                ds.append_data(len(data), dc)
                dc += 1
        ds.nsecs = self.nsecs
        ds.shape = (ds.rows(), ds.columns())
        return ds

    def key_value(self, row, col, missing=&#39;-&#39;):
        &#34;&#34;&#34;A data element returned as a key-value pair.

        Parameters
        ----------
        row: int
            Specifies the row from which the data element should be retrieved.
        col: None, int, or string
            A specification of a column.
            See self.index() for more information on how to specify a column.
        missing: string
            String indicating non-existing data elements.

        Returns
        -------
        key: string
            Header label of the column
        value: string
            A textual representation of the data element according to the format
            of the column, followed by the unit of the column.
        &#34;&#34;&#34;
        col = self.index(col)
        if col is None:
            return &#39;&#39;
        if isinstance(self.data[col][row], float) and m.isnan(self.data[col][row]):
            v = missing
        else:
            u = &#39;&#39;
            if not self.units[col] in &#39;1-&#39; and self.units[col] != &#39;a.u.&#39;:
                u = self.units[col]
            v = (self.formats[col] % self.data[col][row]) + u
        return self.header[col][0], v

    def hide(self, column):
        &#34;&#34;&#34;Hide a column or a range of columns.

        Hidden columns will not be printed out by the write() function.

        Parameters
        ----------
        column: int or string
            The column to be hidden.
            See self.index() for more information on how to specify a column.
        &#34;&#34;&#34;
        c0, c1 = self.find_col(column)
        if c0 is not None:
            for c in range(c0, c1):
                self.hidden[c] = True

    def hide_all(self):
        &#34;&#34;&#34;Hide all columns.

        Hidden columns will not be printed out by the write() function.
        &#34;&#34;&#34;
        for c in range(len(self.hidden)):
            self.hidden[c] = True

    def hide_empty_columns(self, missing=&#39;-&#39;):
        &#34;&#34;&#34;Hide all columns that do not contain data.

        Hidden columns will not be printed out by the write() function.

        Parameters
        ----------
        missing: string
            String indicating missing data.
        &#34;&#34;&#34;
        for c in range(len(self.data)):
            # check for empty column:
            isempty = True
            for v in self.data[c]:
                if isinstance(v, float):
                    if not m.isnan(v):
                        isempty = False
                        break
                else:
                    if v != missing:
                        isempty = False
                        break
            if isempty:
                self.hidden[c] = True

    def show(self, column):
        &#34;&#34;&#34;Show a column or a range of columns.

        Undoes hiding of a column.

        Parameters
        ----------
        column: int or string
            The column to be shown.
            See self.index() for more information on how to specify a column.
        &#34;&#34;&#34;
        c0, c1 = self.find_col(column)
        if c0 is not None:
            for c in range(c0, c1):
                self.hidden[c] = False

    def write(self, fh=sys.stdout, table_format=None, delimiter=None,
              unit_style=None, column_numbers=None, sections=None,
              align_columns=None, shrink_width=True, missing=&#39;-&#39;,
              center_columns=False, latex_label_command=&#39;&#39;, latex_merge_std=False):
        &#34;&#34;&#34;Write the table to a file or stream.

        Parameters
        ----------
        fh: filename or stream
            If not a stream, the file with name `fh` is opened.
            If `fh` does not have an extension,
            the `table_format` is appended as an extension.
            Otherwise `fh` is used as a stream for writing.
        table_format: None or string
            The format to be used for output.
            One of &#39;out&#39;, &#39;dat&#39;, &#39;ascii&#39;, &#39;csv&#39;, &#39;rtai&#39;, &#39;md&#39;, &#39;tex&#39;, &#39;html&#39;.
            If None or &#39;auto&#39; then the format is set to the extension of the filename given by `fh`.
            If `fh` is a stream the format is set to &#39;dat&#39;.
        delimiter: string
            String or character separating columns, if supported by the `table_format`.
            If None or &#39;auto&#39; use the default for the specified `table_format`.
        unit_style: None or string
            - None or &#39;auto&#39;: use default of the specified `table_format`.
            - &#39;row&#39;: write an extra row to the table header specifying the units of the columns.
            - &#39;header&#39;: add the units to the column headers.
            - &#39;none&#39;: do not specify the units.
        column_numbers: string or None
            Add a row specifying the column index:
            - &#39;index&#39;: indices are integers, first column is 0.
            - &#39;num&#39;: indices are integers, first column is 1.
            - &#39;aa&#39;: use &#39;a&#39;, &#39;b&#39;, &#39;c&#39;, ..., &#39;z&#39;, &#39;aa&#39;, &#39;ab&#39;, ... for indexing
            - &#39;aa&#39;: use &#39;A&#39;, &#39;B&#39;, &#39;C&#39;, ..., &#39;Z&#39;, &#39;AA&#39;, &#39;AB&#39;, ... for indexing
            - None or &#39;none&#39;: do not add a row with column indices
            TableData.column_numbering is a list with the supported styles.
        sections: None or int
            Number of section levels to be printed.
            If `None` or &#39;auto&#39; use default of selected `table_format`.
        align_columns: boolean
            - `True`: set width of column formats to make them align.
            - `False`: set width of column formats to 0 - no unnecessary spaces.
            - None or &#39;auto&#39;: Use default of the selected `table_format`.
        shrink_width: boolean
            If `True` disregard width specified by the format strings,
            such that columns can become narrower.
        missing: string
            Indicate missing data by this string.
        center_columns: boolean
            If True center all columns (markdown, html, and latex).
        latex_label_command: string
            LaTeX command for formatting header labels.
            E.g. &#39;textbf&#39; for making the header labels bold.
        latex_merge_std: string
            Merge header of columns with standard deviations with previous column
            (LaTeX tables only).

        Returns
        -------
        file_name: string or None
            The full name of the file into which the data were written.

        Supported file formats
        ----------------------
        
        ## `dat`: data text file
        ``` plain
        # info           reaction     
        # size   weight  delay  jitter
        # m      kg      ms     mm    
           2.34     123   98.7      23
          56.70    3457   54.3      45
           8.90      43   67.9     345
        ```

        ## `ascii`: ascii-art table
        ``` plain
        |---------------------------------|
        | info           | reaction       |
        | size  | weight | delay | jitter |
        | m     | kg     | ms    | mm     |
        |-------|--------|-------|--------|
        |  2.34 |    123 |  98.7 |     23 |
        | 56.70 |   3457 |  54.3 |     45 |
        |  8.90 |     43 |  67.9 |    345 |
        |---------------------------------|
        ```

        ## `csv`: comma separated values
        ``` plain
        size/m,weight/kg,delay/ms,jitter/mm
        2.34,123,98.7,23
        56.70,3457,54.3,45
        8.90,43,67.9,345
        ```

        ## `rtai`: rtai-style table
        ``` plain
        RTH| info         | reaction     
        RTH| size | weight| delay| jitter
        RTH| m    | kg    | ms   | mm    
        RTD|  2.34|    123|  98.7|     23
        RTD| 56.70|   3457|  54.3|     45
        RTD|  8.90|     43|  67.9|    345
        ```

        ## `md`: markdown
        ``` plain
        | size/m | weight/kg | delay/ms | jitter/mm |
        |------:|-------:|------:|-------:|
        |  2.34 |    123 |  98.7 |     23 |
        | 56.70 |   3457 |  54.3 |     45 |
        |  8.90 |     43 |  67.9 |    345 |
        ```

        ## `tex`: latex tabular
        ``` tex
        \\begin{tabular}{rrrr}
          \\hline
          \\multicolumn{2}{l}{info} &amp; \\multicolumn{2}{l}{reaction} \\
          \\multicolumn{1}{l}{size} &amp; \\multicolumn{1}{l}{weight} &amp; \\multicolumn{1}{l}{delay} &amp; \\multicolumn{1}{l}{jitter} \\
          \\multicolumn{1}{l}{m} &amp; \\multicolumn{1}{l}{kg} &amp; \\multicolumn{1}{l}{ms} &amp; \\multicolumn{1}{l}{mm} \\
          \\hline
          2.34 &amp; 123 &amp; 98.7 &amp; 23 \\
          56.70 &amp; 3457 &amp; 54.3 &amp; 45 \\
          8.90 &amp; 43 &amp; 67.9 &amp; 345 \\
          \\hline
        \\end{tabular}
        ```

        ## `html`: html
        ``` html
        &lt;table&gt;
        &lt;thead&gt;
          &lt;tr class=&#34;header&#34;&gt;
            &lt;th align=&#34;left&#34; colspan=&#34;2&#34;&gt;info&lt;/th&gt;
            &lt;th align=&#34;left&#34; colspan=&#34;2&#34;&gt;reaction&lt;/th&gt;
          &lt;/tr&gt;
          &lt;tr class=&#34;header&#34;&gt;
            &lt;th align=&#34;left&#34;&gt;size&lt;/th&gt;
            &lt;th align=&#34;left&#34;&gt;weight&lt;/th&gt;
            &lt;th align=&#34;left&#34;&gt;delay&lt;/th&gt;
            &lt;th align=&#34;left&#34;&gt;jitter&lt;/th&gt;
          &lt;/tr&gt;
          &lt;tr class=&#34;header&#34;&gt;
            &lt;th align=&#34;left&#34;&gt;m&lt;/th&gt;
            &lt;th align=&#34;left&#34;&gt;kg&lt;/th&gt;
            &lt;th align=&#34;left&#34;&gt;ms&lt;/th&gt;
            &lt;th align=&#34;left&#34;&gt;mm&lt;/th&gt;
          &lt;/tr&gt;
        &lt;/thead&gt;
        &lt;tbody&gt;
          &lt;tr class&#34;odd&#34;&gt;
            &lt;td align=&#34;right&#34;&gt;2.34&lt;/td&gt;
            &lt;td align=&#34;right&#34;&gt;123&lt;/td&gt;
            &lt;td align=&#34;right&#34;&gt;98.7&lt;/td&gt;
            &lt;td align=&#34;right&#34;&gt;23&lt;/td&gt;
          &lt;/tr&gt;
          &lt;tr class&#34;even&#34;&gt;
            &lt;td align=&#34;right&#34;&gt;56.70&lt;/td&gt;
            &lt;td align=&#34;right&#34;&gt;3457&lt;/td&gt;
            &lt;td align=&#34;right&#34;&gt;54.3&lt;/td&gt;
            &lt;td align=&#34;right&#34;&gt;45&lt;/td&gt;
          &lt;/tr&gt;
          &lt;tr class&#34;odd&#34;&gt;
            &lt;td align=&#34;right&#34;&gt;8.90&lt;/td&gt;
            &lt;td align=&#34;right&#34;&gt;43&lt;/td&gt;
            &lt;td align=&#34;right&#34;&gt;67.9&lt;/td&gt;
            &lt;td align=&#34;right&#34;&gt;345&lt;/td&gt;
          &lt;/tr&gt;
        &lt;/tbody&gt;
        &lt;/table&gt;
        ```
        &#34;&#34;&#34;
        # fix parameter:
        if table_format == &#39;auto&#39;:
            table_format = None
        if delimiter == &#39;auto&#39;:
            delimiter = None
        if unit_style == &#39;auto&#39;:
            unit_style = None
        if column_numbers == &#39;none&#39;:
            column_numbers = None
        if sections == &#39;auto&#39;:
            sections = None
        if align_columns == &#39;auto&#39;:
            align_columns = None
        # open file:
        own_file = False
        file_name = None
        if not hasattr(fh, &#39;write&#39;):
            _, ext = os.path.splitext(fh)
            if table_format is None:
                if len(ext) &gt; 1 and ext[1:] in self.ext_formats:
                    table_format = self.ext_formats[ext[1:]]
            elif not ext or not ext[1:].lower() in self.ext_formats:
                fh += &#39;.&#39; + self.extensions[table_format]
            file_name = fh
            fh = open(fh, &#39;w&#39;)
            own_file = True
        if table_format is None:
            table_format = &#39;dat&#39;
        # set style:        
        if table_format[0] == &#39;d&#39;:
            align_columns = True
            begin_str = &#39;&#39;
            end_str = &#39;&#39;
            header_start = &#39;# &#39;
            header_sep = &#39;  &#39;
            header_close = &#39;&#39;
            header_end = &#39;\n&#39;
            data_start = &#39;  &#39;
            data_sep = &#39;  &#39;
            data_close = &#39;&#39;
            data_end = &#39;\n&#39;
            top_line = False
            header_line = False
            bottom_line = False
            if delimiter is not None:
                header_sep = delimiter
                data_sep = delimiter
            if sections is None:
                sections = 1000
        elif table_format[0] == &#39;a&#39;:
            align_columns = True
            begin_str = &#39;&#39;
            end_str = &#39;&#39;
            header_start = &#39;| &#39;
            header_sep = &#39; | &#39;
            header_close = &#39;&#39;
            header_end = &#39; |\n&#39;
            data_start = &#39;| &#39;
            data_sep = &#39; | &#39;
            data_close = &#39;&#39;
            data_end = &#39; |\n&#39;
            top_line = True
            header_line = True
            bottom_line = True
            if delimiter is not None:
                header_sep = delimiter
                data_sep = delimiter
            if sections is None:
                sections = 1000
        elif table_format[0] == &#39;c&#39;:
            # csv according to http://www.ietf.org/rfc/rfc4180.txt :
            column_numbers=None
            if unit_style is None:
                unit_style = &#39;header&#39;
            if align_columns is None:
                align_columns = False
            begin_str = &#39;&#39;
            end_str = &#39;&#39;
            header_start=&#39;&#39;
            header_sep = &#39;,&#39;
            header_close = &#39;&#39;
            header_end=&#39;\n&#39;
            data_start=&#39;&#39;
            data_sep = &#39;,&#39;
            data_close = &#39;&#39;
            data_end=&#39;\n&#39;
            top_line = False
            header_line = False
            bottom_line = False
            if delimiter is not None:
                header_sep = delimiter
                data_sep = delimiter
            if sections is None:
                sections = 0
        elif table_format[0] == &#39;r&#39;:
            align_columns = True
            begin_str = &#39;&#39;
            end_str = &#39;&#39;
            header_start = &#39;RTH| &#39;
            header_sep = &#39;| &#39;
            header_close = &#39;&#39;
            header_end = &#39;\n&#39;
            data_start = &#39;RTD| &#39;
            data_sep = &#39;| &#39;
            data_close = &#39;&#39;
            data_end = &#39;\n&#39;
            top_line = False
            header_line = False
            bottom_line = False
            if sections is None:
                sections = 1000
        elif table_format[0] == &#39;m&#39;:
            if unit_style is None or unit_style == &#39;row&#39;:
                unit_style = &#39;header&#39;
            align_columns = True
            begin_str = &#39;&#39;
            end_str = &#39;&#39;
            header_start=&#39;| &#39;
            header_sep = &#39; | &#39;
            header_close = &#39;&#39;
            header_end=&#39; |\n&#39;
            data_start=&#39;| &#39;
            data_sep = &#39; | &#39;
            data_close = &#39;&#39;
            data_end=&#39; |\n&#39;
            top_line = False
            header_line = True
            bottom_line = False
            if sections is None:
                sections = 0
        elif table_format[0] == &#39;h&#39;:
            align_columns = False
            begin_str = &#39;&lt;table&gt;\n&lt;thead&gt;\n&#39;
            end_str = &#39;&lt;/tbody&gt;\n&lt;/table&gt;\n&#39;
            if center_columns:
                header_start=&#39;  &lt;tr&gt;\n    &lt;th align=&#34;center&#34;&#39;
                header_sep = &#39;&lt;/th&gt;\n    &lt;th align=&#34;center&#34;&#39;
            else:
                header_start=&#39;  &lt;tr&gt;\n    &lt;th align=&#34;left&#34;&#39;
                header_sep = &#39;&lt;/th&gt;\n    &lt;th align=&#34;left&#34;&#39;
            header_close = &#39;&gt;&#39;
            header_end=&#39;&lt;/th&gt;\n  &lt;/tr&gt;\n&#39;
            data_start=&#39;  &lt;tr&gt;\n    &lt;td&#39;
            data_sep = &#39;&lt;/td&gt;\n    &lt;td&#39;
            data_close = &#39;&gt;&#39;
            data_end=&#39;&lt;/td&gt;\n  &lt;/tr&gt;\n&#39;
            top_line = False
            header_line = False
            bottom_line = False
            if sections is None:
                sections = 1000
        elif table_format[0] == &#39;t&#39;:
            if align_columns is None:
                align_columns = False
            begin_str = &#39;\\begin{tabular}&#39;
            end_str = &#39;\\end{tabular}\n&#39;
            header_start=&#39;  &#39;
            header_sep = &#39; &amp; &#39;
            header_close = &#39;&#39;
            header_end=&#39; \\\\\n&#39;
            data_start=&#39;  &#39;
            data_sep = &#39; &amp; &#39;
            data_close = &#39;&#39;
            data_end=&#39; \\\\\n&#39;
            top_line = True
            header_line = True
            bottom_line = True
            if sections is None:
                sections = 1000
        else:
            if align_columns is None:
                align_columns = True
            begin_str = &#39;&#39;
            end_str = &#39;&#39;
            header_start = &#39;&#39;
            header_sep = &#39;  &#39;
            header_close = &#39;&#39;
            header_end = &#39;\n&#39;
            data_start = &#39;&#39;
            data_sep = &#39;  &#39;
            data_close = &#39;&#39;
            data_end = &#39;\n&#39;
            top_line = False
            header_line = False
            bottom_line = False
            if sections is None:
                sections = 1000
        # check units:
        if unit_style is None:
            unit_style = &#39;row&#39;
        have_units = False
        for u in self.units:
            if u and u != &#39;1&#39; and u != &#39;-&#39;:
                have_units = True
                break
        if not have_units:
            unit_style = &#39;none&#39;
        # find std columns:
        stdev_col = np.zeros(len(self.header), dtype=np.bool)
        for c in range(len(self.header)-1):
            if self.header[c+1][0].lower() in [&#39;sd&#39;, &#39;std&#39;, &#39;s.d.&#39;, &#39;stdev&#39;] and \
               not self.hidden[c+1]:
                stdev_col[c] = True
        # begin table:
        fh.write(begin_str)
        if table_format[0] == &#39;t&#39;:
            fh.write(&#39;{&#39;)
            merged = False
            for h, f, s in zip(self.hidden, self.formats, stdev_col):
                if merged:
                    fh.write(&#39;l&#39;)
                    merged = False
                    continue
                if h:
                    continue
                if latex_merge_std and s:
                    fh.write(&#39;r@{$\\,\\pm\\,$}&#39;)
                    merged = True
                elif center_columns:
                    fh.write(&#39;c&#39;)
                elif f[1] == &#39;-&#39;:
                    fh.write(&#39;l&#39;)
                else:
                    fh.write(&#39;r&#39;)
            fh.write(&#39;}\n&#39;)
        # retrieve column formats and widths:
        widths = []
        widths_pos = []
        for c, f in enumerate(self.formats):
            w = 0
            # position of width specification:
            i0 = 1
            if f[1] == &#39;-&#39; :
                i0 = 2
            i1 = f.find(&#39;.&#39;)
            if not shrink_width:
                if f[i0:i1]:
                    w = int(f[i0:i1])
            widths_pos.append((i0, i1))
            # adapt width to header label:
            hw = len(self.header[c][0])
            if unit_style == &#39;header&#39; and self.units[c] and\
               self.units[c] != &#39;1&#39; and self.units[c] != &#39;-&#39;:
                hw += 1 + len(self.units[c])
            if w &lt; hw:
                w = hw
            # adapt width to data:
            if f[-1] == &#39;s&#39;:
                for v in self.data[c]:
                    if not isinstance(v, float) and w &lt; len(v):
                        w = len(v)
            else:
                fs = f[:i0] + str(0) + f[i1:]
                for v in self.data[c]:
                    if isinstance(v, float) and m.isnan(v):
                        s = missing
                    else:
                        s = fs % v
                    if w &lt; len(s):
                        w = len(s)
            widths.append(w)
        # adapt width to sections:
        sec_indices = [0] * self.nsecs
        sec_widths = [0] * self.nsecs
        sec_columns = [0] * self.nsecs
        for c in range(len(self.header)):
            w = widths[c]
            for l in range(min(self.nsecs, sections)):
                if 1+l &lt; len(self.header[c]):
                    if c &gt; 0 and sec_columns[l] &gt; 0 and \
                       1+l &lt; len(self.header[sec_indices[l]]) and \
                       len(self.header[sec_indices[l]][1+l]) &gt; sec_widths[l]:
                        dw = len(self.header[sec_indices[l]][1+l]) - sec_widths[l]
                        nc = sec_columns[l]
                        ddw = np.zeros(nc, dtype=int) + dw // nc
                        ddw[:dw % nc] += 1
                        wk = 0
                        for ck in range(sec_indices[l], c):
                            if not self.hidden[ck]:
                                widths[ck] += ddw[wk]
                                wk += 1
                    sec_widths[l] = 0
                    sec_indices[l] = c
                if not self.hidden[c]:
                    if sec_widths[l] &gt; 0:
                        sec_widths[l] += len(header_sep)
                    sec_widths[l] += w
                    sec_columns[l] += 1
        # set width of format string:
        formats = []
        for c, (f, w) in enumerate(zip(self.formats, widths)):
            formats.append(f[:widths_pos[c][0]] + str(w) + f[widths_pos[c][1]:])
        # top line:
        if top_line:
            if table_format[0] == &#39;t&#39;:
                fh.write(&#39;  \\hline \\\\[-2ex]\n&#39;)
            else:
                first = True
                fh.write(header_start.replace(&#39; &#39;, &#39;-&#39;))
                for c in range(len(self.header)):
                    if self.hidden[c]:
                        continue
                    if not first:
                        fh.write(&#39;-&#39;*len(header_sep))
                    first = False
                    fh.write(header_close)
                    w = widths[c]
                    fh.write(w*&#39;-&#39;)
                fh.write(header_end.replace(&#39; &#39;, &#39;-&#39;))
        # section and column headers:
        nsec0 = self.nsecs-sections
        if nsec0 &lt; 0:
            nsec0 = 0
        for ns in range(nsec0, self.nsecs+1):
            nsec = self.nsecs-ns
            first = True
            last = False
            merged = False
            fh.write(header_start)
            for c in range(len(self.header)):
                if nsec &lt; len(self.header[c]):
                    # section width and column count:
                    sw = -len(header_sep)
                    columns = 0
                    if not self.hidden[c]:
                        sw = widths[c]
                        columns = 1
                    for k in range(c+1, len(self.header)):
                        if nsec &lt; len(self.header[k]):
                            break
                        if self.hidden[k]:
                            continue
                        sw += len(header_sep) + widths[k]
                        columns += 1
                    else:
                        last = True
                        if len(header_end.strip()) == 0:
                            sw = 0  # last entry needs no width
                    if columns == 0:
                        continue
                    if not first and not merged:
                        fh.write(header_sep)
                    first = False
                    if table_format[0] == &#39;c&#39;:
                        sw -= len(header_sep)*(columns-1)
                    elif table_format[0] == &#39;h&#39;:
                        if columns&gt;1:
                            fh.write(&#39; colspan=&#34;%d&#34;&#39; % columns)
                    elif table_format[0] == &#39;t&#39;:
                        if merged:
                            merged = False
                            continue
                        if latex_merge_std and nsec == 0 and stdev_col[c]:
                            merged = True
                            fh.write(&#39;\\multicolumn{%d}{c}{&#39; % (columns+1))
                        elif center_columns:
                            fh.write(&#39;\\multicolumn{%d}{c}{&#39; % columns)
                        else:
                            fh.write(&#39;\\multicolumn{%d}{l}{&#39; % columns)
                        if latex_label_command:
                            fh.write(&#39;\\%s{&#39; % latex_label_command)
                    fh.write(header_close)
                    hs = self.header[c][nsec]
                    if nsec == 0 and unit_style == &#39;header&#39;:
                        if self.units[c] and self.units[c] != &#39;1&#39; and self.units[c] != &#39;-&#39;:
                            hs += &#39;/&#39; + self.units[c]
                    if align_columns and not table_format[0] in &#39;th&#39;:
                        f = &#39;%%-%ds&#39; % sw
                        fh.write(f % hs)
                    else:
                        fh.write(hs)
                    if table_format[0] == &#39;c&#39;:
                        if not last:
                            fh.write(header_sep*(columns-1))
                    elif table_format[0] == &#39;t&#39;:
                        if latex_label_command:
                            fh.write(&#39;}&#39;)
                        fh.write(&#39;}&#39;)
            fh.write(header_end)
        # units:
        if unit_style == &#39;row&#39;:
            first = True
            merged = False
            fh.write(header_start)
            for c in range(len(self.header)):
                if self.hidden[c] or merged:
                    merged = False
                    continue
                if not first:
                    fh.write(header_sep)
                first = False
                fh.write(header_close)
                unit = self.units[c]
                if not unit:
                    unit = &#39;-&#39;
                if table_format[0] == &#39;t&#39;:
                    if latex_merge_std and stdev_col[c]:
                        merged = True
                        fh.write(&#39;\\multicolumn{2}{c}{%s}&#39; % latex_unit(unit))
                    elif center_columns:
                        fh.write(&#39;\\multicolumn{1}{c}{%s}&#39; % latex_unit(unit))
                    else:
                        fh.write(&#39;\\multicolumn{1}{l}{%s}&#39; % latex_unit(unit))
                else:
                    if align_columns and not table_format[0] in &#39;h&#39;:
                        f = &#39;%%-%ds&#39; % widths[c]
                        fh.write(f % unit)
                    else:
                        fh.write(unit)
            fh.write(header_end)
        # column numbers:
        if column_numbers is not None:
            first = True
            fh.write(header_start)
            for c in range(len(self.header)):
                if self.hidden[c]:
                    continue
                if not first:
                    fh.write(header_sep)
                first = False
                fh.write(header_close)
                i = c
                if column_numbers == &#39;num&#39;:
                    i = c+1
                aa = index2aa(c, &#39;a&#39;)
                if column_numbers == &#39;AA&#39;:
                    aa = index2aa(c, &#39;A&#39;)
                if table_format[0] == &#39;t&#39;:
                    if column_numbers == &#39;num&#39; or column_numbers == &#39;index&#39;:
                        fh.write(&#39;\\multicolumn{1}{l}{%d}&#39; % i)
                    else:
                        fh.write(&#39;\\multicolumn{1}{l}{%s}&#39; % aa)
                else:
                    if column_numbers == &#39;num&#39; or column_numbers == &#39;index&#39;:
                        if align_columns:
                            f = &#39;%%%dd&#39; % widths[c]
                            fh.write(f % i)
                        else:
                            fh.write(&#39;%d&#39; % i)
                    else:
                        if align_columns:
                            f = &#39;%%-%ds&#39; % widths[c]
                            fh.write(f % aa)
                        else:
                            fh.write(aa)
            fh.write(header_end)
        # header line:
        if header_line:
            if table_format[0] == &#39;m&#39;:
                fh.write(&#39;|&#39;)
                for c in range(len(self.header)):
                    if self.hidden[c]:
                        continue
                    w = widths[c]+2
                    if center_columns:
                        fh.write(&#39;:&#39; + (w-2)*&#39;-&#39; + &#39;:|&#39;)
                    elif formats[c][1] == &#39;-&#39;:
                        fh.write(w*&#39;-&#39; + &#39;|&#39;)
                    else:
                        fh.write((w-1)*&#39;-&#39; + &#39;:|&#39;)
                fh.write(&#39;\n&#39;)
            elif table_format[0] == &#39;t&#39;:
                fh.write(&#39;  \\hline \\\\[-2ex]\n&#39;)
            else:
                first = True
                fh.write(header_start.replace(&#39; &#39;, &#39;-&#39;))
                for c in range(len(self.header)):
                    if self.hidden[c]:
                        continue
                    if not first:
                        fh.write(header_sep.replace(&#39; &#39;, &#39;-&#39;))
                    first = False
                    fh.write(header_close)
                    w = widths[c]
                    fh.write(w*&#39;-&#39;)
                fh.write(header_end.replace(&#39; &#39;, &#39;-&#39;))
        # start table data:
        if table_format[0] == &#39;h&#39;:
            fh.write(&#39;&lt;/thead&gt;\n&lt;tbody&gt;\n&#39;)
        # data:
        for k in range(self.rows()):
            first = True
            merged = False
            fh.write(data_start)
            for c, f in enumerate(formats):
                if self.hidden[c] or merged:
                    merged = False
                    continue
                if not first:
                    fh.write(data_sep)
                first = False
                if table_format[0] == &#39;h&#39;:
                    if center_columns:
                        fh.write(&#39; align=&#34;center&#34;&#39;)
                    elif f[1] == &#39;-&#39;:
                        fh.write(&#39; align=&#34;left&#34;&#39;)
                    else:
                        fh.write(&#39; align=&#34;right&#34;&#39;)
                fh.write(data_close)
                if k &gt;= len(self.data[c]) or \
                   (isinstance(self.data[c][k], float) and m.isnan(self.data[c][k])):
                    # missing data:
                    if table_format[0] == &#39;t&#39; and latex_merge_std and stdev_col[c]:
                        merged = True
                        fh.write(&#39;\\multicolumn{2}{c}{%s}&#39; % missing)
                    elif align_columns:
                        if f[1] == &#39;-&#39;:
                            fn = &#39;%%-%ds&#39; % widths[c]
                        else:
                            fn = &#39;%%%ds&#39; % widths[c]
                        fh.write(fn % missing)
                    else:
                        fh.write(missing)
                else:
                    # data value:
                    ds = f % self.data[c][k]
                    if not align_columns:
                        ds = ds.strip()
                    fh.write(ds)
            fh.write(data_end)
        # bottom line:
        if bottom_line:
            if table_format[0] == &#39;t&#39;:
                fh.write(&#39;  \\hline\n&#39;)
            else:
                first = True
                fh.write(header_start.replace(&#39; &#39;, &#39;-&#39;))
                for c in range(len(self.header)):
                    if self.hidden[c]:
                        continue
                    if not first:
                        fh.write(&#39;-&#39;*len(header_sep))
                    first = False
                    fh.write(header_close)
                    w = widths[c]
                    fh.write(w*&#39;-&#39;)
                fh.write(header_end.replace(&#39; &#39;, &#39;-&#39;))
        # end table:
        fh.write(end_str)
        # close file:
        if own_file:
            fh.close()
        # return file name:
        return file_name

            
    def __str__(self):
        &#34;&#34;&#34;Write table to a string.
        &#34;&#34;&#34;
        stream = StringIO()
        self.write(stream, table_format=&#39;out&#39;)
        return stream.getvalue()
                

    def load(self, fh, missing=&#39;-&#39;):
        &#34;&#34;&#34;Load table from file or stream.

        File type and properties are automatically inferred.

        Parameters
        ----------
        fh: filename or stream
            If not a stream, the file with name `fh` is opened for reading.
        missing: string
            Missing data are indicated by this string.

        Raises
        ------
        FileNotFoundError:
            If `fh` is a path that does not exist.
        &#34;&#34;&#34;

        def read_key_line(line, sep, table_format):
            if sep is None:
                cols, indices = zip(*[(m.group(0), m.start()) for m in re.finditer(r&#39;( ?[\S]+)+(?=[ ][ ]+|\Z)&#39;, line.strip())])
            elif table_format == &#39;csv&#39;:
                cols, indices = zip(*[(c.strip(), i) for i, c in enumerate(line.strip().split(sep)) if c.strip()])
                return cols, indices
            else:
                seps = r&#39;[^&#39;+re.escape(sep)+&#39;]+&#39;
                cols, indices = zip(*[(m.group(0), m.start()) for m in re.finditer(seps, line.strip())])
            colss = []
            indicess = []
            if table_format == &#39;tex&#39;:
                i = 0
                for c in cols:
                    if &#39;multicolumn&#39; in c:
                        fields = c.split(&#39;{&#39;)
                        n = int(fields[1].strip().rstrip(&#39;}&#39;).rstrip())
                        colss.append(fields[3].strip().rstrip(&#39;}&#39;).rstrip())
                        indicess.append(i)
                        i += n
                    else:
                        colss.append(c.strip())
                        indicess.append(i)
                        i += 1
            else:
                for k, (c, i) in enumerate(zip(cols, indices)):
                    if k == 0:
                        c = c.lstrip(&#39;|&#39;)
                    if k == len(cols)-1:
                        c = c.rstrip(&#39;|&#39;)
                    cs = c.strip()
                    colss.append(cs)
                    indicess.append(i)
            return colss, indicess

        def read_data_line(line, sep, post, precd, alld, numc, exped, fixed, strf, missing):
            # read line:
            cols = []
            if sep is None:
                cols = [m.group(0) for m in re.finditer(r&#39;\S+&#39;, line.strip())]
            else:
                seps = r&#39;[^&#39;+re.escape(sep)+&#39;]+&#39;
                cols = [m.group(0).strip() for m in re.finditer(seps, line.strip())]
                cols[0] = cols[0].lstrip(&#39;|&#39;).lstrip()
                cols[-1] = cols[-1].rstrip(&#39;|&#39;).rstrip()
            cols = [c for c in cols if c not in &#39;|&#39;]
            # read columns:
            for k, c in enumerate(cols):
                c = c.strip()
                try:
                    v = float(c)
                    ad = 0
                    ve = c.split(&#39;e&#39;)
                    if len(ve) &lt;= 1:
                        exped[k] = False
                    else:
                        ad = len(ve[1])+1
                    vc = ve[0].split(&#39;.&#39;)
                    ad += len(vc[0])
                    prec = len(vc[0].lstrip(&#39;-&#39;).lstrip(&#39;+&#39;).lstrip(&#39;0&#39;)) 
                    if len(vc) == 2:
                        if numc[k] and post[k] != len(vc[1]):
                            fixed[k] = False
                        if post[k] &lt; len(vc[1]):
                            post[k] = len(vc[1])
                        ad += len(vc[1])+1
                        prec += len(vc[1].rstrip(&#39;0&#39;))
                    if precd[k] &lt; prec:
                        precd[k] = prec
                    if alld[k] &lt; ad:
                        alld[k] = ad
                    numc[k] = True
                except ValueError:
                    if c == missing:
                        v = np.nan
                    else:
                        strf[k] = True
                        if alld[k] &lt; len(c):
                            alld[k] = len(c)
                        v = c
                self.append_data(v, k)

        # initialize:
        self.data = []
        self.shape = (0, 0)
        self.header = []
        self.nsecs = 0
        self.units = []
        self.formats = []
        self.hidden = []
        self.setcol = 0
        self.addcol = 0
        # open file:
        own_file = False
        if not hasattr(fh, &#39;readline&#39;):
            fh = open(fh, &#39;r&#39;)
            own_file = True
        # read inital lines of file:
        key = []
        data = []
        target = data
        comment = False
        table_format=&#39;dat&#39;        
        for line in fh:
            line = line.rstrip()
            if line:
                if r&#39;\begin{tabular&#39; in line:
                    table_format=&#39;tex&#39;
                    target = key
                    continue
                if table_format == &#39;tex&#39;:
                    if r&#39;\end{tabular&#39; in line:
                        break
                    if r&#39;\hline&#39; in line:
                        if key:
                            target = data
                        continue
                    line = line.rstrip(r&#39;\\&#39;)
                if line[0] == &#39;#&#39;:
                    comment = True
                    table_format=&#39;dat&#39;        
                    target = key
                    line = line.lstrip(&#39;#&#39;)
                elif comment:
                    target = data
                if line[0:3] == &#39;RTH&#39;:
                    target = key
                    line = line[3:]
                    table_format=&#39;rtai&#39;
                elif line[0:3] == &#39;RTD&#39;:
                    target = data
                    line = line[3:]
                    table_format=&#39;rtai&#39;        
                if (line[0:3] == &#39;|--&#39; or line[0:3] == &#39;|:-&#39;) and \
                   (line[-3:] == &#39;--|&#39; or line[-3:] == &#39;-:|&#39;):
                    if not data and not key:
                        table_format=&#39;ascii&#39;
                        target = key
                        continue
                    elif not key:
                        table_format=&#39;md&#39;
                        key = data
                        data = []
                        target = data
                        continue
                    elif not data:
                        target = data
                        continue
                    else:
                        break
                target.append(line)
            else:
                break
            if len(data) &gt; 5:
                break
        # find column separator of data and number of columns:
        col_seps = [&#39;|&#39;, &#39;,&#39;, &#39;;&#39;, &#39;:&#39;, &#39;\t&#39;, &#39;&amp;&#39;, None]
        colstd = np.zeros(len(col_seps))
        colnum = np.zeros(len(col_seps), dtype=int)
        for k, sep in enumerate(col_seps):
            cols = []
            s = 5 if len(data) &gt;= 8 else len(data) - 3
            if s &lt; 0 or key:
                s = 0
            for line in data[s:]:
                cs = line.strip().split(sep)
                if not cs[0]:
                    cs = cs[1:]
                if cs and not cs[-1]:
                    cs = cs[:-1]
                cols.append(len(cs))
            colstd[k] = np.std(cols)
            colnum[k] = np.median(cols)
        if np.max(colnum) &lt; 2:
            sep = None
            colnum = 1
        else:
            ci = np.where(np.array(colnum)&gt;1.5)[0]
            ci = ci[np.argmin(colstd[ci])]
            sep = col_seps[ci]
            colnum = int(colnum[ci])
        # fix key:
        if not key and sep is not None and sep in &#39;,;:\t|&#39;:
            table_format = &#39;csv&#39;
        # read key:
        key_cols = []
        key_indices = []
        for line in key:
            cols, indices = read_key_line(line, sep, table_format)
            key_cols.append(cols)
            key_indices.append(indices)
        if not key_cols:
            # no obviously marked table key:
            key_num = 0
            for line in data:
                cols, indices = read_key_line(line, sep, table_format)
                numbers = 0
                for c in cols:
                    try:
                        v = float(c)
                        numbers += 1
                    except ValueError:
                        pass
                if numbers == 0:
                    key_cols.append(cols)
                    key_indices.append(indices)
                    key_num += 1
                else:
                    break
            data = data[key_num:]
        kr = len(key_cols)-1
        # check for key with column indices:
        if kr &gt;= 0:
            cols = key_cols[kr]
            numrow = True
            try:
                pv = int(cols[0])
                for c in cols[1:]:
                    v = int(c)
                    if v != pv+1:
                        numrow = False
                        break
                    pv = v
            except ValueError:
                try:
                    pv = aa2index(cols[0])
                    for c in cols[1:]:
                        v = aa2index(c)
                        if v != pv+1:
                            numrow = False
                            break
                        pv = v
                except ValueError:
                    numrow = False
            if numrow:
                kr -= 1
        # check for unit line:
        units = None
        if kr &gt; 0 and len(key_cols[kr]) == len(key_cols[kr-1]):
            units = key_cols[kr]
            kr -= 1
        # column labels:
        if kr &gt;= 0:
            if units is None:
                # units may be part of the label:
                labels = []
                units = []
                for c in key_cols[kr]:
                    if c[-1] == &#39;)&#39;:
                        lu = c[:-1].split(&#39;(&#39;)
                        if len(lu) &gt;= 2:
                            labels.append(lu[0].strip())
                            units.append(&#39;(&#39;.join(lu[1:]).strip())
                            continue
                    lu = c.split(&#39;/&#39;)
                    if len(lu) &gt;= 2:
                        labels.append(lu[0].strip())
                        units.append(&#39;/&#39;.join(lu[1:]).strip())
                    else:
                        labels.append(c)
                        units.append(&#39;&#39;)
            else:
                labels = key_cols[kr]
            indices = key_indices[kr]
            # init table columns:
            for k in range(colnum):
                self.append(labels[k], units[k], &#39;%g&#39;)
        # read in sections:
        while kr &gt; 0:
            kr -= 1
            for sec_label, sec_inx in zip(key_cols[kr], key_indices[kr]):
                col_inx = indices.index(sec_inx)
                self.header[col_inx].append(sec_label)
                if self.nsecs &lt; len(self.header[col_inx])-1:
                    self.nsecs = len(self.header[col_inx])-1
        # read data:
        post = np.zeros(colnum)
        precd = np.zeros(colnum)
        alld = np.zeros(colnum)
        numc = [False] * colnum
        exped = [True] * colnum
        fixed = [True] * colnum
        strf = [False] * colnum
        for line in data:
            read_data_line(line, sep, post, precd, alld, numc, exped, fixed, strf, missing)
        # read remaining data:
        for line in fh:
            line = line.rstrip()
            if table_format == &#39;tex&#39;:
                if r&#39;\end{tabular&#39; in line or r&#39;\hline&#39; in line:
                    break
                line = line.rstrip(r&#39;\\&#39;)
            if (line[0:3] == &#39;|--&#39; or line[0:3] == &#39;|:-&#39;) and \
                (line[-3:] == &#39;--|&#39; or line[-3:] == &#39;-:|&#39;):
                break
            if line[0:3] == &#39;RTD&#39;:
                line = line[3:]
            read_data_line(line, sep, post, precd, alld, numc, exped, fixed, strf, missing)
        # set formats:
        for k in range(len(alld)):
            if strf[k]:
                self.set_format(&#39;%%-%ds&#39; % alld[k], k)
            elif exped[k]:
                self.set_format(&#39;%%%d.%de&#39; % (alld[k], post[k]), k)
            elif fixed[k]:
                self.set_format(&#39;%%%d.%df&#39; % (alld[k], post[k]), k)
            else:
                self.set_format(&#39;%%%d.%dg&#39; % (alld[k], precd[k]), k)
        # close file:
        if own_file:
            fh.close()</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="thunderfish.tabledata.TableData.descriptions"><code class="name">var <span class="ident">descriptions</span></code></dt>
<dd>
<div class="desc"><p>dict: Decription of output formats corresponding to <code>formats</code>.</p></div>
</dd>
<dt id="thunderfish.tabledata.TableData.ext_formats"><code class="name">var <span class="ident">ext_formats</span></code></dt>
<dd>
<div class="desc"><p>dict: Mapping of file extensions to the output formats.</p></div>
</dd>
<dt id="thunderfish.tabledata.TableData.extensions"><code class="name">var <span class="ident">extensions</span></code></dt>
<dd>
<div class="desc"><p>dict: Default file extensions for the output <code>formats</code>.</p></div>
</dd>
<dt id="thunderfish.tabledata.TableData.formats"><code class="name">var <span class="ident">formats</span></code></dt>
<dd>
<div class="desc"><p>list of strings: Supported output formats.</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="thunderfish.tabledata.TableData.__call__"><code class="name flex">
<span>def <span class="ident">__call__</span></span>(<span>self, column)</span>
</code></dt>
<dd>
<div class="desc"><p>A single column of the table as a numpy array.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>column</code></strong> :&ensp;<code>None, int,</code> or <code>string</code></dt>
<dd>The column to be returned.
See self.index() for more information on how to specify a column.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>data</code></strong> :&ensp;<code>1-D array</code></dt>
<dd>Content of the specified column as a numpy array.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __call__(self, column):
    &#34;&#34;&#34;A single column of the table as a numpy array.

    Parameters
    ----------
    column: None, int, or string
        The column to be returned.
        See self.index() for more information on how to specify a column.

    Returns
    -------
    data: 1-D array
        Content of the specified column as a numpy array.
    &#34;&#34;&#34;
    c = self.index(column)
    return np.asarray(self.data[c])</code></pre>
</details>
</dd>
<dt id="thunderfish.tabledata.TableData.__contains__"><code class="name flex">
<span>def <span class="ident">__contains__</span></span>(<span>self, column)</span>
</code></dt>
<dd>
<div class="desc"><p>Check for existence of a column.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>column</code></strong> :&ensp;<code>None, int,</code> or <code>string</code></dt>
<dd>The column to be checked.
See self.index() for more information on how to specify a column.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>contains</code></strong> :&ensp;<code>bool</code></dt>
<dd>True if <code>column</code> specifies an existing column key.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __contains__(self, column):
    &#34;&#34;&#34;Check for existence of a column.

    Parameters
    ----------
    column: None, int, or string
        The column to be checked.
        See self.index() for more information on how to specify a column.

    Returns
    -------
    contains: bool
        True if `column` specifies an existing column key.
    &#34;&#34;&#34;
    return self.index(column) is not None</code></pre>
</details>
</dd>
<dt id="thunderfish.tabledata.TableData.__delitem__"><code class="name flex">
<span>def <span class="ident">__delitem__</span></span>(<span>self, key)</span>
</code></dt>
<dd>
<div class="desc"><p>Delete data elements or whole columns or rows.</p>
<h2 id="parameters">Parameters</h2>
<p>key:
First key specifies row, (optional) second one the column.
Columns can be specified by index or name,
see <code>index()</code> for details.
If all rows are selected, then the specified columns are removed from the table.
Otherwise only data values are removed.
If all columns are selected than entire rows of data values are removed.
Otherwise only data values in the specified rows are removed.</p>
<h2 id="raises">Raises</h2>
<h2 id="indexerror">Indexerror</h2>
<p>If an invalid column was specified.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __delitem__(self, key):
    &#34;&#34;&#34;Delete data elements or whole columns or rows.

    Parameters
    -----------
    key:
        First key specifies row, (optional) second one the column.
        Columns can be specified by index or name,
        see `index()` for details.
        If all rows are selected, then the specified columns are removed from the table.
        Otherwise only data values are removed.
        If all columns are selected than entire rows of data values are removed.
        Otherwise only data values in the specified rows are removed.

    Raises
    ------
    IndexError:
        If an invalid column was specified.
    &#34;&#34;&#34;
    rows, cols = self.__setupkey(key)
    if rows is None:
        return
    row_indices = np.arange(self.rows(), dtype=np.int)[rows]
    if isinstance(row_indices, np.ndarray):
        if len(row_indices) == self.rows():
            # delete whole columns:
            self.remove(cols)
        elif len(row_indices) &gt; 0:
            for r in reversed(sorted(row_indices)):
                for c in cols:
                    del self.data[c][r]
            self.shape = (self.rows(), self.columns())
    else:
        for c in cols:
            del self.data[c][row_indices]
        self.shape = (self.rows(), self.columns())</code></pre>
</details>
</dd>
<dt id="thunderfish.tabledata.TableData.__getitem__"><code class="name flex">
<span>def <span class="ident">__getitem__</span></span>(<span>self, key)</span>
</code></dt>
<dd>
<div class="desc"><p>Data elements specified by slice.</p>
<h2 id="parameters">Parameters</h2>
<p>key:
First key specifies row, (optional) second one the column.
Columns can be specified by index or name,
see <code>index()</code> for details.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>data:</code></dt>
<dd>
<ul>
<li>A single data value if a single row and a single column is specified.</li>
<li>An array of data elements if a single single column is specified.</li>
<li>A TableData object for multiple columns.</li>
<li>None if no row is selected (e.g. by a logical index that nowhere is True)</li>
</ul>
</dd>
</dl>
<h2 id="raises">Raises</h2>
<h2 id="indexerror">Indexerror</h2>
<p>If an invalid column was specified.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __getitem__(self, key):
    &#34;&#34;&#34;Data elements specified by slice.

    Parameters
    -----------
    key:
        First key specifies row, (optional) second one the column.
        Columns can be specified by index or name,
        see `index()` for details.

    Returns
    -------
    data:
        - A single data value if a single row and a single column is specified.
        - An array of data elements if a single single column is specified.
        - A TableData object for multiple columns.
        - None if no row is selected (e.g. by a logical index that nowhere is True)

    Raises
    ------
    IndexError:
        If an invalid column was specified.
    &#34;&#34;&#34;
    rows, cols = self.__setupkey(key)
    if len(cols) == 1:
        if rows is None:
            return None
        elif isinstance(rows, slice):
            return np.asarray(self.data[cols[0]][rows])
        elif isinstance(rows, (list, tuple, np.ndarray)):
            return np.asarray([self.data[cols[0]][r] for r in rows])
        else:
            return self.data[cols[0]][rows]
    else:
        data = TableData()
        sec_indices = [-1] * self.nsecs
        for c in cols:
            data.append(*self.column_head(c))
            for l in range(self.nsecs):
                s, i = self.section(c, l+1)
                if i != sec_indices[l]:
                    data.header[-1].append(s)
                    sec_indices[l] = i
            if rows is None:
                continue
            if isinstance(rows, (list, tuple, np.ndarray)):
                for r in rows:
                    data.data[-1].append(self.data[c][r])
            else:
                if isinstance(self.data[c][rows], (list, tuple, np.ndarray)):
                    data.data[-1].extend(self.data[c][rows])
                else:
                    data.data[-1].append(self.data[c][rows])
        data.nsecs = self.nsecs
        return data</code></pre>
</details>
</dd>
<dt id="thunderfish.tabledata.TableData.__iter__"><code class="name flex">
<span>def <span class="ident">__iter__</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Initialize iteration over data columns.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __iter__(self):
    &#34;&#34;&#34;Initialize iteration over data columns.
    &#34;&#34;&#34;
    self.iter_counter = -1
    return self</code></pre>
</details>
</dd>
<dt id="thunderfish.tabledata.TableData.__len__"><code class="name flex">
<span>def <span class="ident">__len__</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>The number of columns.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>columns</code></strong> :&ensp;<code>int</code></dt>
<dd>The number of columns contained in the table.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __len__(self):
    &#34;&#34;&#34;The number of columns.
    
    Returns
    -------
    columns: int
        The number of columns contained in the table.
    &#34;&#34;&#34;
    return self.columns()</code></pre>
</details>
</dd>
<dt id="thunderfish.tabledata.TableData.__next__"><code class="name flex">
<span>def <span class="ident">__next__</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Next column of data.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>data</code></strong> :&ensp;<code>list</code> of <code>values</code></dt>
<dd>Table data of next column.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __next__(self):
    &#34;&#34;&#34;Next column of data.

    Returns
    -------
    data: list of values
        Table data of next column.
    &#34;&#34;&#34;
    self.iter_counter += 1
    if self.iter_counter &gt;= self.columns():
        raise StopIteration
    else:
        return self.data[self.iter_counter]</code></pre>
</details>
</dd>
<dt id="thunderfish.tabledata.TableData.__setitem__"><code class="name flex">
<span>def <span class="ident">__setitem__</span></span>(<span>self, key, value)</span>
</code></dt>
<dd>
<div class="desc"><p>Assign values to data elements specified by slice.</p>
<h2 id="parameters">Parameters</h2>
<p>key:
First key specifies row, (optional) second one the column.
Columns can be specified by index or name,
see <code>index()</code> for details.
value: TableData, list, ndarray, float, &hellip;
Value(s) used to assing to the table elements as specified by <code>key</code>.</p>
<h2 id="raises">Raises</h2>
<h2 id="indexerror">Indexerror</h2>
<p>If an invalid column was specified.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __setitem__(self, key, value):
    &#34;&#34;&#34;Assign values to data elements specified by slice.

    Parameters
    -----------
    key:
        First key specifies row, (optional) second one the column.
        Columns can be specified by index or name,
        see `index()` for details.
    value: TableData, list, ndarray, float, ...
        Value(s) used to assing to the table elements as specified by `key`.

    Raises
    ------
    IndexError:
        If an invalid column was specified.
    &#34;&#34;&#34;
    rows, cols = self.__setupkey(key)
    if rows is None:
        return
    if isinstance(value, TableData):
        if isinstance(self.data[cols[0]][rows], (list, tuple, np.ndarray)):
            for k, c in enumerate(cols):
                self.data[c][rows] = value.data[k]
        else:
            for k, c in enumerate(cols):
                self.data[c][rows] = value.data[k][0]
    else:
        if len(cols) == 1:
            if isinstance(rows, (list, tuple, np.ndarray)):
                if len(rows) == 1:
                    self.data[cols[0]][rows[0]] = value
                elif isinstance(value, (list, tuple, np.ndarray)):
                    for k, r in enumerate(rows):
                        self.data[cols[0]][r] = value[k]
                else:
                    for r in rows:
                        self.data[cols[0]][r] = value
            elif isinstance(value, (list, tuple, np.ndarray)):
                self.data[cols[0]][rows] = value
            elif isinstance(rows, (int, np.integer)):
                self.data[cols[0]][rows] = value
            else:
                n = len(self.data[cols[0]][rows])
                if n &gt; 1:
                    self.data[cols[0]][rows] = [value]*n
                else:
                    self.data[cols[0]][rows] = value
        else:
            if isinstance(self.data[0][rows], (list, tuple, np.ndarray)):
                for k, c in enumerate(cols):
                    self.data[c][rows] = value[:,k]
            elif isinstance(value, (list, tuple, np.ndarray)):
                for k, c in enumerate(cols):
                    self.data[c][rows] = value[k]
            else:
                for k, c in enumerate(cols):
                    self.data[c][rows] = value</code></pre>
</details>
</dd>
<dt id="thunderfish.tabledata.TableData.__str__"><code class="name flex">
<span>def <span class="ident">__str__</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Write table to a string.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __str__(self):
    &#34;&#34;&#34;Write table to a string.
    &#34;&#34;&#34;
    stream = StringIO()
    self.write(stream, table_format=&#39;out&#39;)
    return stream.getvalue()</code></pre>
</details>
</dd>
<dt id="thunderfish.tabledata.TableData.append"><code class="name flex">
<span>def <span class="ident">append</span></span>(<span>self, label, unit=None, formats=None, value=None, key=None, fac=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Append column to the table.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>label</code></strong> :&ensp;<code>string</code> or <code>list</code> of <code>string</code></dt>
<dd>Optional section titles and the name of the column.</dd>
<dt><strong><code>unit</code></strong> :&ensp;<code>string</code> or <code>None</code></dt>
<dd>The unit of the column contents.</dd>
<dt><strong><code>formats</code></strong> :&ensp;<code>string</code> or <code>None</code></dt>
<dd>The C-style format string used for printing out the column content, e.g.
'%g', '%.2f', '%s', etc.
If None, the format is set to '%g'.</dd>
<dt><strong><code>value</code></strong> :&ensp;<code>None, float, int, string, etc.</code> or <code>list thereof,</code> or <code>list</code> of <code>dict</code></dt>
<dd>If not None, data for the column.</dd>
<dt><strong><code>key</code></strong> :&ensp;<code>None</code> or <code>key</code> of <code>a dictionary</code></dt>
<dd>If not None and <code>value</code> is a list of dictionaries,
extract from each dictionary in the list the value specified
by <code>key</code> and assign the resulting list as data to the column.</dd>
<dt><strong><code>fac</code></strong> :&ensp;<code>float</code></dt>
<dd>If not None, multiply the data values by this number.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>index</code></strong> :&ensp;<code>int</code></dt>
<dd>The index of the new column.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def append(self, label, unit=None, formats=None, value=None, key=None, fac=None):
    &#34;&#34;&#34;Append column to the table.

    Parameters
    ----------
    label: string or list of string
        Optional section titles and the name of the column.
    unit: string or None
        The unit of the column contents.
    formats: string or None
        The C-style format string used for printing out the column content, e.g.
        &#39;%g&#39;, &#39;%.2f&#39;, &#39;%s&#39;, etc.
        If None, the format is set to &#39;%g&#39;.
    value: None, float, int, string, etc. or list thereof, or list of dict
        If not None, data for the column.
    key: None or key of a dictionary
        If not None and `value` is a list of dictionaries,
        extract from each dictionary in the list the value specified
        by `key` and assign the resulting list as data to the column.
    fac: float
        If not None, multiply the data values by this number.

    Returns
    -------
    index: int
        The index of the new column.
    &#34;&#34;&#34;
    if self.addcol &gt;= len(self.data):
        if isinstance(label, (list, tuple, np.ndarray)):
            self.header.append(list(reversed(label)))
        else:
            self.header.append([label])
        self.formats.append(formats or &#39;%g&#39;)
        self.units.append(unit or &#39;&#39;)
        self.hidden.append(False)
        self.data.append([])
        if self.nsecs &lt; len(self.header[-1])-1:
            self.nsecs = len(self.header[-1])-1
    else:
        if isinstance(label, (list, tuple, np.ndarray)):
            self.header[self.addcol] = list(reversed(label)) + self.header[self.addcol]
        else:
            self.header[self.addcol] = [label] + self.header[self.addcol]
        self.units[self.addcol] = unit or &#39;&#39;
        self.formats[self.addcol] = formats or &#39;%g&#39;
        if self.nsecs &lt; len(self.header[self.addcol])-1:
            self.nsecs = len(self.header[self.addcol])-1
    if value is not None:
        if isinstance(value, (list, tuple, np.ndarray)):
            if key and value and isinstance(value[0], dict):
                value = [d[key] if key in d else float(&#39;nan&#39;) for d in value]
            self.data[-1].extend(value)
        else:
            self.data[-1].append(value)
    if fac:
        for k in range(len(self.data[-1])):
            self.data[-1][k] *= fac
    self.addcol = len(self.data)
    self.shape = (self.rows(), self.columns())
    return self.addcol-1</code></pre>
</details>
</dd>
<dt id="thunderfish.tabledata.TableData.append_data"><code class="name flex">
<span>def <span class="ident">append_data</span></span>(<span>self, data, column=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Append data elements to successive columns.</p>
<p>The current column is set behid the added columns.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>data</code></strong> :&ensp;<code>float, int, string, etc.</code> or <code>list thereof</code> or <code>list</code> of <code>list thereof</code></dt>
<dd>Data values to be appended to successive column.
- A single value is simply appened to the specified column of the table.
- A 1D-list of values is appended to successive columns of the table
starting with the specified column.
- The columns of a 2D-list of values (second index) are appended
to successive columns of the table starting with the specified column.</dd>
<dt><strong><code>column</code></strong> :&ensp;<code>None, int,</code> or <code>string</code></dt>
<dd>The first column to which the data should be appended.
If None, append to the current column.
See self.index() for more information on how to specify a column.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def append_data(self, data, column=None):
    &#34;&#34;&#34;Append data elements to successive columns.

    The current column is set behid the added columns.

    Parameters
    ----------
    data: float, int, string, etc. or list thereof or list of list thereof
        Data values to be appended to successive column.
        - A single value is simply appened to the specified column of the table.
        - A 1D-list of values is appended to successive columns of the table
          starting with the specified column.
        - The columns of a 2D-list of values (second index) are appended
          to successive columns of the table starting with the specified column.
    column: None, int, or string
        The first column to which the data should be appended.
        If None, append to the current column.
        See self.index() for more information on how to specify a column.
    &#34;&#34;&#34;
    column = self.index(column)
    if column is None:
        column = self.setcol
    if isinstance(data, (list, tuple, np.ndarray)):
        if isinstance(data[0], (list, tuple, np.ndarray)):
            # 2D list, rows first:
            for row in data:
                for i, val in enumerate(row):
                    self.data[column+i].append(val)
            self.setcol = column + len(data[0])
        else:
            # 1D list:
            for val in data:
                self.data[column].append(val)
                column += 1
            self.setcol = column
    else:
        # single value:
        self.data[column].append(data)
        self.setcol = column+1
    self.shape = (self.rows(), self.columns())</code></pre>
</details>
</dd>
<dt id="thunderfish.tabledata.TableData.append_data_column"><code class="name flex">
<span>def <span class="ident">append_data_column</span></span>(<span>self, data, column=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Append data elements to a column.</p>
<p>The current column is incremented by one.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>data</code></strong> :&ensp;<code>float, int, string, etc.</code> or <code>list thereof</code></dt>
<dd>Data values to be appended to a column.</dd>
<dt><strong><code>column</code></strong> :&ensp;<code>None, int,</code> or <code>string</code></dt>
<dd>The column to which the data should be appended.
If None, append to the current column.
See self.index() for more information on how to specify a column.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def append_data_column(self, data, column=None):
    &#34;&#34;&#34;Append data elements to a column.

    The current column is incremented by one.

    Parameters
    ----------
    data: float, int, string, etc. or list thereof
        Data values to be appended to a column.
    column: None, int, or string
        The column to which the data should be appended.
        If None, append to the current column.
        See self.index() for more information on how to specify a column.
    &#34;&#34;&#34;
    column = self.index(column)
    if column is None:
        column = self.setcol
    if isinstance(data, (list, tuple, np.ndarray)):
        self.data[column].extend(data)
        column += 1
        self.setcol = column
    else:
        self.data[column].append(data)
        self.setcol = column+1
    self.shape = (self.rows(), self.columns())</code></pre>
</details>
</dd>
<dt id="thunderfish.tabledata.TableData.append_section"><code class="name flex">
<span>def <span class="ident">append_section</span></span>(<span>self, label)</span>
</code></dt>
<dd>
<div class="desc"><p>Add sections to the table header.</p>
<p>Each column of the table has a header label. Columns can be
grouped into sections. Sections can be nested arbitrarily.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>label</code></strong> :&ensp;<code>string</code> or <code>list</code> of <code>string</code></dt>
<dd>The name(s) of the section(s).</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>index</code></strong> :&ensp;<code>int</code></dt>
<dd>The column index where the section was appended.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def append_section(self, label):
    &#34;&#34;&#34;Add sections to the table header.

    Each column of the table has a header label. Columns can be
    grouped into sections. Sections can be nested arbitrarily.

    Parameters
    ----------
    label: string or list of string
        The name(s) of the section(s).

    Returns
    -------
    index: int
        The column index where the section was appended.
    &#34;&#34;&#34;
    if self.addcol &gt;= len(self.data):
        if isinstance(label, (list, tuple, np.ndarray)):
            self.header.append(list(reversed(label)))
        else:
            self.header.append([label])
        self.units.append(&#39;&#39;)
        self.formats.append(&#39;&#39;)
        self.hidden.append(False)
        self.data.append([])
    else:
        if isinstance(label, (list, tuple, np.ndarray)):
            self.header[self.addcol] = list(reversed(label)) + self.header[self.addcol]
        else:
            self.header[self.addcol] = [label] + self.header[self.addcol]
    if self.nsecs &lt; len(self.header[self.addcol]):
        self.nsecs = len(self.header[self.addcol])
    self.addcol = len(self.data)-1
    self.shape = (self.rows(), self.columns())
    return self.addcol</code></pre>
</details>
</dd>
<dt id="thunderfish.tabledata.TableData.array"><code class="name flex">
<span>def <span class="ident">array</span></span>(<span>self, row=None)</span>
</code></dt>
<dd>
<div class="desc"><p>The table data as a numpy array.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>row</code></strong> :&ensp;<code>int</code> or <code>None</code></dt>
<dd>If specified, a 1D array of that row will be returned.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>data</code></strong> :&ensp;<code>2D</code> or <code>1D ndarray</code></dt>
<dd>If no row is specified, the data content of the entire table
as a 2D numpy array (rows first).
If a row is specified, a 1D array of that row.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def array(self, row=None):
    &#34;&#34;&#34;The table data as a numpy array.

    Parameters
    ----------
    row: int or None
        If specified, a 1D array of that row will be returned.

    Returns
    -------
    data: 2D or 1D ndarray
        If no row is specified, the data content of the entire table
        as a 2D numpy array (rows first).
        If a row is specified, a 1D array of that row.
    &#34;&#34;&#34;
    if row is None:
        return np.array(self.data).T
    else:
        return np.array([d[row] for d in self.data])</code></pre>
</details>
</dd>
<dt id="thunderfish.tabledata.TableData.clear_data"><code class="name flex">
<span>def <span class="ident">clear_data</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Clear content of the table but keep header.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def clear_data(self):
    &#34;&#34;&#34;Clear content of the table but keep header.
    &#34;&#34;&#34;
    for c in range(len(self.data)):
        self.data[c] = []
    self.setcol = 0
    self.shape = (self.rows(), self.columns())</code></pre>
</details>
</dd>
<dt id="thunderfish.tabledata.TableData.col"><code class="name flex">
<span>def <span class="ident">col</span></span>(<span>self, column)</span>
</code></dt>
<dd>
<div class="desc"><p>A single column of the table.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>column</code></strong> :&ensp;<code>None, int,</code> or <code>string</code></dt>
<dd>The column to be returned.
See self.index() for more information on how to specify a column.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>table</code></strong> :&ensp;<code><a title="thunderfish.tabledata.TableData" href="#thunderfish.tabledata.TableData">TableData</a></code></dt>
<dd>A TableData object with a single column.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def col(self, column):
    &#34;&#34;&#34;A single column of the table.

    Parameters
    ----------
    column: None, int, or string
        The column to be returned.
        See self.index() for more information on how to specify a column.

    Returns
    -------
    table: TableData
        A TableData object with a single column.
    &#34;&#34;&#34;
    data = TableData()
    c = self.index(column)
    data.append(*self.column_head(c))
    data.data = [self.data[c]]
    data.nsecs = 0
    return data</code></pre>
</details>
</dd>
<dt id="thunderfish.tabledata.TableData.column_head"><code class="name flex">
<span>def <span class="ident">column_head</span></span>(<span>self, column)</span>
</code></dt>
<dd>
<div class="desc"><p>The name, unit, and format of a column.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>column</code></strong> :&ensp;<code>None, int,</code> or <code>string</code></dt>
<dd>A specification of a column.
See self.index() for more information on how to specify a column.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>name</code></strong> :&ensp;<code>string</code></dt>
<dd>The column label.</dd>
<dt><strong><code>unit</code></strong> :&ensp;<code>string</code></dt>
<dd>The unit.</dd>
<dt><strong><code>format</code></strong> :&ensp;<code>string</code></dt>
<dd>The format string.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def column_head(self, column):
    &#34;&#34;&#34;The name, unit, and format of a column.

    Parameters
    ----------
    column: None, int, or string
        A specification of a column.
        See self.index() for more information on how to specify a column.

    Returns
    -------
    name: string
        The column label.
    unit: string
        The unit.
    format: string
        The format string.
    &#34;&#34;&#34;
    column = self.index(column)
    return self.header[column][0], self.units[column], self.formats[column]</code></pre>
</details>
</dd>
<dt id="thunderfish.tabledata.TableData.column_spec"><code class="name flex">
<span>def <span class="ident">column_spec</span></span>(<span>self, column)</span>
</code></dt>
<dd>
<div class="desc"><p>Full specification of a column with all its section names.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>column</code></strong> :&ensp;<code>int</code> or <code>string</code></dt>
<dd>Specifies the column.
See self.index() for more information on how to specify a column.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>s</code></strong> :&ensp;<code>string</code></dt>
<dd>Full specification of the column by all its section names and its header name.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def column_spec(self, column):
    &#34;&#34;&#34;Full specification of a column with all its section names.

    Parameters
    ----------
    column: int or string
        Specifies the column.
        See self.index() for more information on how to specify a column.

    Returns
    -------
    s: string
        Full specification of the column by all its section names and its header name.
    &#34;&#34;&#34;
    c = self.index(column)
    fh = [self.header[c][0]]
    for l in range(self.nsecs):
        fh.append(self.section(c, l+1)[0])
    return &#39;&gt;&#39;.join(reversed(fh))</code></pre>
</details>
</dd>
<dt id="thunderfish.tabledata.TableData.columns"><code class="name flex">
<span>def <span class="ident">columns</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>The number of columns.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>columns</code></strong> :&ensp;<code>int</code></dt>
<dd>The number of columns contained in the table.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def columns(self):
    &#34;&#34;&#34;The number of columns.
    
    Returns
    -------
    columns: int
        The number of columns contained in the table.
    &#34;&#34;&#34;
    return len(self.header)</code></pre>
</details>
</dd>
<dt id="thunderfish.tabledata.TableData.data_frame"><code class="name flex">
<span>def <span class="ident">data_frame</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>The table data as a pandas DataFrame.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>data</code></strong> :&ensp;<code>pandas.DataFrame</code></dt>
<dd>A pandas DataFrame of the whole table.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def data_frame(self):
    &#34;&#34;&#34;The table data as a pandas DataFrame.

    Returns
    -------
    data: pandas.DataFrame
        A pandas DataFrame of the whole table.
    &#34;&#34;&#34;
    return pd.DataFrame(self.dict())</code></pre>
</details>
</dd>
<dt id="thunderfish.tabledata.TableData.dict"><code class="name flex">
<span>def <span class="ident">dict</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>The table as a dictionary.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>table</code></strong> :&ensp;<code>dict</code></dt>
<dd>A dictionary with keys being the column headers and
values the list of data elements of the corresponding column.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def dict(self):
    &#34;&#34;&#34;The table as a dictionary.

    Returns
    -------
    table: dict
        A dictionary with keys being the column headers and
        values the list of data elements of the corresponding column.
    &#34;&#34;&#34;
    table = {k: v for k, v in self.items()}
    return table</code></pre>
</details>
</dd>
<dt id="thunderfish.tabledata.TableData.dicts"><code class="name flex">
<span>def <span class="ident">dicts</span></span>(<span>self, raw_values=True, missing='-')</span>
</code></dt>
<dd>
<div class="desc"><p>The table as a list of dictionaries.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>raw_values</code></strong> :&ensp;<code>bool</code></dt>
<dd>If True, use raw table values as values,
else format the values and add unit string.</dd>
<dt><strong><code>missing</code></strong> :&ensp;<code>string</code></dt>
<dd>String indicating non-existing data elements.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>table</code></strong> :&ensp;<code>list</code> of <code>dict</code></dt>
<dd>For each row of the table a dictionary with header as key.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def dicts(self, raw_values=True, missing=&#39;-&#39;):
    &#34;&#34;&#34;The table as a list of dictionaries.

    Parameters
    ----------
    raw_values: bool
        If True, use raw table values as values,
        else format the values and add unit string.
    missing: string
        String indicating non-existing data elements.

    Returns
    -------
    table: list of dict
        For each row of the table a dictionary with header as key.
    &#34;&#34;&#34;
    table = []
    for row in range(self.rows()):
        data = {}
        for col in range(len(self.header)):
            if raw_values:
                v = self.data[col][row];
            else:
                if isinstance(self.data[col][row], float) and m.isnan(self.data[col][row]):
                    v = missing
                else:
                    u = &#39;&#39;
                    if not self.units[col] in &#39;1-&#39; and self.units[col] != &#39;a.u.&#39;:
                        u = self.units[col]
                    v = (self.formats[col] % self.data[col][row]) + u
            data[self.header[col][0]] = v
        table.append(data)
    return table</code></pre>
</details>
</dd>
<dt id="thunderfish.tabledata.TableData.fill_data"><code class="name flex">
<span>def <span class="ident">fill_data</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Fill up all columns with missing data to have the same number of
data elements.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def fill_data(self):
    &#34;&#34;&#34;Fill up all columns with missing data to have the same number of
    data elements.
    &#34;&#34;&#34;
    # maximum rows:
    maxr = self.rows()
    # fill up:
    for c in range(len(self.data)):
        while len(self.data[c]) &lt; maxr:
            self.data[c].append(np.nan)
    self.setcol = 0
    self.shape = (self.rows(), self.columns())</code></pre>
</details>
</dd>
<dt id="thunderfish.tabledata.TableData.find_col"><code class="name flex">
<span>def <span class="ident">find_col</span></span>(<span>self, column)</span>
</code></dt>
<dd>
<div class="desc"><p>Find the start and end index of a column specification.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>column</code></strong> :&ensp;<code>None, int,</code> or <code>string</code></dt>
<dd>A specification of a column.
See self.index() for more information on how to specify a column.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>c0</code></strong> :&ensp;<code>int</code> or <code>None</code></dt>
<dd>A valid column index or None that is specified by <code>column</code>.</dd>
<dt><strong><code>c1</code></strong> :&ensp;<code>int</code> or <code>None</code></dt>
<dd>A valid column index or None of the column following the range specified
by <code>column</code>.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def find_col(self, column):
    &#34;&#34;&#34;Find the start and end index of a column specification.
    
    Parameters
    ----------
    column: None, int, or string
        A specification of a column.
        See self.index() for more information on how to specify a column.

    Returns
    -------
    c0: int or None
        A valid column index or None that is specified by `column`.
    c1: int or None
        A valid column index or None of the column following the range specified
        by `column`.
    &#34;&#34;&#34;

    def find_column_indices(ss, si, minns, maxns, c0, strict=True):
        if si &gt;= len(ss):
            return None, None, None, None
        ns0 = 0
        for ns in range(minns, maxns+1):
            nsec = maxns-ns
            if ss[si] == &#39;&#39;:
                si += 1
                continue
            for c in range(c0, len(self.header)):
                if nsec &lt; len(self.header[c]) and \
                    ( ( strict and self.header[c][nsec] == ss[si] ) or
                      ( not strict and ss[si] in self.header[c][nsec] ) ):
                    ns0 = ns
                    c0 = c
                    si += 1
                    if si &gt;= len(ss):
                        c1 = len(self.header)
                        for c in range(c0+1, len(self.header)):
                            if nsec &lt; len(self.header[c]):
                                c1 = c
                                break
                        return c0, c1, ns0, None
                    elif nsec &gt; 0:
                        break
        return None, c0, ns0, si

    if column is None:
        return None, None
    if not isinstance(column, (int, np.integer)) and column.isdigit():
        column = int(column)
    if isinstance(column, (int, np.integer)):
        if column &gt;= 0 and column &lt; len(self.header):
            return column, column+1
        else:
            return None, None
    # find column by header:
    ss = column.rstrip(&#39;&gt;&#39;).split(&#39;&gt;&#39;)
    maxns = self.nsecs
    si0 = 0
    while si0 &lt; len(ss) and ss[si0] == &#39;&#39;:
        maxns -= 1
        si0 += 1
    if maxns &lt; 0:
        maxns = 0
    c0, c1, ns, si = find_column_indices(ss, si0, 0, maxns, 0, True)
    if c0 is None and c1 is not None:
        c0, c1, ns, si = find_column_indices(ss, si, ns, maxns, c1, False)
    return c0, c1</code></pre>
</details>
</dd>
<dt id="thunderfish.tabledata.TableData.format"><code class="name flex">
<span>def <span class="ident">format</span></span>(<span>self, column)</span>
</code></dt>
<dd>
<div class="desc"><p>The format string of the column.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>column</code></strong> :&ensp;<code>None, int,</code> or <code>string</code></dt>
<dd>A specification of a column.
See self.index() for more information on how to specify a column.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>format</code></strong> :&ensp;<code>string</code></dt>
<dd>The format string.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def format(self, column):
    &#34;&#34;&#34;The format string of the column.

    Parameters
    ----------
    column: None, int, or string
        A specification of a column.
        See self.index() for more information on how to specify a column.

    Returns
    -------
    format: string
        The format string.
    &#34;&#34;&#34;
    column = self.index(column)
    return self.formats[column]</code></pre>
</details>
</dd>
<dt id="thunderfish.tabledata.TableData.hide"><code class="name flex">
<span>def <span class="ident">hide</span></span>(<span>self, column)</span>
</code></dt>
<dd>
<div class="desc"><p>Hide a column or a range of columns.</p>
<p>Hidden columns will not be printed out by the write() function.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>column</code></strong> :&ensp;<code>int</code> or <code>string</code></dt>
<dd>The column to be hidden.
See self.index() for more information on how to specify a column.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def hide(self, column):
    &#34;&#34;&#34;Hide a column or a range of columns.

    Hidden columns will not be printed out by the write() function.

    Parameters
    ----------
    column: int or string
        The column to be hidden.
        See self.index() for more information on how to specify a column.
    &#34;&#34;&#34;
    c0, c1 = self.find_col(column)
    if c0 is not None:
        for c in range(c0, c1):
            self.hidden[c] = True</code></pre>
</details>
</dd>
<dt id="thunderfish.tabledata.TableData.hide_all"><code class="name flex">
<span>def <span class="ident">hide_all</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Hide all columns.</p>
<p>Hidden columns will not be printed out by the write() function.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def hide_all(self):
    &#34;&#34;&#34;Hide all columns.

    Hidden columns will not be printed out by the write() function.
    &#34;&#34;&#34;
    for c in range(len(self.hidden)):
        self.hidden[c] = True</code></pre>
</details>
</dd>
<dt id="thunderfish.tabledata.TableData.hide_empty_columns"><code class="name flex">
<span>def <span class="ident">hide_empty_columns</span></span>(<span>self, missing='-')</span>
</code></dt>
<dd>
<div class="desc"><p>Hide all columns that do not contain data.</p>
<p>Hidden columns will not be printed out by the write() function.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>missing</code></strong> :&ensp;<code>string</code></dt>
<dd>String indicating missing data.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def hide_empty_columns(self, missing=&#39;-&#39;):
    &#34;&#34;&#34;Hide all columns that do not contain data.

    Hidden columns will not be printed out by the write() function.

    Parameters
    ----------
    missing: string
        String indicating missing data.
    &#34;&#34;&#34;
    for c in range(len(self.data)):
        # check for empty column:
        isempty = True
        for v in self.data[c]:
            if isinstance(v, float):
                if not m.isnan(v):
                    isempty = False
                    break
            else:
                if v != missing:
                    isempty = False
                    break
        if isempty:
            self.hidden[c] = True</code></pre>
</details>
</dd>
<dt id="thunderfish.tabledata.TableData.index"><code class="name flex">
<span>def <span class="ident">index</span></span>(<span>self, column)</span>
</code></dt>
<dd>
<div class="desc"><p>The index of a column.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>column</code></strong> :&ensp;<code>None, int,</code> or <code>string</code></dt>
<dd>A specification of a column.
- None: no column is specified
- int: the index of the column (first column is zero), e.g. <code>index(2)</code>.
- a string representing an integer is converted into the column index,
e.g. <code>index('2')</code>
- a string specifying a column by its header.
Header names of descending hierarchy are separated by '&gt;'.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>index</code></strong> :&ensp;<code>int</code> or <code>None</code></dt>
<dd>A valid column index or None.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def index(self, column):
    &#34;&#34;&#34;The index of a column.
    
    Parameters
    ----------
    column: None, int, or string
        A specification of a column.
        - None: no column is specified
        - int: the index of the column (first column is zero), e.g. `index(2)`.
        - a string representing an integer is converted into the column index,
          e.g. `index(&#39;2&#39;)`
        - a string specifying a column by its header.
          Header names of descending hierarchy are separated by &#39;&gt;&#39;.

    Returns
    -------
    index: int or None
        A valid column index or None.
    &#34;&#34;&#34;
    c0, c1 = self.find_col(column)
    return c0</code></pre>
</details>
</dd>
<dt id="thunderfish.tabledata.TableData.insert"><code class="name flex">
<span>def <span class="ident">insert</span></span>(<span>self, column, label, unit=None, formats=None, value=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Insert a table column at a given position.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>If no <code>value</code> is given, the inserted column is an empty list.</p>
</div>
<h2 id="parameters">Parameters</h2>
<dl>
<dt>columns int or string</dt>
<dt>Column before which to insert the new column.</dt>
<dt>Column can be specified by index or name,</dt>
<dt>see <code>index()</code> for details.</dt>
<dt><strong><code>label</code></strong> :&ensp;<code>string</code> or <code>list</code> of <code>string</code></dt>
<dd>Optional section titles and the name of the column.</dd>
<dt><strong><code>unit</code></strong> :&ensp;<code>string</code> or <code>None</code></dt>
<dd>The unit of the column contents.</dd>
<dt><strong><code>formats</code></strong> :&ensp;<code>string</code> or <code>None</code></dt>
<dd>The C-style format string used for printing out the column content, e.g.
'%g', '%.2f', '%s', etc.
If None, the format is set to '%g'.</dd>
<dt><strong><code>value</code></strong> :&ensp;<code>None, float, int, string, etc.</code> or <code>list thereof</code></dt>
<dd>If not None, data for the column.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>index</code></strong> :&ensp;<code>int</code></dt>
<dd>The index of the inserted column.</dd>
</dl>
<h2 id="raises">Raises</h2>
<h2 id="indexerror">Indexerror</h2>
<p>If an invalid column was specified.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def insert(self, column, label, unit=None, formats=None, value=None):
    &#34;&#34;&#34;Insert a table column at a given position.

    .. WARNING::
       If no `value` is given, the inserted column is an empty list.

    Parameters
    ----------
    columns int or string
        Column before which to insert the new column.
        Column can be specified by index or name,
        see `index()` for details.
    label: string or list of string
        Optional section titles and the name of the column.
    unit: string or None
        The unit of the column contents.
    formats: string or None
        The C-style format string used for printing out the column content, e.g.
        &#39;%g&#39;, &#39;%.2f&#39;, &#39;%s&#39;, etc.
        If None, the format is set to &#39;%g&#39;.
    value: None, float, int, string, etc. or list thereof
        If not None, data for the column.

    Returns
    -------
    index: int
        The index of the inserted column.
        
    Raises
    ------
    IndexError:
        If an invalid column was specified.
    &#34;&#34;&#34;
    col = self.index(column)
    if col is None:
        if isinstance(column, (int, np.integer)):
            column = &#39;%d&#39; % column
        raise IndexError(&#39;Cannot insert before non-existing column &#39; + column)
    if isinstance(label, (list, tuple, np.ndarray)):
        self.header.insert(col, list(reversed(label)))
    else:
        self.header.insert(col, [label])
    self.formats.insert(col, formats or &#39;%g&#39;)
    self.units.insert(col, unit or &#39;&#39;)
    self.hidden.insert(col, False)
    self.data.insert(col, [])
    if self.nsecs &lt; len(self.header[col])-1:
        self.nsecs = len(self.header[col])-1
    if value is not None:
        if isinstance(value, (list, tuple, np.ndarray)):
            self.data[col].extend(value)
        else:
            self.data[col].append(value)
    self.addcol = len(self.data)
    self.shape = (self.rows(), self.columns())
    return col</code></pre>
</details>
</dd>
<dt id="thunderfish.tabledata.TableData.insert_section"><code class="name flex">
<span>def <span class="ident">insert_section</span></span>(<span>self, column, section)</span>
</code></dt>
<dd>
<div class="desc"><p>Insert a section at a given position of the table header.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt>columns int or string</dt>
<dt>Column before which to insert the new section.</dt>
<dt>Column can be specified by index or name,</dt>
<dt>see <code>index()</code> for details.</dt>
<dt><strong><code>section</code></strong> :&ensp;<code>string</code></dt>
<dd>The name of the section.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>index</code></strong> :&ensp;<code>int</code></dt>
<dd>The index of the column where the section was inserted.</dd>
</dl>
<h2 id="raises">Raises</h2>
<h2 id="indexerror">Indexerror</h2>
<p>If an invalid column was specified.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def insert_section(self, column, section):
    &#34;&#34;&#34;Insert a section at a given position of the table header.

    Parameters
    ----------
    columns int or string
        Column before which to insert the new section.
        Column can be specified by index or name,
        see `index()` for details.
    section: string
        The name of the section.

    Returns
    -------
    index: int
        The index of the column where the section was inserted.
        
    Raises
    ------
    IndexError:
        If an invalid column was specified.
    &#34;&#34;&#34;
    col = self.index(column)
    if col is None:
        if isinstance(column, (int, np.integer)):
            column = &#39;%d&#39; % column
        raise IndexError(&#39;Cannot insert at non-existing column &#39; + column)
    self.header[col].append(section)
    if self.nsecs &lt; len(self.header[col])-1:
        self.nsecs = len(self.header[col])-1
    return col</code></pre>
</details>
</dd>
<dt id="thunderfish.tabledata.TableData.items"><code class="name flex">
<span>def <span class="ident">items</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Column names and corresponding data.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>items</code></strong> :&ensp;<code>list</code> of <code>tuples</code></dt>
<dd>Unique column specifications and the corresponding data.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def items(self):
    &#34;&#34;&#34;Column names and corresponding data.

    Returns
    -------
    items: list of tuples
        Unique column specifications and the corresponding data.
    &#34;&#34;&#34;
    return [(self.column_spec(c), self.data[c]) for c in range(self.columns())]</code></pre>
</details>
</dd>
<dt id="thunderfish.tabledata.TableData.key_value"><code class="name flex">
<span>def <span class="ident">key_value</span></span>(<span>self, row, col, missing='-')</span>
</code></dt>
<dd>
<div class="desc"><p>A data element returned as a key-value pair.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>row</code></strong> :&ensp;<code>int</code></dt>
<dd>Specifies the row from which the data element should be retrieved.</dd>
<dt><strong><code>col</code></strong> :&ensp;<code>None, int,</code> or <code>string</code></dt>
<dd>A specification of a column.
See self.index() for more information on how to specify a column.</dd>
<dt><strong><code>missing</code></strong> :&ensp;<code>string</code></dt>
<dd>String indicating non-existing data elements.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>key</code></strong> :&ensp;<code>string</code></dt>
<dd>Header label of the column</dd>
<dt><strong><code>value</code></strong> :&ensp;<code>string</code></dt>
<dd>A textual representation of the data element according to the format
of the column, followed by the unit of the column.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def key_value(self, row, col, missing=&#39;-&#39;):
    &#34;&#34;&#34;A data element returned as a key-value pair.

    Parameters
    ----------
    row: int
        Specifies the row from which the data element should be retrieved.
    col: None, int, or string
        A specification of a column.
        See self.index() for more information on how to specify a column.
    missing: string
        String indicating non-existing data elements.

    Returns
    -------
    key: string
        Header label of the column
    value: string
        A textual representation of the data element according to the format
        of the column, followed by the unit of the column.
    &#34;&#34;&#34;
    col = self.index(col)
    if col is None:
        return &#39;&#39;
    if isinstance(self.data[col][row], float) and m.isnan(self.data[col][row]):
        v = missing
    else:
        u = &#39;&#39;
        if not self.units[col] in &#39;1-&#39; and self.units[col] != &#39;a.u.&#39;:
            u = self.units[col]
        v = (self.formats[col] % self.data[col][row]) + u
    return self.header[col][0], v</code></pre>
</details>
</dd>
<dt id="thunderfish.tabledata.TableData.keys"><code class="name flex">
<span>def <span class="ident">keys</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>List of unique column keys for all available columns.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>keys</code></strong> :&ensp;<code>list</code> of <code>strings</code></dt>
<dd>List of unique column specifications.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def keys(self):
    &#34;&#34;&#34;List of unique column keys for all available columns.

    Returns
    -------
    keys: list of strings
        List of unique column specifications.
    &#34;&#34;&#34;
    return [self.column_spec(c) for c in range(self.columns())]</code></pre>
</details>
</dd>
<dt id="thunderfish.tabledata.TableData.label"><code class="name flex">
<span>def <span class="ident">label</span></span>(<span>self, column)</span>
</code></dt>
<dd>
<div class="desc"><p>The name of a column.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>column</code></strong> :&ensp;<code>None, int,</code> or <code>string</code></dt>
<dd>A specification of a column.
See self.index() for more information on how to specify a column.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>name</code></strong> :&ensp;<code>string</code></dt>
<dd>The column label.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def label(self, column):
    &#34;&#34;&#34;The name of a column.

    Parameters
    ----------
    column: None, int, or string
        A specification of a column.
        See self.index() for more information on how to specify a column.

    Returns
    -------
    name: string
        The column label.
    &#34;&#34;&#34;
    column = self.index(column)
    return self.header[column][0]</code></pre>
</details>
</dd>
<dt id="thunderfish.tabledata.TableData.load"><code class="name flex">
<span>def <span class="ident">load</span></span>(<span>self, fh, missing='-')</span>
</code></dt>
<dd>
<div class="desc"><p>Load table from file or stream.</p>
<p>File type and properties are automatically inferred.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>fh</code></strong> :&ensp;<code>filename</code> or <code>stream</code></dt>
<dd>If not a stream, the file with name <code>fh</code> is opened for reading.</dd>
<dt><strong><code>missing</code></strong> :&ensp;<code>string</code></dt>
<dd>Missing data are indicated by this string.</dd>
</dl>
<h2 id="raises">Raises</h2>
<h2 id="filenotfounderror">Filenotfounderror</h2>
<p>If <code>fh</code> is a path that does not exist.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def load(self, fh, missing=&#39;-&#39;):
    &#34;&#34;&#34;Load table from file or stream.

    File type and properties are automatically inferred.

    Parameters
    ----------
    fh: filename or stream
        If not a stream, the file with name `fh` is opened for reading.
    missing: string
        Missing data are indicated by this string.

    Raises
    ------
    FileNotFoundError:
        If `fh` is a path that does not exist.
    &#34;&#34;&#34;

    def read_key_line(line, sep, table_format):
        if sep is None:
            cols, indices = zip(*[(m.group(0), m.start()) for m in re.finditer(r&#39;( ?[\S]+)+(?=[ ][ ]+|\Z)&#39;, line.strip())])
        elif table_format == &#39;csv&#39;:
            cols, indices = zip(*[(c.strip(), i) for i, c in enumerate(line.strip().split(sep)) if c.strip()])
            return cols, indices
        else:
            seps = r&#39;[^&#39;+re.escape(sep)+&#39;]+&#39;
            cols, indices = zip(*[(m.group(0), m.start()) for m in re.finditer(seps, line.strip())])
        colss = []
        indicess = []
        if table_format == &#39;tex&#39;:
            i = 0
            for c in cols:
                if &#39;multicolumn&#39; in c:
                    fields = c.split(&#39;{&#39;)
                    n = int(fields[1].strip().rstrip(&#39;}&#39;).rstrip())
                    colss.append(fields[3].strip().rstrip(&#39;}&#39;).rstrip())
                    indicess.append(i)
                    i += n
                else:
                    colss.append(c.strip())
                    indicess.append(i)
                    i += 1
        else:
            for k, (c, i) in enumerate(zip(cols, indices)):
                if k == 0:
                    c = c.lstrip(&#39;|&#39;)
                if k == len(cols)-1:
                    c = c.rstrip(&#39;|&#39;)
                cs = c.strip()
                colss.append(cs)
                indicess.append(i)
        return colss, indicess

    def read_data_line(line, sep, post, precd, alld, numc, exped, fixed, strf, missing):
        # read line:
        cols = []
        if sep is None:
            cols = [m.group(0) for m in re.finditer(r&#39;\S+&#39;, line.strip())]
        else:
            seps = r&#39;[^&#39;+re.escape(sep)+&#39;]+&#39;
            cols = [m.group(0).strip() for m in re.finditer(seps, line.strip())]
            cols[0] = cols[0].lstrip(&#39;|&#39;).lstrip()
            cols[-1] = cols[-1].rstrip(&#39;|&#39;).rstrip()
        cols = [c for c in cols if c not in &#39;|&#39;]
        # read columns:
        for k, c in enumerate(cols):
            c = c.strip()
            try:
                v = float(c)
                ad = 0
                ve = c.split(&#39;e&#39;)
                if len(ve) &lt;= 1:
                    exped[k] = False
                else:
                    ad = len(ve[1])+1
                vc = ve[0].split(&#39;.&#39;)
                ad += len(vc[0])
                prec = len(vc[0].lstrip(&#39;-&#39;).lstrip(&#39;+&#39;).lstrip(&#39;0&#39;)) 
                if len(vc) == 2:
                    if numc[k] and post[k] != len(vc[1]):
                        fixed[k] = False
                    if post[k] &lt; len(vc[1]):
                        post[k] = len(vc[1])
                    ad += len(vc[1])+1
                    prec += len(vc[1].rstrip(&#39;0&#39;))
                if precd[k] &lt; prec:
                    precd[k] = prec
                if alld[k] &lt; ad:
                    alld[k] = ad
                numc[k] = True
            except ValueError:
                if c == missing:
                    v = np.nan
                else:
                    strf[k] = True
                    if alld[k] &lt; len(c):
                        alld[k] = len(c)
                    v = c
            self.append_data(v, k)

    # initialize:
    self.data = []
    self.shape = (0, 0)
    self.header = []
    self.nsecs = 0
    self.units = []
    self.formats = []
    self.hidden = []
    self.setcol = 0
    self.addcol = 0
    # open file:
    own_file = False
    if not hasattr(fh, &#39;readline&#39;):
        fh = open(fh, &#39;r&#39;)
        own_file = True
    # read inital lines of file:
    key = []
    data = []
    target = data
    comment = False
    table_format=&#39;dat&#39;        
    for line in fh:
        line = line.rstrip()
        if line:
            if r&#39;\begin{tabular&#39; in line:
                table_format=&#39;tex&#39;
                target = key
                continue
            if table_format == &#39;tex&#39;:
                if r&#39;\end{tabular&#39; in line:
                    break
                if r&#39;\hline&#39; in line:
                    if key:
                        target = data
                    continue
                line = line.rstrip(r&#39;\\&#39;)
            if line[0] == &#39;#&#39;:
                comment = True
                table_format=&#39;dat&#39;        
                target = key
                line = line.lstrip(&#39;#&#39;)
            elif comment:
                target = data
            if line[0:3] == &#39;RTH&#39;:
                target = key
                line = line[3:]
                table_format=&#39;rtai&#39;
            elif line[0:3] == &#39;RTD&#39;:
                target = data
                line = line[3:]
                table_format=&#39;rtai&#39;        
            if (line[0:3] == &#39;|--&#39; or line[0:3] == &#39;|:-&#39;) and \
               (line[-3:] == &#39;--|&#39; or line[-3:] == &#39;-:|&#39;):
                if not data and not key:
                    table_format=&#39;ascii&#39;
                    target = key
                    continue
                elif not key:
                    table_format=&#39;md&#39;
                    key = data
                    data = []
                    target = data
                    continue
                elif not data:
                    target = data
                    continue
                else:
                    break
            target.append(line)
        else:
            break
        if len(data) &gt; 5:
            break
    # find column separator of data and number of columns:
    col_seps = [&#39;|&#39;, &#39;,&#39;, &#39;;&#39;, &#39;:&#39;, &#39;\t&#39;, &#39;&amp;&#39;, None]
    colstd = np.zeros(len(col_seps))
    colnum = np.zeros(len(col_seps), dtype=int)
    for k, sep in enumerate(col_seps):
        cols = []
        s = 5 if len(data) &gt;= 8 else len(data) - 3
        if s &lt; 0 or key:
            s = 0
        for line in data[s:]:
            cs = line.strip().split(sep)
            if not cs[0]:
                cs = cs[1:]
            if cs and not cs[-1]:
                cs = cs[:-1]
            cols.append(len(cs))
        colstd[k] = np.std(cols)
        colnum[k] = np.median(cols)
    if np.max(colnum) &lt; 2:
        sep = None
        colnum = 1
    else:
        ci = np.where(np.array(colnum)&gt;1.5)[0]
        ci = ci[np.argmin(colstd[ci])]
        sep = col_seps[ci]
        colnum = int(colnum[ci])
    # fix key:
    if not key and sep is not None and sep in &#39;,;:\t|&#39;:
        table_format = &#39;csv&#39;
    # read key:
    key_cols = []
    key_indices = []
    for line in key:
        cols, indices = read_key_line(line, sep, table_format)
        key_cols.append(cols)
        key_indices.append(indices)
    if not key_cols:
        # no obviously marked table key:
        key_num = 0
        for line in data:
            cols, indices = read_key_line(line, sep, table_format)
            numbers = 0
            for c in cols:
                try:
                    v = float(c)
                    numbers += 1
                except ValueError:
                    pass
            if numbers == 0:
                key_cols.append(cols)
                key_indices.append(indices)
                key_num += 1
            else:
                break
        data = data[key_num:]
    kr = len(key_cols)-1
    # check for key with column indices:
    if kr &gt;= 0:
        cols = key_cols[kr]
        numrow = True
        try:
            pv = int(cols[0])
            for c in cols[1:]:
                v = int(c)
                if v != pv+1:
                    numrow = False
                    break
                pv = v
        except ValueError:
            try:
                pv = aa2index(cols[0])
                for c in cols[1:]:
                    v = aa2index(c)
                    if v != pv+1:
                        numrow = False
                        break
                    pv = v
            except ValueError:
                numrow = False
        if numrow:
            kr -= 1
    # check for unit line:
    units = None
    if kr &gt; 0 and len(key_cols[kr]) == len(key_cols[kr-1]):
        units = key_cols[kr]
        kr -= 1
    # column labels:
    if kr &gt;= 0:
        if units is None:
            # units may be part of the label:
            labels = []
            units = []
            for c in key_cols[kr]:
                if c[-1] == &#39;)&#39;:
                    lu = c[:-1].split(&#39;(&#39;)
                    if len(lu) &gt;= 2:
                        labels.append(lu[0].strip())
                        units.append(&#39;(&#39;.join(lu[1:]).strip())
                        continue
                lu = c.split(&#39;/&#39;)
                if len(lu) &gt;= 2:
                    labels.append(lu[0].strip())
                    units.append(&#39;/&#39;.join(lu[1:]).strip())
                else:
                    labels.append(c)
                    units.append(&#39;&#39;)
        else:
            labels = key_cols[kr]
        indices = key_indices[kr]
        # init table columns:
        for k in range(colnum):
            self.append(labels[k], units[k], &#39;%g&#39;)
    # read in sections:
    while kr &gt; 0:
        kr -= 1
        for sec_label, sec_inx in zip(key_cols[kr], key_indices[kr]):
            col_inx = indices.index(sec_inx)
            self.header[col_inx].append(sec_label)
            if self.nsecs &lt; len(self.header[col_inx])-1:
                self.nsecs = len(self.header[col_inx])-1
    # read data:
    post = np.zeros(colnum)
    precd = np.zeros(colnum)
    alld = np.zeros(colnum)
    numc = [False] * colnum
    exped = [True] * colnum
    fixed = [True] * colnum
    strf = [False] * colnum
    for line in data:
        read_data_line(line, sep, post, precd, alld, numc, exped, fixed, strf, missing)
    # read remaining data:
    for line in fh:
        line = line.rstrip()
        if table_format == &#39;tex&#39;:
            if r&#39;\end{tabular&#39; in line or r&#39;\hline&#39; in line:
                break
            line = line.rstrip(r&#39;\\&#39;)
        if (line[0:3] == &#39;|--&#39; or line[0:3] == &#39;|:-&#39;) and \
            (line[-3:] == &#39;--|&#39; or line[-3:] == &#39;-:|&#39;):
            break
        if line[0:3] == &#39;RTD&#39;:
            line = line[3:]
        read_data_line(line, sep, post, precd, alld, numc, exped, fixed, strf, missing)
    # set formats:
    for k in range(len(alld)):
        if strf[k]:
            self.set_format(&#39;%%-%ds&#39; % alld[k], k)
        elif exped[k]:
            self.set_format(&#39;%%%d.%de&#39; % (alld[k], post[k]), k)
        elif fixed[k]:
            self.set_format(&#39;%%%d.%df&#39; % (alld[k], post[k]), k)
        else:
            self.set_format(&#39;%%%d.%dg&#39; % (alld[k], precd[k]), k)
    # close file:
    if own_file:
        fh.close()</code></pre>
</details>
</dd>
<dt id="thunderfish.tabledata.TableData.next"><code class="name flex">
<span>def <span class="ident">next</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Return next data columns.
(python2 syntax)</p>
<h2 id="see-also">See also:</h2>
<p><code>__next__()</code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def next(self):
    &#34;&#34;&#34;Return next data columns.  (python2 syntax)

    See also:
    ---------
    `__next__()`
    &#34;&#34;&#34;
    return self.__next__()</code></pre>
</details>
</dd>
<dt id="thunderfish.tabledata.TableData.remove"><code class="name flex">
<span>def <span class="ident">remove</span></span>(<span>self, columns)</span>
</code></dt>
<dd>
<div class="desc"><p>Remove columns from the table.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>columns</code></strong> :&ensp;<code>int</code> or <code>string</code> or <code>list</code> of <code>int</code> or <code>string</code></dt>
<dd>Columns can be specified by index or name,
see <code>index()</code> for details.</dd>
</dl>
<h2 id="raises">Raises</h2>
<h2 id="indexerror">Indexerror</h2>
<p>If an invalid column was specified.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def remove(self, columns):
    &#34;&#34;&#34;Remove columns from the table.

    Parameters
    -----------
    columns: int or string or list of int or string
        Columns can be specified by index or name,
        see `index()` for details.

    Raises
    ------
    IndexError:
        If an invalid column was specified.
    &#34;&#34;&#34;
    # fix columns:
    if not isinstance(columns, (list, tuple, np.ndarray)):
        columns = [ columns ]
    if not columns:
        return
    # remove:
    for col in columns:
        c = self.index(col)
        if c is None:
            if isinstance(col, (int, np.integer)):
                col = &#39;%d&#39; % col
            raise IndexError(&#39;Cannot remove non-existing column &#39; + col)
            continue
        if c+1 &lt; len(self.header):
            self.header[c+1].extend(self.header[c][len(self.header[c+1]):])
        del self.header[c]
        del self.units[c]
        del self.formats[c]
        del self.hidden[c]
        del self.data[c]
    if self.setcol &gt; len(self.data):
        self.setcol = len(self.data)
    self.shape = (self.rows(), self.columns())</code></pre>
</details>
</dd>
<dt id="thunderfish.tabledata.TableData.row"><code class="name flex">
<span>def <span class="ident">row</span></span>(<span>self, index)</span>
</code></dt>
<dd>
<div class="desc"><p>A single row of the table.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>index</code></strong> :&ensp;<code>int</code></dt>
<dd>The index of the row to be returned.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>data</code></strong> :&ensp;<code><a title="thunderfish.tabledata.TableData" href="#thunderfish.tabledata.TableData">TableData</a></code></dt>
<dd>A TableData object with a single row.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def row(self, index):
    &#34;&#34;&#34;A single row of the table.

    Parameters
    ----------
    index: int
        The index of the row to be returned.

    Returns
    -------
    data: TableData
        A TableData object with a single row.
    &#34;&#34;&#34;
    data = TableData()
    sec_indices = [-1] * self.nsecs
    for c in range(self.columns()):
        data.append(*self.column_head(c))
        for l in range(self.nsecs):
            s, i = self.section(c, l+1)
            if i != sec_indices[l]:
                data.header[-1].append(s)
                sec_indices[l] = i
        data.data[-1] = [self.data[c][index]]
    data.nsecs = self.nsecs
    return data</code></pre>
</details>
</dd>
<dt id="thunderfish.tabledata.TableData.row_dict"><code class="name flex">
<span>def <span class="ident">row_dict</span></span>(<span>self, index)</span>
</code></dt>
<dd>
<div class="desc"><p>A single row of the table.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>index</code></strong> :&ensp;<code>int</code></dt>
<dd>The index of the row to be returned.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>data</code></strong> :&ensp;<code>dict</code></dt>
<dd>A dictionary with column header as key and corresponding data value of row <code>index</code>
as value.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def row_dict(self, index):
    &#34;&#34;&#34;A single row of the table.

    Parameters
    ----------
    index: int
        The index of the row to be returned.

    Returns
    -------
    data: dict
        A dictionary with column header as key and corresponding data value of row `index`
        as value.
    &#34;&#34;&#34;
    data = {}
    for c in range(self.columns()):
        data[self.label(c)] = self.data[c][index]
    return data</code></pre>
</details>
</dd>
<dt id="thunderfish.tabledata.TableData.rows"><code class="name flex">
<span>def <span class="ident">rows</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>The number of rows.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>rows</code></strong> :&ensp;<code>int</code></dt>
<dd>The number of rows contained in the table.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def rows(self):
    &#34;&#34;&#34;The number of rows.
    
    Returns
    -------
    rows: int
        The number of rows contained in the table.
    &#34;&#34;&#34;
    return max(map(len, self.data)) if self.data else 0</code></pre>
</details>
</dd>
<dt id="thunderfish.tabledata.TableData.section"><code class="name flex">
<span>def <span class="ident">section</span></span>(<span>self, column, level)</span>
</code></dt>
<dd>
<div class="desc"><p>The section name of a specified column.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>column</code></strong> :&ensp;<code>None, int,</code> or <code>string</code></dt>
<dd>A specification of a column.
See self.index() for more information on how to specify a column.</dd>
<dt><strong><code>level</code></strong> :&ensp;<code>int</code></dt>
<dd>The level of the section to be returned. The column label itself is level=0.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>name</code></strong> :&ensp;<code>string</code></dt>
<dd>The name of the section at the specified level containing the column.</dd>
<dt><strong><code>index</code></strong> :&ensp;<code>int</code></dt>
<dd>The column index that contains this section (equal or smaller thant <code>column</code>).</dd>
</dl>
<h2 id="raises">Raises</h2>
<h2 id="indexerror">Indexerror</h2>
<p>If <code>level</code> exceeds the maximum possible level.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def section(self, column, level):
    &#34;&#34;&#34;The section name of a specified column.

    Parameters
    ----------
    column: None, int, or string
        A specification of a column.
        See self.index() for more information on how to specify a column.
    level: int
        The level of the section to be returned. The column label itself is level=0.

    Returns
    -------
    name: string
        The name of the section at the specified level containing the column.
    index: int
        The column index that contains this section (equal or smaller thant `column`).

    Raises
    ------
    IndexError:
        If `level` exceeds the maximum possible level.
    &#34;&#34;&#34;
    if level &lt; 0 or level &gt; self.nsecs:
        raise IndexError(&#39;Invalid section level&#39;)
    column = self.index(column)
    while len(self.header[column]) &lt;= level:
        column -= 1
    return self.header[column][level], column</code></pre>
</details>
</dd>
<dt id="thunderfish.tabledata.TableData.set_column"><code class="name flex">
<span>def <span class="ident">set_column</span></span>(<span>self, column)</span>
</code></dt>
<dd>
<div class="desc"><p>Set the column where to add data.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>column</code></strong> :&ensp;<code>int</code> or <code>string</code></dt>
<dd>The column to which data elements should be appended.
See self.index() for more information on how to specify a column.</dd>
</dl>
<h2 id="raises">Raises</h2>
<h2 id="indexerror">Indexerror</h2>
<p>If an invalid column was specified.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_column(self, column):
    &#34;&#34;&#34;Set the column where to add data.

    Parameters
    ----------
    column: int or string
        The column to which data elements should be appended.
        See self.index() for more information on how to specify a column.

    Raises
    ------
    IndexError:
        If an invalid column was specified.
    &#34;&#34;&#34;
    col = self.index(column)
    if col is None:
        if isinstance(column, (int, np.integer)):
            column = &#39;%d&#39; % column
        raise IndexError(&#39;column &#39; + column + &#39; not found or invalid&#39;)
    self.setcol = col
    return col</code></pre>
</details>
</dd>
<dt id="thunderfish.tabledata.TableData.set_format"><code class="name flex">
<span>def <span class="ident">set_format</span></span>(<span>self, format, column)</span>
</code></dt>
<dd>
<div class="desc"><p>Set the format string of a column.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>format</code></strong> :&ensp;<code>string</code></dt>
<dd>The new format string to be used for the column.</dd>
<dt><strong><code>column</code></strong> :&ensp;<code>None, int,</code> or <code>string</code></dt>
<dd>A specification of a column.
See self.index() for more information on how to specify a column.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_format(self, format, column):
    &#34;&#34;&#34;Set the format string of a column.

    Parameters
    ----------
    format: string
        The new format string to be used for the column.
    column: None, int, or string
        A specification of a column.
        See self.index() for more information on how to specify a column.
    &#34;&#34;&#34;
    column = self.index(column)
    self.formats[column] = format
    return column</code></pre>
</details>
</dd>
<dt id="thunderfish.tabledata.TableData.set_formats"><code class="name flex">
<span>def <span class="ident">set_formats</span></span>(<span>self, formats)</span>
</code></dt>
<dd>
<div class="desc"><p>Set the format strings of all columns.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>formats</code></strong> :&ensp;<code>string</code> or <code>list</code> of <code>string</code></dt>
<dd>The new format strings to be used.
If only a single format is specified,
then all columns get the same format.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_formats(self, formats):
    &#34;&#34;&#34;Set the format strings of all columns.

    Parameters
    ----------
    formats: string or list of string
        The new format strings to be used.
        If only a single format is specified,
        then all columns get the same format.
    &#34;&#34;&#34;
    if isinstance(formats, (list, tuple, np.ndarray)):
        for c, f in enumerate(formats):
            self.formats[c] = f or &#39;%g&#39;
    else:
        for c in range(len(self.formats)):
            self.formats[c] = formats or &#39;%g&#39;</code></pre>
</details>
</dd>
<dt id="thunderfish.tabledata.TableData.set_label"><code class="name flex">
<span>def <span class="ident">set_label</span></span>(<span>self, label, column)</span>
</code></dt>
<dd>
<div class="desc"><p>Set the name of a column.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>label</code></strong> :&ensp;<code>string</code></dt>
<dd>The new name to be used for the column.</dd>
<dt><strong><code>column</code></strong> :&ensp;<code>None, int,</code> or <code>string</code></dt>
<dd>A specification of a column.
See self.index() for more information on how to specify a column.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_label(self, label, column):
    &#34;&#34;&#34;Set the name of a column.

    Parameters
    ----------
    label: string
        The new name to be used for the column.
    column: None, int, or string
        A specification of a column.
        See self.index() for more information on how to specify a column.
    &#34;&#34;&#34;        
    column = self.index(column)
    self.header[column][0] = label
    return column</code></pre>
</details>
</dd>
<dt id="thunderfish.tabledata.TableData.set_section"><code class="name flex">
<span>def <span class="ident">set_section</span></span>(<span>self, label, column, level)</span>
</code></dt>
<dd>
<div class="desc"><p>Set a section name.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>label</code></strong> :&ensp;<code>string</code></dt>
<dd>The new name to be used for the section.</dd>
<dt><strong><code>column</code></strong> :&ensp;<code>None, int,</code> or <code>string</code></dt>
<dd>A specification of a column.
See self.index() for more information on how to specify a column.</dd>
<dt><strong><code>level</code></strong> :&ensp;<code>int</code></dt>
<dd>The level of the section to be set. The column label itself is level=0.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_section(self, label, column, level):
    &#34;&#34;&#34;Set a section name.

    Parameters
    ----------
    label: string
        The new name to be used for the section.
    column: None, int, or string
        A specification of a column.
        See self.index() for more information on how to specify a column.
    level: int
        The level of the section to be set. The column label itself is level=0.
    &#34;&#34;&#34;
    column = self.index(column)
    self.header[column][level] = label
    return column</code></pre>
</details>
</dd>
<dt id="thunderfish.tabledata.TableData.set_unit"><code class="name flex">
<span>def <span class="ident">set_unit</span></span>(<span>self, unit, column)</span>
</code></dt>
<dd>
<div class="desc"><p>Set the unit of a column.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>unit</code></strong> :&ensp;<code>string</code></dt>
<dd>The new unit to be used for the column.</dd>
<dt><strong><code>column</code></strong> :&ensp;<code>None, int,</code> or <code>string</code></dt>
<dd>A specification of a column.
See self.index() for more information on how to specify a column.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_unit(self, unit, column):
    &#34;&#34;&#34;Set the unit of a column.

    Parameters
    ----------
    unit: string
        The new unit to be used for the column.
    column: None, int, or string
        A specification of a column.
        See self.index() for more information on how to specify a column.
    &#34;&#34;&#34;
    column = self.index(column)
    self.units[column] = unit
    return column</code></pre>
</details>
</dd>
<dt id="thunderfish.tabledata.TableData.set_units"><code class="name flex">
<span>def <span class="ident">set_units</span></span>(<span>self, units)</span>
</code></dt>
<dd>
<div class="desc"><p>Set the units of all columns.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>units</code></strong> :&ensp;<code>list</code> of <code>string</code></dt>
<dd>The new units to be used.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_units(self, units):
    &#34;&#34;&#34;Set the units of all columns.

    Parameters
    ----------
    units: list of string
        The new units to be used.
    &#34;&#34;&#34;
    for c, u in enumerate(units):
        self.units[c] = u</code></pre>
</details>
</dd>
<dt id="thunderfish.tabledata.TableData.show"><code class="name flex">
<span>def <span class="ident">show</span></span>(<span>self, column)</span>
</code></dt>
<dd>
<div class="desc"><p>Show a column or a range of columns.</p>
<p>Undoes hiding of a column.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>column</code></strong> :&ensp;<code>int</code> or <code>string</code></dt>
<dd>The column to be shown.
See self.index() for more information on how to specify a column.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def show(self, column):
    &#34;&#34;&#34;Show a column or a range of columns.

    Undoes hiding of a column.

    Parameters
    ----------
    column: int or string
        The column to be shown.
        See self.index() for more information on how to specify a column.
    &#34;&#34;&#34;
    c0, c1 = self.find_col(column)
    if c0 is not None:
        for c in range(c0, c1):
            self.hidden[c] = False</code></pre>
</details>
</dd>
<dt id="thunderfish.tabledata.TableData.sort"><code class="name flex">
<span>def <span class="ident">sort</span></span>(<span>self, columns, reverse=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Sort the table rows in place.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>columns</code></strong> :&ensp;<code>int</code> or <code>string</code> or <code>list</code> of <code>int</code> or <code>string</code></dt>
<dd>A column specifier or a list of column specifiers of the columns
to be sorted.</dd>
<dt><strong><code>reverse</code></strong> :&ensp;<code>boolean</code></dt>
<dd>If <code>True</code> sort in descending order.</dd>
</dl>
<h2 id="raises">Raises</h2>
<h2 id="indexerror">Indexerror</h2>
<p>If an invalid column was specified.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sort(self, columns, reverse=False):
    &#34;&#34;&#34;Sort the table rows in place.

    Parameters
    ----------
    columns: int or string or list of int or string
        A column specifier or a list of column specifiers of the columns
        to be sorted.
    reverse: boolean
        If `True` sort in descending order.

    Raises
    ------
    IndexError:
        If an invalid column was specified.
    &#34;&#34;&#34;
    # fix columns:
    if not isinstance(columns, (list, tuple, np.ndarray)):
        columns = [ columns ]
    if not columns:
        return
    cols = []
    for col in columns:
        c = self.index(col)
        if c is None:
            if isinstance(col, (int, np.integer)):
                col = &#39;%d&#39; % col
            raise IndexError(&#39;sort column &#39; + col + &#39; not found&#39;)
            continue
        cols.append(c)
    # get sorted row indices:
    row_inx = range(self.rows())
    row_inx = sorted(row_inx, key=lambda x : [float(&#39;-inf&#39;) if self.data[c][x] is np.nan \
                     or self.data[c][x] != self.data[c][x] \
                     else self.data[c][x] for c in cols], reverse=reverse)
    # sort table according to indices:
    for c in range(self.columns()):
        self.data[c] = [self.data[c][r] for r in row_inx]</code></pre>
</details>
</dd>
<dt id="thunderfish.tabledata.TableData.statistics"><code class="name flex">
<span>def <span class="ident">statistics</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Descriptive statistics of each column.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def statistics(self):
    &#34;&#34;&#34;Descriptive statistics of each column.
    &#34;&#34;&#34;
    ds = TableData()
    if self.nsecs &gt; 0:
        ds.append_section(&#39;statistics&#39;)
        for l in range(1,self.nsecs):
            ds.append_section(&#39;-&#39;)
        ds.append(&#39;-&#39;, &#39;-&#39;, &#39;%-10s&#39;)
    else:
        ds.append(&#39;statistics&#39;, &#39;-&#39;, &#39;%-10s&#39;)
    ds.append_data(&#39;mean&#39;, 0)
    ds.append_data(&#39;std&#39;, 0)
    ds.append_data(&#39;min&#39;, 0)
    ds.append_data(&#39;quartile1&#39;, 0)
    ds.append_data(&#39;median&#39;, 0)
    ds.append_data(&#39;quartile3&#39;, 0)
    ds.append_data(&#39;max&#39;, 0)
    ds.append_data(&#39;count&#39;, 0)
    dc = 1
    for c in range(self.columns()):
        if len(self.data[c]) &gt; 0 and isinstance(self.data[c][0], (float, int)):
            ds.hidden.append(False)
            ds.header.append(self.header[c])
            ds.units.append(self.units[c])
            # integer data still make floating point statistics:
            if isinstance(self.data[c][0], float):
                f = self.formats[c]
                i0 = f.find(&#39;.&#39;)
                if i0 &gt; 0:
                    p = int(f[i0+1:-1])
                    if p &lt;= 0:
                        f = &#39;%.1f&#39;
                ds.formats.append(f)
            else:
                ds.formats.append(&#39;%.1f&#39;)
            # remove nans:
            data = np.asarray(self.data[c], np.float)
            data = data[np.isfinite(data)]
            # compute statistics:
            ds.data.append([])
            ds.append_data(np.mean(data), dc)
            ds.append_data(np.std(data), dc)
            ds.append_data(np.min(data), dc)
            q1, m, q3 = np.percentile(data, [25., 50., 75.])
            ds.append_data(q1, dc)
            ds.append_data(m, dc)
            ds.append_data(q3, dc)
            ds.append_data(np.max(data), dc)
            ds.append_data(len(data), dc)
            dc += 1
    ds.nsecs = self.nsecs
    ds.shape = (ds.rows(), ds.columns())
    return ds</code></pre>
</details>
</dd>
<dt id="thunderfish.tabledata.TableData.table_header"><code class="name flex">
<span>def <span class="ident">table_header</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>The header of the table without content.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>data</code></strong> :&ensp;<code><a title="thunderfish.tabledata.TableData" href="#thunderfish.tabledata.TableData">TableData</a></code></dt>
<dd>A TableData object with the same header but empty data.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def table_header(self):
    &#34;&#34;&#34;The header of the table without content.

    Returns
    -------
    data: TableData
        A TableData object with the same header but empty data.
    &#34;&#34;&#34;
    data = TableData()
    sec_indices = [-1] * self.nsecs
    for c in range(self.columns()):
        data.append(*self.column_head(c))
        for l in range(self.nsecs):
            s, i = self.section(c, l+1)
            if i != sec_indices[l]:
                data.header[-1].append(s)
                sec_indices[l] = i
    data.nsecs = self.nsecs
    return data</code></pre>
</details>
</dd>
<dt id="thunderfish.tabledata.TableData.unit"><code class="name flex">
<span>def <span class="ident">unit</span></span>(<span>self, column)</span>
</code></dt>
<dd>
<div class="desc"><p>The unit of a column.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>column</code></strong> :&ensp;<code>None, int,</code> or <code>string</code></dt>
<dd>A specification of a column.
See self.index() for more information on how to specify a column.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>unit</code></strong> :&ensp;<code>string</code></dt>
<dd>The unit.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def unit(self, column):
    &#34;&#34;&#34;The unit of a column.

    Parameters
    ----------
    column: None, int, or string
        A specification of a column.
        See self.index() for more information on how to specify a column.

    Returns
    -------
    unit: string
        The unit.
    &#34;&#34;&#34;
    column = self.index(column)
    return self.units[column]</code></pre>
</details>
</dd>
<dt id="thunderfish.tabledata.TableData.values"><code class="name flex">
<span>def <span class="ident">values</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>List of column data corresponding to keys().</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>data</code></strong> :&ensp;<code>list</code> of <code>list</code> of <code>values</code></dt>
<dd>The data of the table. First index is columns!</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def values(self):
    &#34;&#34;&#34;List of column data corresponding to keys().

    Returns
    -------
    data: list of list of values
        The data of the table. First index is columns!
    &#34;&#34;&#34;
    return self.data</code></pre>
</details>
</dd>
<dt id="thunderfish.tabledata.TableData.write"><code class="name flex">
<span>def <span class="ident">write</span></span>(<span>self, fh=sys.stdout, table_format=None, delimiter=None, unit_style=None, column_numbers=None, sections=None, align_columns=None, shrink_width=True, missing='-', center_columns=False, latex_label_command='', latex_merge_std=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Write the table to a file or stream.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>fh</code></strong> :&ensp;<code>filename</code> or <code>stream</code></dt>
<dd>If not a stream, the file with name <code>fh</code> is opened.
If <code>fh</code> does not have an extension,
the <code>table_format</code> is appended as an extension.
Otherwise <code>fh</code> is used as a stream for writing.</dd>
<dt><strong><code>table_format</code></strong> :&ensp;<code>None</code> or <code>string</code></dt>
<dd>The format to be used for output.
One of 'out', 'dat', 'ascii', 'csv', 'rtai', 'md', 'tex', 'html'.
If None or 'auto' then the format is set to the extension of the filename given by <code>fh</code>.
If <code>fh</code> is a stream the format is set to 'dat'.</dd>
<dt><strong><code>delimiter</code></strong> :&ensp;<code>string</code></dt>
<dd>String or character separating columns, if supported by the <code>table_format</code>.
If None or 'auto' use the default for the specified <code>table_format</code>.</dd>
<dt><strong><code>unit_style</code></strong> :&ensp;<code>None</code> or <code>string</code></dt>
<dd>
<ul>
<li>None or 'auto': use default of the specified <code>table_format</code>.</li>
<li>'row': write an extra row to the table header specifying the units of the columns.</li>
<li>'header': add the units to the column headers.</li>
<li>'none': do not specify the units.</li>
</ul>
</dd>
<dt><strong><code>column_numbers</code></strong> :&ensp;<code>string</code> or <code>None</code></dt>
<dd>Add a row specifying the column index:
- 'index': indices are integers, first column is 0.
- 'num': indices are integers, first column is 1.
- 'aa': use 'a', 'b', 'c', &hellip;, 'z', 'aa', 'ab', &hellip; for indexing
- 'aa': use 'A', 'B', 'C', &hellip;, 'Z', 'AA', 'AB', &hellip; for indexing
- None or 'none': do not add a row with column indices
TableData.column_numbering is a list with the supported styles.</dd>
<dt><strong><code>sections</code></strong> :&ensp;<code>None</code> or <code>int</code></dt>
<dd>Number of section levels to be printed.
If <code>None</code> or 'auto' use default of selected <code>table_format</code>.</dd>
<dt><strong><code>align_columns</code></strong> :&ensp;<code>boolean</code></dt>
<dd>
<ul>
<li><code>True</code>: set width of column formats to make them align.</li>
<li><code>False</code>: set width of column formats to 0 - no unnecessary spaces.</li>
<li>None or 'auto': Use default of the selected <code>table_format</code>.</li>
</ul>
</dd>
<dt><strong><code>shrink_width</code></strong> :&ensp;<code>boolean</code></dt>
<dd>If <code>True</code> disregard width specified by the format strings,
such that columns can become narrower.</dd>
<dt><strong><code>missing</code></strong> :&ensp;<code>string</code></dt>
<dd>Indicate missing data by this string.</dd>
<dt><strong><code>center_columns</code></strong> :&ensp;<code>boolean</code></dt>
<dd>If True center all columns (markdown, html, and latex).</dd>
<dt><strong><code>latex_label_command</code></strong> :&ensp;<code>string</code></dt>
<dd>LaTeX command for formatting header labels.
E.g. 'textbf' for making the header labels bold.</dd>
<dt><strong><code>latex_merge_std</code></strong> :&ensp;<code>string</code></dt>
<dd>Merge header of columns with standard deviations with previous column
(LaTeX tables only).</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>file_name</code></strong> :&ensp;<code>string</code> or <code>None</code></dt>
<dd>The full name of the file into which the data were written.</dd>
</dl>
<h2 id="supported-file-formats">Supported File Formats</h2>
<h2 id="dat-data-text-file"><code>dat</code>: data text file</h2>
<pre><code class="language-plain"># info           reaction     
# size   weight  delay  jitter
# m      kg      ms     mm    
   2.34     123   98.7      23
  56.70    3457   54.3      45
   8.90      43   67.9     345
</code></pre>
<h2 id="ascii-ascii-art-table"><code>ascii</code>: ascii-art table</h2>
<pre><code class="language-plain">|---------------------------------|
| info           | reaction       |
| size  | weight | delay | jitter |
| m     | kg     | ms    | mm     |
|-------|--------|-------|--------|
|  2.34 |    123 |  98.7 |     23 |
| 56.70 |   3457 |  54.3 |     45 |
|  8.90 |     43 |  67.9 |    345 |
|---------------------------------|
</code></pre>
<h2 id="csv-comma-separated-values"><code>csv</code>: comma separated values</h2>
<pre><code class="language-plain">size/m,weight/kg,delay/ms,jitter/mm
2.34,123,98.7,23
56.70,3457,54.3,45
8.90,43,67.9,345
</code></pre>
<h2 id="rtai-rtai-style-table"><code>rtai</code>: rtai-style table</h2>
<pre><code class="language-plain">RTH| info         | reaction     
RTH| size | weight| delay| jitter
RTH| m    | kg    | ms   | mm    
RTD|  2.34|    123|  98.7|     23
RTD| 56.70|   3457|  54.3|     45
RTD|  8.90|     43|  67.9|    345
</code></pre>
<h2 id="md-markdown"><code>md</code>: markdown</h2>
<pre><code class="language-plain">| size/m | weight/kg | delay/ms | jitter/mm |
|------:|-------:|------:|-------:|
|  2.34 |    123 |  98.7 |     23 |
| 56.70 |   3457 |  54.3 |     45 |
|  8.90 |     43 |  67.9 |    345 |
</code></pre>
<h2 id="tex-latex-tabular"><code>tex</code>: latex tabular</h2>
<pre><code class="language-tex">\begin{tabular}{rrrr}
  \hline
  \multicolumn{2}{l}{info} &amp; \multicolumn{2}{l}{reaction} \
  \multicolumn{1}{l}{size} &amp; \multicolumn{1}{l}{weight} &amp; \multicolumn{1}{l}{delay} &amp; \multicolumn{1}{l}{jitter} \
  \multicolumn{1}{l}{m} &amp; \multicolumn{1}{l}{kg} &amp; \multicolumn{1}{l}{ms} &amp; \multicolumn{1}{l}{mm} \
  \hline
  2.34 &amp; 123 &amp; 98.7 &amp; 23 \
  56.70 &amp; 3457 &amp; 54.3 &amp; 45 \
  8.90 &amp; 43 &amp; 67.9 &amp; 345 \
  \hline
\end{tabular}
</code></pre>
<h2 id="html-html"><code>html</code>: html</h2>
<pre><code class="language-html">&lt;table&gt;
&lt;thead&gt;
  &lt;tr class=&quot;header&quot;&gt;
    &lt;th align=&quot;left&quot; colspan=&quot;2&quot;&gt;info&lt;/th&gt;
    &lt;th align=&quot;left&quot; colspan=&quot;2&quot;&gt;reaction&lt;/th&gt;
  &lt;/tr&gt;
  &lt;tr class=&quot;header&quot;&gt;
    &lt;th align=&quot;left&quot;&gt;size&lt;/th&gt;
    &lt;th align=&quot;left&quot;&gt;weight&lt;/th&gt;
    &lt;th align=&quot;left&quot;&gt;delay&lt;/th&gt;
    &lt;th align=&quot;left&quot;&gt;jitter&lt;/th&gt;
  &lt;/tr&gt;
  &lt;tr class=&quot;header&quot;&gt;
    &lt;th align=&quot;left&quot;&gt;m&lt;/th&gt;
    &lt;th align=&quot;left&quot;&gt;kg&lt;/th&gt;
    &lt;th align=&quot;left&quot;&gt;ms&lt;/th&gt;
    &lt;th align=&quot;left&quot;&gt;mm&lt;/th&gt;
  &lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
  &lt;tr class&quot;odd&quot;&gt;
    &lt;td align=&quot;right&quot;&gt;2.34&lt;/td&gt;
    &lt;td align=&quot;right&quot;&gt;123&lt;/td&gt;
    &lt;td align=&quot;right&quot;&gt;98.7&lt;/td&gt;
    &lt;td align=&quot;right&quot;&gt;23&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr class&quot;even&quot;&gt;
    &lt;td align=&quot;right&quot;&gt;56.70&lt;/td&gt;
    &lt;td align=&quot;right&quot;&gt;3457&lt;/td&gt;
    &lt;td align=&quot;right&quot;&gt;54.3&lt;/td&gt;
    &lt;td align=&quot;right&quot;&gt;45&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr class&quot;odd&quot;&gt;
    &lt;td align=&quot;right&quot;&gt;8.90&lt;/td&gt;
    &lt;td align=&quot;right&quot;&gt;43&lt;/td&gt;
    &lt;td align=&quot;right&quot;&gt;67.9&lt;/td&gt;
    &lt;td align=&quot;right&quot;&gt;345&lt;/td&gt;
  &lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def write(self, fh=sys.stdout, table_format=None, delimiter=None,
          unit_style=None, column_numbers=None, sections=None,
          align_columns=None, shrink_width=True, missing=&#39;-&#39;,
          center_columns=False, latex_label_command=&#39;&#39;, latex_merge_std=False):
    &#34;&#34;&#34;Write the table to a file or stream.

    Parameters
    ----------
    fh: filename or stream
        If not a stream, the file with name `fh` is opened.
        If `fh` does not have an extension,
        the `table_format` is appended as an extension.
        Otherwise `fh` is used as a stream for writing.
    table_format: None or string
        The format to be used for output.
        One of &#39;out&#39;, &#39;dat&#39;, &#39;ascii&#39;, &#39;csv&#39;, &#39;rtai&#39;, &#39;md&#39;, &#39;tex&#39;, &#39;html&#39;.
        If None or &#39;auto&#39; then the format is set to the extension of the filename given by `fh`.
        If `fh` is a stream the format is set to &#39;dat&#39;.
    delimiter: string
        String or character separating columns, if supported by the `table_format`.
        If None or &#39;auto&#39; use the default for the specified `table_format`.
    unit_style: None or string
        - None or &#39;auto&#39;: use default of the specified `table_format`.
        - &#39;row&#39;: write an extra row to the table header specifying the units of the columns.
        - &#39;header&#39;: add the units to the column headers.
        - &#39;none&#39;: do not specify the units.
    column_numbers: string or None
        Add a row specifying the column index:
        - &#39;index&#39;: indices are integers, first column is 0.
        - &#39;num&#39;: indices are integers, first column is 1.
        - &#39;aa&#39;: use &#39;a&#39;, &#39;b&#39;, &#39;c&#39;, ..., &#39;z&#39;, &#39;aa&#39;, &#39;ab&#39;, ... for indexing
        - &#39;aa&#39;: use &#39;A&#39;, &#39;B&#39;, &#39;C&#39;, ..., &#39;Z&#39;, &#39;AA&#39;, &#39;AB&#39;, ... for indexing
        - None or &#39;none&#39;: do not add a row with column indices
        TableData.column_numbering is a list with the supported styles.
    sections: None or int
        Number of section levels to be printed.
        If `None` or &#39;auto&#39; use default of selected `table_format`.
    align_columns: boolean
        - `True`: set width of column formats to make them align.
        - `False`: set width of column formats to 0 - no unnecessary spaces.
        - None or &#39;auto&#39;: Use default of the selected `table_format`.
    shrink_width: boolean
        If `True` disregard width specified by the format strings,
        such that columns can become narrower.
    missing: string
        Indicate missing data by this string.
    center_columns: boolean
        If True center all columns (markdown, html, and latex).
    latex_label_command: string
        LaTeX command for formatting header labels.
        E.g. &#39;textbf&#39; for making the header labels bold.
    latex_merge_std: string
        Merge header of columns with standard deviations with previous column
        (LaTeX tables only).

    Returns
    -------
    file_name: string or None
        The full name of the file into which the data were written.

    Supported file formats
    ----------------------
    
    ## `dat`: data text file
    ``` plain
    # info           reaction     
    # size   weight  delay  jitter
    # m      kg      ms     mm    
       2.34     123   98.7      23
      56.70    3457   54.3      45
       8.90      43   67.9     345
    ```

    ## `ascii`: ascii-art table
    ``` plain
    |---------------------------------|
    | info           | reaction       |
    | size  | weight | delay | jitter |
    | m     | kg     | ms    | mm     |
    |-------|--------|-------|--------|
    |  2.34 |    123 |  98.7 |     23 |
    | 56.70 |   3457 |  54.3 |     45 |
    |  8.90 |     43 |  67.9 |    345 |
    |---------------------------------|
    ```

    ## `csv`: comma separated values
    ``` plain
    size/m,weight/kg,delay/ms,jitter/mm
    2.34,123,98.7,23
    56.70,3457,54.3,45
    8.90,43,67.9,345
    ```

    ## `rtai`: rtai-style table
    ``` plain
    RTH| info         | reaction     
    RTH| size | weight| delay| jitter
    RTH| m    | kg    | ms   | mm    
    RTD|  2.34|    123|  98.7|     23
    RTD| 56.70|   3457|  54.3|     45
    RTD|  8.90|     43|  67.9|    345
    ```

    ## `md`: markdown
    ``` plain
    | size/m | weight/kg | delay/ms | jitter/mm |
    |------:|-------:|------:|-------:|
    |  2.34 |    123 |  98.7 |     23 |
    | 56.70 |   3457 |  54.3 |     45 |
    |  8.90 |     43 |  67.9 |    345 |
    ```

    ## `tex`: latex tabular
    ``` tex
    \\begin{tabular}{rrrr}
      \\hline
      \\multicolumn{2}{l}{info} &amp; \\multicolumn{2}{l}{reaction} \\
      \\multicolumn{1}{l}{size} &amp; \\multicolumn{1}{l}{weight} &amp; \\multicolumn{1}{l}{delay} &amp; \\multicolumn{1}{l}{jitter} \\
      \\multicolumn{1}{l}{m} &amp; \\multicolumn{1}{l}{kg} &amp; \\multicolumn{1}{l}{ms} &amp; \\multicolumn{1}{l}{mm} \\
      \\hline
      2.34 &amp; 123 &amp; 98.7 &amp; 23 \\
      56.70 &amp; 3457 &amp; 54.3 &amp; 45 \\
      8.90 &amp; 43 &amp; 67.9 &amp; 345 \\
      \\hline
    \\end{tabular}
    ```

    ## `html`: html
    ``` html
    &lt;table&gt;
    &lt;thead&gt;
      &lt;tr class=&#34;header&#34;&gt;
        &lt;th align=&#34;left&#34; colspan=&#34;2&#34;&gt;info&lt;/th&gt;
        &lt;th align=&#34;left&#34; colspan=&#34;2&#34;&gt;reaction&lt;/th&gt;
      &lt;/tr&gt;
      &lt;tr class=&#34;header&#34;&gt;
        &lt;th align=&#34;left&#34;&gt;size&lt;/th&gt;
        &lt;th align=&#34;left&#34;&gt;weight&lt;/th&gt;
        &lt;th align=&#34;left&#34;&gt;delay&lt;/th&gt;
        &lt;th align=&#34;left&#34;&gt;jitter&lt;/th&gt;
      &lt;/tr&gt;
      &lt;tr class=&#34;header&#34;&gt;
        &lt;th align=&#34;left&#34;&gt;m&lt;/th&gt;
        &lt;th align=&#34;left&#34;&gt;kg&lt;/th&gt;
        &lt;th align=&#34;left&#34;&gt;ms&lt;/th&gt;
        &lt;th align=&#34;left&#34;&gt;mm&lt;/th&gt;
      &lt;/tr&gt;
    &lt;/thead&gt;
    &lt;tbody&gt;
      &lt;tr class&#34;odd&#34;&gt;
        &lt;td align=&#34;right&#34;&gt;2.34&lt;/td&gt;
        &lt;td align=&#34;right&#34;&gt;123&lt;/td&gt;
        &lt;td align=&#34;right&#34;&gt;98.7&lt;/td&gt;
        &lt;td align=&#34;right&#34;&gt;23&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr class&#34;even&#34;&gt;
        &lt;td align=&#34;right&#34;&gt;56.70&lt;/td&gt;
        &lt;td align=&#34;right&#34;&gt;3457&lt;/td&gt;
        &lt;td align=&#34;right&#34;&gt;54.3&lt;/td&gt;
        &lt;td align=&#34;right&#34;&gt;45&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr class&#34;odd&#34;&gt;
        &lt;td align=&#34;right&#34;&gt;8.90&lt;/td&gt;
        &lt;td align=&#34;right&#34;&gt;43&lt;/td&gt;
        &lt;td align=&#34;right&#34;&gt;67.9&lt;/td&gt;
        &lt;td align=&#34;right&#34;&gt;345&lt;/td&gt;
      &lt;/tr&gt;
    &lt;/tbody&gt;
    &lt;/table&gt;
    ```
    &#34;&#34;&#34;
    # fix parameter:
    if table_format == &#39;auto&#39;:
        table_format = None
    if delimiter == &#39;auto&#39;:
        delimiter = None
    if unit_style == &#39;auto&#39;:
        unit_style = None
    if column_numbers == &#39;none&#39;:
        column_numbers = None
    if sections == &#39;auto&#39;:
        sections = None
    if align_columns == &#39;auto&#39;:
        align_columns = None
    # open file:
    own_file = False
    file_name = None
    if not hasattr(fh, &#39;write&#39;):
        _, ext = os.path.splitext(fh)
        if table_format is None:
            if len(ext) &gt; 1 and ext[1:] in self.ext_formats:
                table_format = self.ext_formats[ext[1:]]
        elif not ext or not ext[1:].lower() in self.ext_formats:
            fh += &#39;.&#39; + self.extensions[table_format]
        file_name = fh
        fh = open(fh, &#39;w&#39;)
        own_file = True
    if table_format is None:
        table_format = &#39;dat&#39;
    # set style:        
    if table_format[0] == &#39;d&#39;:
        align_columns = True
        begin_str = &#39;&#39;
        end_str = &#39;&#39;
        header_start = &#39;# &#39;
        header_sep = &#39;  &#39;
        header_close = &#39;&#39;
        header_end = &#39;\n&#39;
        data_start = &#39;  &#39;
        data_sep = &#39;  &#39;
        data_close = &#39;&#39;
        data_end = &#39;\n&#39;
        top_line = False
        header_line = False
        bottom_line = False
        if delimiter is not None:
            header_sep = delimiter
            data_sep = delimiter
        if sections is None:
            sections = 1000
    elif table_format[0] == &#39;a&#39;:
        align_columns = True
        begin_str = &#39;&#39;
        end_str = &#39;&#39;
        header_start = &#39;| &#39;
        header_sep = &#39; | &#39;
        header_close = &#39;&#39;
        header_end = &#39; |\n&#39;
        data_start = &#39;| &#39;
        data_sep = &#39; | &#39;
        data_close = &#39;&#39;
        data_end = &#39; |\n&#39;
        top_line = True
        header_line = True
        bottom_line = True
        if delimiter is not None:
            header_sep = delimiter
            data_sep = delimiter
        if sections is None:
            sections = 1000
    elif table_format[0] == &#39;c&#39;:
        # csv according to http://www.ietf.org/rfc/rfc4180.txt :
        column_numbers=None
        if unit_style is None:
            unit_style = &#39;header&#39;
        if align_columns is None:
            align_columns = False
        begin_str = &#39;&#39;
        end_str = &#39;&#39;
        header_start=&#39;&#39;
        header_sep = &#39;,&#39;
        header_close = &#39;&#39;
        header_end=&#39;\n&#39;
        data_start=&#39;&#39;
        data_sep = &#39;,&#39;
        data_close = &#39;&#39;
        data_end=&#39;\n&#39;
        top_line = False
        header_line = False
        bottom_line = False
        if delimiter is not None:
            header_sep = delimiter
            data_sep = delimiter
        if sections is None:
            sections = 0
    elif table_format[0] == &#39;r&#39;:
        align_columns = True
        begin_str = &#39;&#39;
        end_str = &#39;&#39;
        header_start = &#39;RTH| &#39;
        header_sep = &#39;| &#39;
        header_close = &#39;&#39;
        header_end = &#39;\n&#39;
        data_start = &#39;RTD| &#39;
        data_sep = &#39;| &#39;
        data_close = &#39;&#39;
        data_end = &#39;\n&#39;
        top_line = False
        header_line = False
        bottom_line = False
        if sections is None:
            sections = 1000
    elif table_format[0] == &#39;m&#39;:
        if unit_style is None or unit_style == &#39;row&#39;:
            unit_style = &#39;header&#39;
        align_columns = True
        begin_str = &#39;&#39;
        end_str = &#39;&#39;
        header_start=&#39;| &#39;
        header_sep = &#39; | &#39;
        header_close = &#39;&#39;
        header_end=&#39; |\n&#39;
        data_start=&#39;| &#39;
        data_sep = &#39; | &#39;
        data_close = &#39;&#39;
        data_end=&#39; |\n&#39;
        top_line = False
        header_line = True
        bottom_line = False
        if sections is None:
            sections = 0
    elif table_format[0] == &#39;h&#39;:
        align_columns = False
        begin_str = &#39;&lt;table&gt;\n&lt;thead&gt;\n&#39;
        end_str = &#39;&lt;/tbody&gt;\n&lt;/table&gt;\n&#39;
        if center_columns:
            header_start=&#39;  &lt;tr&gt;\n    &lt;th align=&#34;center&#34;&#39;
            header_sep = &#39;&lt;/th&gt;\n    &lt;th align=&#34;center&#34;&#39;
        else:
            header_start=&#39;  &lt;tr&gt;\n    &lt;th align=&#34;left&#34;&#39;
            header_sep = &#39;&lt;/th&gt;\n    &lt;th align=&#34;left&#34;&#39;
        header_close = &#39;&gt;&#39;
        header_end=&#39;&lt;/th&gt;\n  &lt;/tr&gt;\n&#39;
        data_start=&#39;  &lt;tr&gt;\n    &lt;td&#39;
        data_sep = &#39;&lt;/td&gt;\n    &lt;td&#39;
        data_close = &#39;&gt;&#39;
        data_end=&#39;&lt;/td&gt;\n  &lt;/tr&gt;\n&#39;
        top_line = False
        header_line = False
        bottom_line = False
        if sections is None:
            sections = 1000
    elif table_format[0] == &#39;t&#39;:
        if align_columns is None:
            align_columns = False
        begin_str = &#39;\\begin{tabular}&#39;
        end_str = &#39;\\end{tabular}\n&#39;
        header_start=&#39;  &#39;
        header_sep = &#39; &amp; &#39;
        header_close = &#39;&#39;
        header_end=&#39; \\\\\n&#39;
        data_start=&#39;  &#39;
        data_sep = &#39; &amp; &#39;
        data_close = &#39;&#39;
        data_end=&#39; \\\\\n&#39;
        top_line = True
        header_line = True
        bottom_line = True
        if sections is None:
            sections = 1000
    else:
        if align_columns is None:
            align_columns = True
        begin_str = &#39;&#39;
        end_str = &#39;&#39;
        header_start = &#39;&#39;
        header_sep = &#39;  &#39;
        header_close = &#39;&#39;
        header_end = &#39;\n&#39;
        data_start = &#39;&#39;
        data_sep = &#39;  &#39;
        data_close = &#39;&#39;
        data_end = &#39;\n&#39;
        top_line = False
        header_line = False
        bottom_line = False
        if sections is None:
            sections = 1000
    # check units:
    if unit_style is None:
        unit_style = &#39;row&#39;
    have_units = False
    for u in self.units:
        if u and u != &#39;1&#39; and u != &#39;-&#39;:
            have_units = True
            break
    if not have_units:
        unit_style = &#39;none&#39;
    # find std columns:
    stdev_col = np.zeros(len(self.header), dtype=np.bool)
    for c in range(len(self.header)-1):
        if self.header[c+1][0].lower() in [&#39;sd&#39;, &#39;std&#39;, &#39;s.d.&#39;, &#39;stdev&#39;] and \
           not self.hidden[c+1]:
            stdev_col[c] = True
    # begin table:
    fh.write(begin_str)
    if table_format[0] == &#39;t&#39;:
        fh.write(&#39;{&#39;)
        merged = False
        for h, f, s in zip(self.hidden, self.formats, stdev_col):
            if merged:
                fh.write(&#39;l&#39;)
                merged = False
                continue
            if h:
                continue
            if latex_merge_std and s:
                fh.write(&#39;r@{$\\,\\pm\\,$}&#39;)
                merged = True
            elif center_columns:
                fh.write(&#39;c&#39;)
            elif f[1] == &#39;-&#39;:
                fh.write(&#39;l&#39;)
            else:
                fh.write(&#39;r&#39;)
        fh.write(&#39;}\n&#39;)
    # retrieve column formats and widths:
    widths = []
    widths_pos = []
    for c, f in enumerate(self.formats):
        w = 0
        # position of width specification:
        i0 = 1
        if f[1] == &#39;-&#39; :
            i0 = 2
        i1 = f.find(&#39;.&#39;)
        if not shrink_width:
            if f[i0:i1]:
                w = int(f[i0:i1])
        widths_pos.append((i0, i1))
        # adapt width to header label:
        hw = len(self.header[c][0])
        if unit_style == &#39;header&#39; and self.units[c] and\
           self.units[c] != &#39;1&#39; and self.units[c] != &#39;-&#39;:
            hw += 1 + len(self.units[c])
        if w &lt; hw:
            w = hw
        # adapt width to data:
        if f[-1] == &#39;s&#39;:
            for v in self.data[c]:
                if not isinstance(v, float) and w &lt; len(v):
                    w = len(v)
        else:
            fs = f[:i0] + str(0) + f[i1:]
            for v in self.data[c]:
                if isinstance(v, float) and m.isnan(v):
                    s = missing
                else:
                    s = fs % v
                if w &lt; len(s):
                    w = len(s)
        widths.append(w)
    # adapt width to sections:
    sec_indices = [0] * self.nsecs
    sec_widths = [0] * self.nsecs
    sec_columns = [0] * self.nsecs
    for c in range(len(self.header)):
        w = widths[c]
        for l in range(min(self.nsecs, sections)):
            if 1+l &lt; len(self.header[c]):
                if c &gt; 0 and sec_columns[l] &gt; 0 and \
                   1+l &lt; len(self.header[sec_indices[l]]) and \
                   len(self.header[sec_indices[l]][1+l]) &gt; sec_widths[l]:
                    dw = len(self.header[sec_indices[l]][1+l]) - sec_widths[l]
                    nc = sec_columns[l]
                    ddw = np.zeros(nc, dtype=int) + dw // nc
                    ddw[:dw % nc] += 1
                    wk = 0
                    for ck in range(sec_indices[l], c):
                        if not self.hidden[ck]:
                            widths[ck] += ddw[wk]
                            wk += 1
                sec_widths[l] = 0
                sec_indices[l] = c
            if not self.hidden[c]:
                if sec_widths[l] &gt; 0:
                    sec_widths[l] += len(header_sep)
                sec_widths[l] += w
                sec_columns[l] += 1
    # set width of format string:
    formats = []
    for c, (f, w) in enumerate(zip(self.formats, widths)):
        formats.append(f[:widths_pos[c][0]] + str(w) + f[widths_pos[c][1]:])
    # top line:
    if top_line:
        if table_format[0] == &#39;t&#39;:
            fh.write(&#39;  \\hline \\\\[-2ex]\n&#39;)
        else:
            first = True
            fh.write(header_start.replace(&#39; &#39;, &#39;-&#39;))
            for c in range(len(self.header)):
                if self.hidden[c]:
                    continue
                if not first:
                    fh.write(&#39;-&#39;*len(header_sep))
                first = False
                fh.write(header_close)
                w = widths[c]
                fh.write(w*&#39;-&#39;)
            fh.write(header_end.replace(&#39; &#39;, &#39;-&#39;))
    # section and column headers:
    nsec0 = self.nsecs-sections
    if nsec0 &lt; 0:
        nsec0 = 0
    for ns in range(nsec0, self.nsecs+1):
        nsec = self.nsecs-ns
        first = True
        last = False
        merged = False
        fh.write(header_start)
        for c in range(len(self.header)):
            if nsec &lt; len(self.header[c]):
                # section width and column count:
                sw = -len(header_sep)
                columns = 0
                if not self.hidden[c]:
                    sw = widths[c]
                    columns = 1
                for k in range(c+1, len(self.header)):
                    if nsec &lt; len(self.header[k]):
                        break
                    if self.hidden[k]:
                        continue
                    sw += len(header_sep) + widths[k]
                    columns += 1
                else:
                    last = True
                    if len(header_end.strip()) == 0:
                        sw = 0  # last entry needs no width
                if columns == 0:
                    continue
                if not first and not merged:
                    fh.write(header_sep)
                first = False
                if table_format[0] == &#39;c&#39;:
                    sw -= len(header_sep)*(columns-1)
                elif table_format[0] == &#39;h&#39;:
                    if columns&gt;1:
                        fh.write(&#39; colspan=&#34;%d&#34;&#39; % columns)
                elif table_format[0] == &#39;t&#39;:
                    if merged:
                        merged = False
                        continue
                    if latex_merge_std and nsec == 0 and stdev_col[c]:
                        merged = True
                        fh.write(&#39;\\multicolumn{%d}{c}{&#39; % (columns+1))
                    elif center_columns:
                        fh.write(&#39;\\multicolumn{%d}{c}{&#39; % columns)
                    else:
                        fh.write(&#39;\\multicolumn{%d}{l}{&#39; % columns)
                    if latex_label_command:
                        fh.write(&#39;\\%s{&#39; % latex_label_command)
                fh.write(header_close)
                hs = self.header[c][nsec]
                if nsec == 0 and unit_style == &#39;header&#39;:
                    if self.units[c] and self.units[c] != &#39;1&#39; and self.units[c] != &#39;-&#39;:
                        hs += &#39;/&#39; + self.units[c]
                if align_columns and not table_format[0] in &#39;th&#39;:
                    f = &#39;%%-%ds&#39; % sw
                    fh.write(f % hs)
                else:
                    fh.write(hs)
                if table_format[0] == &#39;c&#39;:
                    if not last:
                        fh.write(header_sep*(columns-1))
                elif table_format[0] == &#39;t&#39;:
                    if latex_label_command:
                        fh.write(&#39;}&#39;)
                    fh.write(&#39;}&#39;)
        fh.write(header_end)
    # units:
    if unit_style == &#39;row&#39;:
        first = True
        merged = False
        fh.write(header_start)
        for c in range(len(self.header)):
            if self.hidden[c] or merged:
                merged = False
                continue
            if not first:
                fh.write(header_sep)
            first = False
            fh.write(header_close)
            unit = self.units[c]
            if not unit:
                unit = &#39;-&#39;
            if table_format[0] == &#39;t&#39;:
                if latex_merge_std and stdev_col[c]:
                    merged = True
                    fh.write(&#39;\\multicolumn{2}{c}{%s}&#39; % latex_unit(unit))
                elif center_columns:
                    fh.write(&#39;\\multicolumn{1}{c}{%s}&#39; % latex_unit(unit))
                else:
                    fh.write(&#39;\\multicolumn{1}{l}{%s}&#39; % latex_unit(unit))
            else:
                if align_columns and not table_format[0] in &#39;h&#39;:
                    f = &#39;%%-%ds&#39; % widths[c]
                    fh.write(f % unit)
                else:
                    fh.write(unit)
        fh.write(header_end)
    # column numbers:
    if column_numbers is not None:
        first = True
        fh.write(header_start)
        for c in range(len(self.header)):
            if self.hidden[c]:
                continue
            if not first:
                fh.write(header_sep)
            first = False
            fh.write(header_close)
            i = c
            if column_numbers == &#39;num&#39;:
                i = c+1
            aa = index2aa(c, &#39;a&#39;)
            if column_numbers == &#39;AA&#39;:
                aa = index2aa(c, &#39;A&#39;)
            if table_format[0] == &#39;t&#39;:
                if column_numbers == &#39;num&#39; or column_numbers == &#39;index&#39;:
                    fh.write(&#39;\\multicolumn{1}{l}{%d}&#39; % i)
                else:
                    fh.write(&#39;\\multicolumn{1}{l}{%s}&#39; % aa)
            else:
                if column_numbers == &#39;num&#39; or column_numbers == &#39;index&#39;:
                    if align_columns:
                        f = &#39;%%%dd&#39; % widths[c]
                        fh.write(f % i)
                    else:
                        fh.write(&#39;%d&#39; % i)
                else:
                    if align_columns:
                        f = &#39;%%-%ds&#39; % widths[c]
                        fh.write(f % aa)
                    else:
                        fh.write(aa)
        fh.write(header_end)
    # header line:
    if header_line:
        if table_format[0] == &#39;m&#39;:
            fh.write(&#39;|&#39;)
            for c in range(len(self.header)):
                if self.hidden[c]:
                    continue
                w = widths[c]+2
                if center_columns:
                    fh.write(&#39;:&#39; + (w-2)*&#39;-&#39; + &#39;:|&#39;)
                elif formats[c][1] == &#39;-&#39;:
                    fh.write(w*&#39;-&#39; + &#39;|&#39;)
                else:
                    fh.write((w-1)*&#39;-&#39; + &#39;:|&#39;)
            fh.write(&#39;\n&#39;)
        elif table_format[0] == &#39;t&#39;:
            fh.write(&#39;  \\hline \\\\[-2ex]\n&#39;)
        else:
            first = True
            fh.write(header_start.replace(&#39; &#39;, &#39;-&#39;))
            for c in range(len(self.header)):
                if self.hidden[c]:
                    continue
                if not first:
                    fh.write(header_sep.replace(&#39; &#39;, &#39;-&#39;))
                first = False
                fh.write(header_close)
                w = widths[c]
                fh.write(w*&#39;-&#39;)
            fh.write(header_end.replace(&#39; &#39;, &#39;-&#39;))
    # start table data:
    if table_format[0] == &#39;h&#39;:
        fh.write(&#39;&lt;/thead&gt;\n&lt;tbody&gt;\n&#39;)
    # data:
    for k in range(self.rows()):
        first = True
        merged = False
        fh.write(data_start)
        for c, f in enumerate(formats):
            if self.hidden[c] or merged:
                merged = False
                continue
            if not first:
                fh.write(data_sep)
            first = False
            if table_format[0] == &#39;h&#39;:
                if center_columns:
                    fh.write(&#39; align=&#34;center&#34;&#39;)
                elif f[1] == &#39;-&#39;:
                    fh.write(&#39; align=&#34;left&#34;&#39;)
                else:
                    fh.write(&#39; align=&#34;right&#34;&#39;)
            fh.write(data_close)
            if k &gt;= len(self.data[c]) or \
               (isinstance(self.data[c][k], float) and m.isnan(self.data[c][k])):
                # missing data:
                if table_format[0] == &#39;t&#39; and latex_merge_std and stdev_col[c]:
                    merged = True
                    fh.write(&#39;\\multicolumn{2}{c}{%s}&#39; % missing)
                elif align_columns:
                    if f[1] == &#39;-&#39;:
                        fn = &#39;%%-%ds&#39; % widths[c]
                    else:
                        fn = &#39;%%%ds&#39; % widths[c]
                    fh.write(fn % missing)
                else:
                    fh.write(missing)
            else:
                # data value:
                ds = f % self.data[c][k]
                if not align_columns:
                    ds = ds.strip()
                fh.write(ds)
        fh.write(data_end)
    # bottom line:
    if bottom_line:
        if table_format[0] == &#39;t&#39;:
            fh.write(&#39;  \\hline\n&#39;)
        else:
            first = True
            fh.write(header_start.replace(&#39; &#39;, &#39;-&#39;))
            for c in range(len(self.header)):
                if self.hidden[c]:
                    continue
                if not first:
                    fh.write(&#39;-&#39;*len(header_sep))
                first = False
                fh.write(header_close)
                w = widths[c]
                fh.write(w*&#39;-&#39;)
            fh.write(header_end.replace(&#39; &#39;, &#39;-&#39;))
    # end table:
    fh.write(end_str)
    # close file:
    if own_file:
        fh.close()
    # return file name:
    return file_name</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul>
<li><a href="#classes">Classes</a></li>
<li><a href="#helper-functions">Helper functions</a></li>
<li><a href="#configuration">Configuration</a></li>
</ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="thunderfish" href="index.html">thunderfish</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="thunderfish.tabledata.aa2index" href="#thunderfish.tabledata.aa2index">aa2index</a></code></li>
<li><code><a title="thunderfish.tabledata.add_write_table_config" href="#thunderfish.tabledata.add_write_table_config">add_write_table_config</a></code></li>
<li><code><a title="thunderfish.tabledata.index2aa" href="#thunderfish.tabledata.index2aa">index2aa</a></code></li>
<li><code><a title="thunderfish.tabledata.latex_unit" href="#thunderfish.tabledata.latex_unit">latex_unit</a></code></li>
<li><code><a title="thunderfish.tabledata.write" href="#thunderfish.tabledata.write">write</a></code></li>
<li><code><a title="thunderfish.tabledata.write_table_args" href="#thunderfish.tabledata.write_table_args">write_table_args</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="thunderfish.tabledata.IndentStream" href="#thunderfish.tabledata.IndentStream">IndentStream</a></code></h4>
<ul class="">
<li><code><a title="thunderfish.tabledata.IndentStream.flush" href="#thunderfish.tabledata.IndentStream.flush">flush</a></code></li>
<li><code><a title="thunderfish.tabledata.IndentStream.write" href="#thunderfish.tabledata.IndentStream.write">write</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="thunderfish.tabledata.TableData" href="#thunderfish.tabledata.TableData">TableData</a></code></h4>
<ul class="two-column">
<li><code><a title="thunderfish.tabledata.TableData.__call__" href="#thunderfish.tabledata.TableData.__call__">__call__</a></code></li>
<li><code><a title="thunderfish.tabledata.TableData.__contains__" href="#thunderfish.tabledata.TableData.__contains__">__contains__</a></code></li>
<li><code><a title="thunderfish.tabledata.TableData.__delitem__" href="#thunderfish.tabledata.TableData.__delitem__">__delitem__</a></code></li>
<li><code><a title="thunderfish.tabledata.TableData.__getitem__" href="#thunderfish.tabledata.TableData.__getitem__">__getitem__</a></code></li>
<li><code><a title="thunderfish.tabledata.TableData.__iter__" href="#thunderfish.tabledata.TableData.__iter__">__iter__</a></code></li>
<li><code><a title="thunderfish.tabledata.TableData.__len__" href="#thunderfish.tabledata.TableData.__len__">__len__</a></code></li>
<li><code><a title="thunderfish.tabledata.TableData.__next__" href="#thunderfish.tabledata.TableData.__next__">__next__</a></code></li>
<li><code><a title="thunderfish.tabledata.TableData.__setitem__" href="#thunderfish.tabledata.TableData.__setitem__">__setitem__</a></code></li>
<li><code><a title="thunderfish.tabledata.TableData.__str__" href="#thunderfish.tabledata.TableData.__str__">__str__</a></code></li>
<li><code><a title="thunderfish.tabledata.TableData.append" href="#thunderfish.tabledata.TableData.append">append</a></code></li>
<li><code><a title="thunderfish.tabledata.TableData.append_data" href="#thunderfish.tabledata.TableData.append_data">append_data</a></code></li>
<li><code><a title="thunderfish.tabledata.TableData.append_data_column" href="#thunderfish.tabledata.TableData.append_data_column">append_data_column</a></code></li>
<li><code><a title="thunderfish.tabledata.TableData.append_section" href="#thunderfish.tabledata.TableData.append_section">append_section</a></code></li>
<li><code><a title="thunderfish.tabledata.TableData.array" href="#thunderfish.tabledata.TableData.array">array</a></code></li>
<li><code><a title="thunderfish.tabledata.TableData.clear_data" href="#thunderfish.tabledata.TableData.clear_data">clear_data</a></code></li>
<li><code><a title="thunderfish.tabledata.TableData.col" href="#thunderfish.tabledata.TableData.col">col</a></code></li>
<li><code><a title="thunderfish.tabledata.TableData.column_head" href="#thunderfish.tabledata.TableData.column_head">column_head</a></code></li>
<li><code><a title="thunderfish.tabledata.TableData.column_spec" href="#thunderfish.tabledata.TableData.column_spec">column_spec</a></code></li>
<li><code><a title="thunderfish.tabledata.TableData.columns" href="#thunderfish.tabledata.TableData.columns">columns</a></code></li>
<li><code><a title="thunderfish.tabledata.TableData.data_frame" href="#thunderfish.tabledata.TableData.data_frame">data_frame</a></code></li>
<li><code><a title="thunderfish.tabledata.TableData.descriptions" href="#thunderfish.tabledata.TableData.descriptions">descriptions</a></code></li>
<li><code><a title="thunderfish.tabledata.TableData.dict" href="#thunderfish.tabledata.TableData.dict">dict</a></code></li>
<li><code><a title="thunderfish.tabledata.TableData.dicts" href="#thunderfish.tabledata.TableData.dicts">dicts</a></code></li>
<li><code><a title="thunderfish.tabledata.TableData.ext_formats" href="#thunderfish.tabledata.TableData.ext_formats">ext_formats</a></code></li>
<li><code><a title="thunderfish.tabledata.TableData.extensions" href="#thunderfish.tabledata.TableData.extensions">extensions</a></code></li>
<li><code><a title="thunderfish.tabledata.TableData.fill_data" href="#thunderfish.tabledata.TableData.fill_data">fill_data</a></code></li>
<li><code><a title="thunderfish.tabledata.TableData.find_col" href="#thunderfish.tabledata.TableData.find_col">find_col</a></code></li>
<li><code><a title="thunderfish.tabledata.TableData.format" href="#thunderfish.tabledata.TableData.format">format</a></code></li>
<li><code><a title="thunderfish.tabledata.TableData.formats" href="#thunderfish.tabledata.TableData.formats">formats</a></code></li>
<li><code><a title="thunderfish.tabledata.TableData.hide" href="#thunderfish.tabledata.TableData.hide">hide</a></code></li>
<li><code><a title="thunderfish.tabledata.TableData.hide_all" href="#thunderfish.tabledata.TableData.hide_all">hide_all</a></code></li>
<li><code><a title="thunderfish.tabledata.TableData.hide_empty_columns" href="#thunderfish.tabledata.TableData.hide_empty_columns">hide_empty_columns</a></code></li>
<li><code><a title="thunderfish.tabledata.TableData.index" href="#thunderfish.tabledata.TableData.index">index</a></code></li>
<li><code><a title="thunderfish.tabledata.TableData.insert" href="#thunderfish.tabledata.TableData.insert">insert</a></code></li>
<li><code><a title="thunderfish.tabledata.TableData.insert_section" href="#thunderfish.tabledata.TableData.insert_section">insert_section</a></code></li>
<li><code><a title="thunderfish.tabledata.TableData.items" href="#thunderfish.tabledata.TableData.items">items</a></code></li>
<li><code><a title="thunderfish.tabledata.TableData.key_value" href="#thunderfish.tabledata.TableData.key_value">key_value</a></code></li>
<li><code><a title="thunderfish.tabledata.TableData.keys" href="#thunderfish.tabledata.TableData.keys">keys</a></code></li>
<li><code><a title="thunderfish.tabledata.TableData.label" href="#thunderfish.tabledata.TableData.label">label</a></code></li>
<li><code><a title="thunderfish.tabledata.TableData.load" href="#thunderfish.tabledata.TableData.load">load</a></code></li>
<li><code><a title="thunderfish.tabledata.TableData.next" href="#thunderfish.tabledata.TableData.next">next</a></code></li>
<li><code><a title="thunderfish.tabledata.TableData.remove" href="#thunderfish.tabledata.TableData.remove">remove</a></code></li>
<li><code><a title="thunderfish.tabledata.TableData.row" href="#thunderfish.tabledata.TableData.row">row</a></code></li>
<li><code><a title="thunderfish.tabledata.TableData.row_dict" href="#thunderfish.tabledata.TableData.row_dict">row_dict</a></code></li>
<li><code><a title="thunderfish.tabledata.TableData.rows" href="#thunderfish.tabledata.TableData.rows">rows</a></code></li>
<li><code><a title="thunderfish.tabledata.TableData.section" href="#thunderfish.tabledata.TableData.section">section</a></code></li>
<li><code><a title="thunderfish.tabledata.TableData.set_column" href="#thunderfish.tabledata.TableData.set_column">set_column</a></code></li>
<li><code><a title="thunderfish.tabledata.TableData.set_format" href="#thunderfish.tabledata.TableData.set_format">set_format</a></code></li>
<li><code><a title="thunderfish.tabledata.TableData.set_formats" href="#thunderfish.tabledata.TableData.set_formats">set_formats</a></code></li>
<li><code><a title="thunderfish.tabledata.TableData.set_label" href="#thunderfish.tabledata.TableData.set_label">set_label</a></code></li>
<li><code><a title="thunderfish.tabledata.TableData.set_section" href="#thunderfish.tabledata.TableData.set_section">set_section</a></code></li>
<li><code><a title="thunderfish.tabledata.TableData.set_unit" href="#thunderfish.tabledata.TableData.set_unit">set_unit</a></code></li>
<li><code><a title="thunderfish.tabledata.TableData.set_units" href="#thunderfish.tabledata.TableData.set_units">set_units</a></code></li>
<li><code><a title="thunderfish.tabledata.TableData.show" href="#thunderfish.tabledata.TableData.show">show</a></code></li>
<li><code><a title="thunderfish.tabledata.TableData.sort" href="#thunderfish.tabledata.TableData.sort">sort</a></code></li>
<li><code><a title="thunderfish.tabledata.TableData.statistics" href="#thunderfish.tabledata.TableData.statistics">statistics</a></code></li>
<li><code><a title="thunderfish.tabledata.TableData.table_header" href="#thunderfish.tabledata.TableData.table_header">table_header</a></code></li>
<li><code><a title="thunderfish.tabledata.TableData.unit" href="#thunderfish.tabledata.TableData.unit">unit</a></code></li>
<li><code><a title="thunderfish.tabledata.TableData.values" href="#thunderfish.tabledata.TableData.values">values</a></code></li>
<li><code><a title="thunderfish.tabledata.TableData.write" href="#thunderfish.tabledata.TableData.write">write</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>