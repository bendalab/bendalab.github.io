<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>thunderfish.collectfish API documentation</title>
<meta name="description" content="Collect data generated by thunderfish in a wavefish and a pulsefish table." />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS_CHTML" integrity="sha256-kZafAc6mZvK3W3v1pHOcUix30OHQN6pU/NO2oFkqZVw=" crossorigin></script>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>thunderfish.collectfish</code></h1>
</header>
<section id="section-intro">
<p>Collect data generated by thunderfish in a wavefish and a pulsefish table.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
Collect data generated by thunderfish in a wavefish and a pulsefish table.
&#34;&#34;&#34;

import os
import glob
import sys
import argparse
import numpy as np
from .version import __version__, __year__
from .configfile import ConfigFile
from .tabledata import TableData, add_write_table_config, write_table_args
from .harmonics import add_harmonic_groups_config
from .eodanalysis import wave_similarity, pulse_similarity
from .eodanalysis import load_species_waveforms, add_species_config
from .eodanalysis import wave_quality, wave_quality_args, add_eod_quality_config
from .eodanalysis import pulse_quality, pulse_quality_args
from .eodanalysis import adjust_eodf


def collect_fish(files, simplify_file=False,
                 meta_data=None, meta_recordings=None, skip_recordings=False,
                 temp_col=None, q10=1.62, max_fish=0, harmonics=None,
                 peaks0=None, peaks1=None, cfg=None, verbose=0):
    &#34;&#34;&#34;Combine all *-wavefish.* and/or *-pulsefish.* files into respective summary tables.

    Data from the *-wavespectrum-*.* and the *-pulsepeaks-*.* files can be added
    as specified by `harmonics`, `peaks0`, and `peaks1`.

    Meta data of the recordings can also be added via `meta_data` and
    `meta_recordings`.  If `meta_data` contains a column with
    temperature, this column can be specified by the `temp_col`
    parameter. In this case, an &#39;T_adjust&#39; and an &#39;EODf_adjust&#39; column
    are inserted into the resulting tables containing the mean
    temperature and EOD frequencies adjusted to this temperature,
    respectively. For the temperature adjustment of EOD frequency
    a Q10 value can be supplied by the `q10` parameter.

    Parameters
    ----------
    files: list of strings
        Files to be combined.
    simplify_file: boolean
        Remove initial common directories from input files.
    meta_data: TableData or None
        Table with additional data for each of the recordings.
        The meta data are inserted into the summary table according to
        the name of the recording as specified in `meta_recordings`.
    meta_recordings: array of strings
        For each row in `meta_data` the name of the recording.
        This name is matched agains the basename of input `files`.
    skip_recordings: bool
        If True skip recordings that are not found in `meta_recordings`.
    temp_col: string or None
        A column in `meta_data` with temperatures to which EOD
        frequences should be adjusted.
    q10: float
        Q10 value describing temperature dependence of EOD
        frequencies.  The default of 1.62 is from Dunlap, Smith, Yetka
        (2000) Brain Behav Evol, measured for Apteronotus
        lepthorhynchus in the lab.
    max_fish: int
        Maximum number of fish to be taken, if 0 take all.
    harmonics: int
        Number of harmonic to be added to the wave-type fish table
        (amplitude, relampl, phase).  This data is read in from the
        corresponding *-wavespectrum-*.* files.
    peaks0: int
        Index of the first peak of a EOD pulse to be added to the
        pulse-type fish table.  This data is read in from the
        corresponding *-pulsepeaks-*.* files.
    peaks1: int
        Index of the last peak of a EOD pulse to be added to the
        pulse-type fish table.  This data is read in from the
        corresponding *-pulsepeaks-*.* files.
    cfg: ConfigFile
        Configuration parameter for EOD quality assessment and species
        assignment.
    verbose: int
        Verbose output:
        
        1: print infos on meta data coverage.
        2: print additional infos on discarded recordings.

    Returns
    -------
    wave_table: TableData
        Summary table for all wave-type fish.
    pulse_table: TableData
        Summary table for all pulse-type fish.
    all_table: TableData
        Summary table for all wave-type and pulse-type fish.

    &#34;&#34;&#34;
    def find_recording(recording, meta_recordings):
        &#34;&#34;&#34; Find row of a recording in meta data.

        Parameters
        ----------
        recording: string
            Base name of a recording.
        meta_recordings: list of string
            List of meta data recordings where to find `recording`.
        &#34;&#34;&#34;
        if meta_data is not None:
            rec = os.path.splitext(os.path.basename(recording))[0]
            for i in range(len(meta_recordings)):
                if rec == meta_recordings[i]:
                    return i
        return -1
        
    # prepare meta recodings names:
    meta_recordings_used = None
    if meta_recordings is not None:
        meta_recordings_used = np.zeros(len(meta_recordings), dtype=np.bool)
        for r in range(len(meta_recordings)):
            meta_recordings[r] = os.path.splitext(os.path.basename(meta_recordings[r]))[0]
    # prepare adjusted temperatures:
    if meta_data is not None and temp_col is not None:
        temp_idx = meta_data.index(temp_col)
        temp = meta_data[:,temp_idx]
        mean_tmp = np.round(np.nanmean(temp)/0.1)*0.1
        meta_data.insert(temp_idx+1, &#39;T_adjust&#39;, &#39;C&#39;, &#39;%.1f&#39;)
        meta_data.append_data_column([mean_tmp]*meta_data.rows(), temp_idx+1)
    # prepare species distances:
    wave_names, wave_eods, pulse_names, pulse_eods = \
      load_species_waveforms(cfg.value(&#39;speciesFile&#39;))
    wave_max_rms = cfg.value(&#39;maximumWaveSpeciesRMS&#39;)
    pulse_max_rms = cfg.value(&#39;maximumPulseSpeciesRMS&#39;)
    # load data:    
    wave_table = None
    pulse_table = None
    all_table = None
    file_pathes = []
    for file_name in files:
        # file name:
        table = None
        base_path, file_ext = os.path.splitext(file_name)[0:2]
        if base_path.endswith(&#39;-pulsefish&#39;):
            base_path = base_path[:-10]
            fish_type = &#39;pulse&#39;
        elif base_path.endswith(&#39;-wavefish&#39;):
            base_path = base_path[:-9]
            fish_type = &#39;wave&#39;
        else:
            continue
        if base_path.startswith(&#39;./&#39;):
            base_path = base_path[2:]
        recording = base_path
        # extract time:
        start_time = None
        window_time = None
        rs = recording.split(&#39;-&#39;)
        if len(rs) &gt; 0 and rs[-1][0] == &#39;t&#39;:
            start_time = float(rs[-1][1:-1])
            rs = rs[:-1]
        # extract channel:
        channel = None
        if len(rs) &gt; 0 and rs[-1][0] == &#39;c&#39;:
            channel = int(rs[-1][1:])
            rs = rs[:-1]
        recording = &#39;-&#39;.join(rs)
        file_pathes.append(os.path.normpath(recording).split(os.path.sep))
        if verbose &gt; 2:
            print(&#39;processing %s (%s):&#39; % (file_name, recording))
        # find row in meta_data:
        mr = -1
        if meta_data is not None:
            mr = find_recording(recording, meta_recordings)
            if mr &lt; 0:
                if skip_recordings:
                    if verbose &gt; 0:
                        print(&#39;skip recording %s: no metadata found&#39; % recording)
                    continue
                elif verbose &gt; 0:
                    print(&#39;no metadata found for recording %s&#39; % recording)
            else:
                meta_recordings_used[mr] = True
        # data:
        data = TableData(file_name)
        if &#39;tstart&#39; in data:
            start_time = data[0, &#39;tstart&#39;]
            window_time = data[0, &#39;twindow&#39;]
            data.remove([&#39;tstart&#39;, &#39;twindow&#39;])
        table = wave_table if fish_type == &#39;wave&#39; else pulse_table
        # prepare tables:
        if not table:
            df = TableData(data)
            df.clear_data()
            if meta_data is not None:
                if data.nsecs &gt; 0:
                    df.insert_section(0, &#39;metadata&#39;)
                for c in range(meta_data.columns()):
                    df.insert(c, *meta_data.column_head(c))
            df.insert(0, [&#39;recording&#39;]*data.nsecs + [&#39;file&#39;], &#39;&#39;, &#39;%-s&#39;)
            if window_time is not None:
                df.insert(1, &#39;window&#39;, &#39;s&#39;, &#39;%.2f&#39;)
            if start_time is not None:
                df.insert(1, &#39;time&#39;, &#39;s&#39;, &#39;%.2f&#39;)
            if channel is not None:
                df.insert(1, &#39;channel&#39;, &#39;&#39;, &#39;%d&#39;)
            if fish_type == &#39;wave&#39;:
                if harmonics is not None:
                    wave_spec = TableData(base_path + &#39;-wavespectrum-0&#39; + file_ext)
                    if data.nsecs &gt; 0:
                        df.append_section(&#39;harmonics&#39;)
                    for h in range(min(harmonics, wave_spec.rows())+1):
                        df.append(&#39;ampl%d&#39; % h, wave_spec.unit(&#39;amplitude&#39;),
                                      wave_spec.format(&#39;amplitude&#39;))
                        if h &gt; 0:
                            df.append(&#39;relampl%d&#39; % h, &#39;%&#39;, &#39;%.2f&#39;)
                            df.append(&#39;relpower%d&#39; % h, &#39;%&#39;, &#39;%.2f&#39;)
                        df.append(&#39;phase%d&#39; % h, &#39;rad&#39;, &#39;%.3f&#39;)
                if len(wave_names) &gt; 0:
                    if data.nsecs &gt; 0:
                        df.append_section(&#39;species&#39;)
                    for species in wave_names:
                        df.append(species, &#39;%&#39;, &#39;%.0f&#39;)
                    df.append(&#39;species&#39;, &#39;&#39;, &#39;%-s&#39;)
            else:
                if peaks0 is not None:
                    pulse_peaks = TableData(base_path + &#39;-pulsepeaks-0&#39; + file_ext)
                    if data.nsecs &gt; 0:
                        df.append_section(&#39;peaks&#39;)
                    for p in range(peaks0, peaks1+1):
                        if p != 1:
                            df.append(&#39;P%dtime&#39; % p, &#39;ms&#39;, &#39;%.3f&#39;)
                        df.append(&#39;P%dampl&#39; % p, pulse_peaks.unit(&#39;amplitude&#39;),
                                  pulse_peaks.format(&#39;amplitude&#39;))
                        if p != 1:
                            df.append(&#39;P%drelampl&#39; % p, &#39;%&#39;, &#39;%.2f&#39;)
                        df.append(&#39;P%dwidth&#39; % p, &#39;ms&#39;, &#39;%.3f&#39;)
                if len(pulse_names) &gt; 0:
                    if data.nsecs &gt; 0:
                        df.append_section(&#39;species&#39;)
                    for species in pulse_names:
                        df.append(species, &#39;%&#39;, &#39;%.0f&#39;)
                    df.append(&#39;species&#39;, &#39;&#39;, &#39;%-s&#39;)
            if fish_type == &#39;wave&#39;:
                wave_table = df
                table = wave_table
            else:
                pulse_table = df
                table = pulse_table
            if not all_table:
                df = TableData()
                df.append(&#39;file&#39;, &#39;&#39;, &#39;%-s&#39;)
                if start_time is not None:
                    df.append(&#39;time&#39;, &#39;s&#39;, &#39;%.1f&#39;)
                if window_time is not None:
                    df.append(&#39;window&#39;, &#39;s&#39;, &#39;%.1f&#39;)
                if channel is not None:
                    df.append(&#39;channel&#39;, &#39;&#39;, &#39;%d&#39;)
                if meta_data is not None:
                    for c in range(meta_data.columns()):
                        df.append(*meta_data.column_head(c))
                df.append(&#39;index&#39;, &#39;&#39;, &#39;%d&#39;)
                df.append(&#39;EODf&#39;, &#39;Hz&#39;, &#39;%.1f&#39;)
                df.append(&#39;type&#39;, &#39;&#39;, &#39;%-5s&#39;)
                if len(wave_names) + len(pulse_names) &gt; 0:
                    df.append(&#39;species&#39;, &#39;&#39;, &#39;%-s&#39;)
                all_table = df
        # fill tables:
        n = data.rows() if not max_fish or max_fish &gt; data.rows() else max_fish
        for r in range(n):
            # fish index:
            idx = r
            if &#39;index&#39; in data:
                idx = data[r,&#39;index&#39;]
            # check quality:
            skips = &#39;&#39;
            if fish_type == &#39;wave&#39;:
                wave_spec = TableData(base_path + &#39;-wavespectrum-%d&#39;%idx + file_ext)
                if cfg is not None:
                    spec_data = wave_spec.array()
                    props = data.row_dict(r)
                    if &#39;clipped&#39; in props:
                        props[&#39;clipped&#39;] *= 0.01 
                    if &#39;noise&#39; in props:
                        props[&#39;noise&#39;] *= 0.01 
                    if &#39;rmserror&#39; in props:
                        props[&#39;rmserror&#39;] *= 0.01 
                    if &#39;thd&#39; in props:
                        props[&#39;thd&#39;] *= 0.01 
                    _, skips, msg = wave_quality(props, 0.01*spec_data[1:,3],
                                                 **wave_quality_args(cfg))
            else:
                if cfg is not None:
                    props = data.row_dict(r)
                    if &#39;clipped&#39; in props:
                        props[&#39;clipped&#39;] *= 0.01 
                    if &#39;noise&#39; in props:
                        props[&#39;noise&#39;] *= 0.01
                    skips, msg, _ = pulse_quality(props, **pulse_quality_args(cfg))
            if len(skips) &gt; 0:
                if verbose &gt; 1:
                    print(&#39;skip fish %2d from %s: %s&#39; % (idx, recording, skips))
                continue
            # fill in data:
            data_col = 0
            table.append_data(recording, data_col)
            all_table.append_data(recording, data_col)
            data_col += 1
            if channel is not None:
                table.append_data(channel, data_col)
                all_table.append_data(channel, data_col)
                data_col += 1
            if start_time is not None:
                table.append_data(start_time, data_col)
                all_table.append_data(start_time, data_col)
                data_col += 1
            if window_time is not None:
                table.append_data(window_time, data_col)
                all_table.append_data(window_time, data_col)
                data_col += 1
            # meta data:
            if mr &gt;= 0:
                for c in range(meta_data.columns()):
                    table.append_data(meta_data[mr,c], data_col)
                    all_table.append_data(meta_data[mr,c], data_col)
                    data_col += 1
            elif meta_data is not None:
                data_col += meta_data.columns()
            table.append_data(data[r,:].array(), data_col)
            eodf = data[r,&#39;EODf&#39;]
            all_table.append_data(data[r,&#39;index&#39;], data_col)
            all_table.append_data(eodf)
            all_table.append_data(fish_type)
            species_name = &#39;unknown&#39;
            species_rms = 1.0e12
            if fish_type == &#39;wave&#39;:
                if harmonics is not None:
                    for h in range(min(harmonics, wave_spec.rows())+1):
                        table.append_data(wave_spec[h,&#39;amplitude&#39;])
                        if h &gt; 0:
                            table.append_data(wave_spec[h,&#39;relampl&#39;])
                            table.append_data(wave_spec[h,&#39;relpower&#39;])
                        table.append_data(wave_spec[h,&#39;phase&#39;])
                if len(wave_names) &gt; 0:
                    wave_eod = TableData(base_path + &#39;-eodwaveform-%d&#39;%idx + file_ext).array()
                    wave_eod[:,0] *= 0.001
                    for species, eod in zip(wave_names, wave_eods):
                        rms = wave_similarity(eod, wave_eod, 1.0, eodf)
                        if rms &lt; species_rms and rms &lt; wave_max_rms:
                            species_name = species
                            species_rms = rms
                        table.append_data(100.0*rms)
                    table.append_data(species_name)
            else:
                if peaks0 is not None:
                    pulse_peaks = TableData(base_path + &#39;-pulsepeaks-%d&#39;%idx + file_ext)
                    for p in range(peaks0, peaks1+1):
                        for pr in range(pulse_peaks.rows()):
                            if pulse_peaks[pr,&#39;P&#39;] == p:
                                break
                        else:
                            continue
                        if p != 1:
                            table.append_data(pulse_peaks[pr,&#39;time&#39;], &#39;P%dtime&#39; % p)
                        table.append_data(pulse_peaks[pr,&#39;amplitude&#39;], &#39;P%dampl&#39; % p)
                        if p != 1:
                            table.append_data(pulse_peaks[pr,&#39;relampl&#39;], &#39;P%drelampl&#39; % p)
                        table.append_data(pulse_peaks[pr,&#39;width&#39;], &#39;P%dwidth&#39; % p)
                if len(pulse_names) &gt; 0:
                    pulse_eod = TableData(base_path + &#39;-eodwaveform-%d&#39;%idx + file_ext).array()
                    pulse_eod[:,0] *= 0.001
                    for species, eod in zip(pulse_names, pulse_eods):
                        rms = pulse_similarity(eod, pulse_eod)
                        if rms &lt; species_rms and rms &lt; pulse_max_rms:
                            species_name = species
                            species_rms = rms
                        table.append_data(100.0*rms)
                    table.append_data(species_name)
            if len(wave_names) + len(pulse_names) &gt; 0:
                all_table.append_data(species_name)
            table.fill_data()
            all_table.fill_data()
    # check coverage of meta data:
    if meta_recordings_used is not None:
        if np.all(meta_recordings_used):
            if verbose &gt; 0:
                print(&#39;found recordings for all meta data&#39;)
        else:
            if verbose &gt; 0:
                print(&#39;no recordings found for:&#39;)
            for mr in range(len(meta_recordings)):
                recording = meta_recordings[mr]
                if not meta_recordings_used[mr]:
                    if verbose &gt; 0:
                        print(recording)
                    all_table.set_column(0)
                    all_table.append_data(recording)
                    for c in range(meta_data.columns()):
                        all_table.append_data(meta_data[mr,c])
                    all_table.append_data(np.nan) # index
                    all_table.append_data(np.nan) # EODf
                    all_table.append_data(&#39;none&#39;) # type
    # adjust EODf to mean temperature:
    for table in [wave_table, pulse_table, all_table]:
        if table is not None and temp_col is not None:
            eodf_idx = table.index(&#39;EODf&#39;)
            table.insert(eodf_idx+1, &#39;EODf_adjust&#39;, &#39;Hz&#39;, &#39;%.1f&#39;)
            table.fill_data()
            temp_idx = table.index(temp_col)
            tadjust_idx = table.index(&#39;T_adjust&#39;)
            for r in range(table.rows()):
                eodf = table[r,eodf_idx]
                if np.isfinite(table[r,temp_col]) and np.isfinite(table[r,tadjust_idx]):
                    eodf = adjust_eodf(eodf, table[r,temp_col], table[r,tadjust_idx], q10)
                table[r,eodf_idx+1] = eodf
    # add wavefish species (experimental):
    # simplify pathes:
    if simplify_file and len(file_pathes) &gt; 1:
        fp0 = file_pathes[0]
        for fi in range(len(fp0)):
            is_same = True
            for fp in file_pathes[1:]:
                if fi &gt;= len(fp) or fp[fi] != fp0[fi]:
                    is_same = False
                    break
            if not is_same:
                break
        for table in [wave_table, pulse_table, all_table]:
            if table is not None:
                for k in range(table.rows()):
                    idx = table.index(&#39;file&#39;)
                    fps = os.path.normpath(table[k,idx]).split(os.path.sep)
                    table[k,idx] = os.path.sep.join(fps[fi:])
    return wave_table, pulse_table, all_table

    
def rangestr(string):
    &#34;&#34;&#34;
    Parse string of the form N:M .
    &#34;&#34;&#34;
    if string[0] == &#39;=&#39;:
        string = &#39;-&#39; + string[1:]
    ss = string.split(&#39;:&#39;)
    v0 = v1 = None
    if len(ss) == 1:
        v0 = int(string)
        v1 = v0
    else:
        v0 = int(ss[0])
        v1 = int(ss[1])
    return (v0, v1)


def main(cargs=None):
    # command line arguments:
    if cargs is None:
        cargs = sys.argv[1:]
    parser = argparse.ArgumentParser(add_help=True,
        description=&#39;Collect data generated by thunderfish in a wavefish and a pulsefish table.&#39;,
        epilog=&#39;version %s by Benda-Lab (2019-%s)&#39; % (__version__, __year__))
    parser.add_argument(&#39;--version&#39;, action=&#39;version&#39;, version=__version__)
    parser.add_argument(&#39;-v&#39;, action=&#39;count&#39;, dest=&#39;verbose&#39;, default=0,
                        help=&#39;verbosity level: -v for meta data coverage, -vv for additional info on discarded recordings.&#39;)
    parser.add_argument(&#39;-t&#39;, dest=&#39;table_type&#39;, default=None, choices=[&#39;wave&#39;, &#39;pulse&#39;],
                        help=&#39;wave-type or pulse-type fish&#39;)
    parser.add_argument(&#39;-c&#39;, dest=&#39;simplify_file&#39;, action=&#39;store_true&#39;,
                        help=&#39;remove initial common directories from input files&#39;)
    parser.add_argument(&#39;-m&#39;, dest=&#39;max_fish&#39;, type=int, metavar=&#39;N&#39;,
                        help=&#39;maximum number of fish to be taken from each recording&#39;)
    parser.add_argument(&#39;-p&#39;, dest=&#39;pulse_peaks&#39;, type=rangestr,
                        default=(0, 1), metavar=&#39;N:M&#39;,
                        help=&#39;add properties of peak N to M of pulse-type EODs to the table&#39;)
    parser.add_argument(&#39;-w&#39;, dest=&#39;harmonics&#39;, type=int, default=3, metavar=&#39;N&#39;,
                        help=&#39;add properties of first N harmonics of wave-type EODs to the table&#39;)
    parser.add_argument(&#39;-r&#39;, dest=&#39;remove_cols&#39;, action=&#39;append&#39;, default=[], metavar=&#39;COLUMN&#39;,
                        help=&#39;columns to be removed from output table&#39;)
    parser.add_argument(&#39;-s&#39;, dest=&#39;statistics&#39;, action=&#39;store_true&#39;,
                        help=&#39;also write table with statistics&#39;)
    parser.add_argument(&#39;-i&#39;, dest=&#39;meta_file&#39;, metavar=&#39;FILE:REC:TEMP&#39;, default=&#39;&#39;, type=str,
                        help=&#39;insert rows from metadata table in FILE matching recording in colum REC. The optional TEMP specifies a column with temperatures to which EOD frequencies should be adjusted&#39;)
    parser.add_argument(&#39;-q&#39;, dest=&#39;q10&#39;, metavar=&#39;Q10&#39;, default=1.62, type=float,
                        help=&#39;Q10 value for adjusting EOD frequencies to a common temperature&#39;)
    parser.add_argument(&#39;-S&#39;, dest=&#39;skip&#39;, action=&#39;store_true&#39;,
                        help=&#39;skip recordings that are not contained in metadata table&#39;)
    parser.add_argument(&#39;-n&#39;, dest=&#39;file_suffix&#39;, metavar=&#39;NAME&#39;, default=&#39;&#39;, type=str,
                        help=&#39;name for summary files that is appended to &#34;wavefish&#34; or &#34;pulsefish&#34;&#39;)
    parser.add_argument(&#39;-o&#39;, dest=&#39;out_path&#39;, metavar=&#39;PATH&#39;, default=&#39;.&#39;, type=str,
                        help=&#39;path where to store summary tables&#39;)
    parser.add_argument(&#39;-f&#39;, dest=&#39;format&#39;, default=&#39;auto&#39;, type=str,
                        choices=TableData.formats + [&#39;same&#39;],
                        help=&#39;file format used for saving summary tables (&#34;same&#34; uses same format as input files)&#39;)
    parser.add_argument(&#39;file&#39;, nargs=&#39;+&#39;, default=&#39;&#39;, type=str,
                        help=&#39;a *-wavefish.* or *-pulsefish.* file as generated by thunderfish&#39;)
    # fix minus sign issue:
    ca = []
    pa = False
    for a in cargs:
        if pa and a[0] == &#39;-&#39;:
            a = &#39;=&#39; + a[1:]
        pa = False
        if a == &#39;-p&#39;:
            pa = True
        ca.append(a)
    # read in command line arguments:    
    args = parser.parse_args(ca)
    verbose = args.verbose
    table_type = args.table_type
    remove_cols = args.remove_cols
    statistics = args.statistics
    meta_file = args.meta_file
    file_suffix = args.file_suffix
    out_path = args.out_path
    data_format = args.format
    
    # expand wildcard patterns:
    files = []
    if os.name == &#39;nt&#39;:
        for fn in args.file:
            files.extend(glob.glob(fn))
    else:
        files = args.file
        
    # read configuration:
    cfgfile = __package__ + &#39;.cfg&#39;
    cfg = ConfigFile()
    add_harmonic_groups_config(cfg)
    add_eod_quality_config(cfg)
    add_species_config(cfg)
    add_write_table_config(cfg, table_format=&#39;csv&#39;, unit_style=&#39;row&#39;,
                           align_columns=True, shrink_width=False)
    cfg.load_files(cfgfile, files[0], 3)
    # output format:
    if data_format == &#39;same&#39;:
        ext = os.path.splitext(files[0])[1][1:]
        if ext in TableData.ext_formats:
            data_format = TableData.ext_formats[ext]
        else:
            data_format = &#39;dat&#39;
    if data_format != &#39;auto&#39;:
        cfg.set(&#39;fileFormat&#39;, data_format)
    # create output folder:
    if not os.path.exists(out_path):
        os.makedirs(out_path)
    # read in meta file:
    md = None
    rec_data = None
    temp_col = None
    if len(meta_file) &gt; 0:
        mds = meta_file.split(&#39;:&#39;)
        meta_data = mds[0]
        if not os.path.isfile(meta_data):
            print(&#39;meta data file &#34;%s&#34; not found.&#39; % meta_data)
            exit()
        md = TableData(meta_data)
        if len(mds) &lt; 2:
            print(&#39;no recording column specified for the table in %s. Choose one of&#39; % meta_data)
            for k in md.keys():
                print(&#39; &#39;, k)
            exit()
        rec_col = mds[1]
        if rec_col not in md:
            print(&#39;%s is not a valid key for the table in %s. Choose one of&#39; % (rec_col, meta_data))
            for k in md.keys():
                print(&#39; &#39;, k)
            exit()
        else:
            rec_data = md[:,rec_col]
            del md[:,rec_col]
        if len(mds) &gt; 2:
            temp_col = mds[2]
            if temp_col not in md:
                print(&#39;%s is not a valid key for the table in %s. Choose one of&#39; % (temp_col, meta_data))
                for k in md.keys():
                    print(&#39; &#39;, k)
                exit()
    # collect files:
    wave_table, pulse_table, all_table = collect_fish(files, args.simplify_file,
                                           md, rec_data, args.skip,
                                           temp_col, args.q10,
                                           args.max_fish, args.harmonics,
                                           args.pulse_peaks[0],  args.pulse_peaks[1],
                                           cfg, verbose)
    # write tables:
    if len(file_suffix) &gt; 0 and file_suffix[0] != &#39;-&#39;:
        file_suffix = &#39;-&#39; + file_suffix
    tables = []
    table_names = []
    if pulse_table and (not table_type or table_type == &#39;pulse&#39;):
        tables.append(pulse_table)
        table_names.append(&#39;pulse&#39;)
    if wave_table and (not table_type or table_type == &#39;wave&#39;):
        tables.append(wave_table)
        table_names.append(&#39;wave&#39;)
    if all_table and not table_type:
        tables.append(all_table)
        table_names.append(&#39;all&#39;)
    for table, name in zip(tables, table_names):
        for rc in remove_cols:
            if rc in table:
                table.remove(rc)
        table.write(os.path.join(out_path, &#39;%sfish%s&#39; % (name, file_suffix)),
                    **write_table_args(cfg))
        if statistics:
            s = table.statistics()
            s.write(os.path.join(out_path, &#39;%sfish%s-statistics&#39; % (name, file_suffix)),
                    **write_table_args(cfg))


if __name__ == &#39;__main__&#39;:
    main()</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="thunderfish.collectfish.collect_fish"><code class="name flex">
<span>def <span class="ident">collect_fish</span></span>(<span>files, simplify_file=False, meta_data=None, meta_recordings=None, skip_recordings=False, temp_col=None, q10=1.62, max_fish=0, harmonics=None, peaks0=None, peaks1=None, cfg=None, verbose=0)</span>
</code></dt>
<dd>
<div class="desc"><p>Combine all <em>-wavefish.</em> and/or <em>-pulsefish.</em> files into respective summary tables.</p>
<p>Data from the <em>-wavespectrum-</em>.<em> and the </em>-pulsepeaks-<em>.</em> files can be added
as specified by <code>harmonics</code>, <code>peaks0</code>, and <code>peaks1</code>.</p>
<p>Meta data of the recordings can also be added via <code>meta_data</code> and
<code>meta_recordings</code>.
If <code>meta_data</code> contains a column with
temperature, this column can be specified by the <code>temp_col</code>
parameter. In this case, an 'T_adjust' and an 'EODf_adjust' column
are inserted into the resulting tables containing the mean
temperature and EOD frequencies adjusted to this temperature,
respectively. For the temperature adjustment of EOD frequency
a Q10 value can be supplied by the <code>q10</code> parameter.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>files</code></strong> :&ensp;<code>list</code> of <code>strings</code></dt>
<dd>Files to be combined.</dd>
<dt><strong><code>simplify_file</code></strong> :&ensp;<code>boolean</code></dt>
<dd>Remove initial common directories from input files.</dd>
<dt><strong><code>meta_data</code></strong> :&ensp;<code>TableData</code> or <code>None</code></dt>
<dd>Table with additional data for each of the recordings.
The meta data are inserted into the summary table according to
the name of the recording as specified in <code>meta_recordings</code>.</dd>
<dt><strong><code>meta_recordings</code></strong> :&ensp;<code>array</code> of <code>strings</code></dt>
<dd>For each row in <code>meta_data</code> the name of the recording.
This name is matched agains the basename of input <code>files</code>.</dd>
<dt><strong><code>skip_recordings</code></strong> :&ensp;<code>bool</code></dt>
<dd>If True skip recordings that are not found in <code>meta_recordings</code>.</dd>
<dt><strong><code>temp_col</code></strong> :&ensp;<code>string</code> or <code>None</code></dt>
<dd>A column in <code>meta_data</code> with temperatures to which EOD
frequences should be adjusted.</dd>
<dt><strong><code>q10</code></strong> :&ensp;<code>float</code></dt>
<dd>Q10 value describing temperature dependence of EOD
frequencies.
The default of 1.62 is from Dunlap, Smith, Yetka
(2000) Brain Behav Evol, measured for Apteronotus
lepthorhynchus in the lab.</dd>
<dt><strong><code>max_fish</code></strong> :&ensp;<code>int</code></dt>
<dd>Maximum number of fish to be taken, if 0 take all.</dd>
<dt><strong><code>harmonics</code></strong> :&ensp;<code>int</code></dt>
<dd>Number of harmonic to be added to the wave-type fish table
(amplitude, relampl, phase).
This data is read in from the
corresponding <em>-wavespectrum-</em>.* files.</dd>
<dt><strong><code>peaks0</code></strong> :&ensp;<code>int</code></dt>
<dd>Index of the first peak of a EOD pulse to be added to the
pulse-type fish table.
This data is read in from the
corresponding <em>-pulsepeaks-</em>.* files.</dd>
<dt><strong><code>peaks1</code></strong> :&ensp;<code>int</code></dt>
<dd>Index of the last peak of a EOD pulse to be added to the
pulse-type fish table.
This data is read in from the
corresponding <em>-pulsepeaks-</em>.* files.</dd>
<dt><strong><code>cfg</code></strong> :&ensp;<code>ConfigFile</code></dt>
<dd>Configuration parameter for EOD quality assessment and species
assignment.</dd>
<dt><strong><code>verbose</code></strong> :&ensp;<code>int</code></dt>
<dd>
<p>Verbose output:</p>
<p>1: print infos on meta data coverage.
2: print additional infos on discarded recordings.</p>
</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>wave_table</code></strong> :&ensp;<code>TableData</code></dt>
<dd>Summary table for all wave-type fish.</dd>
<dt><strong><code>pulse_table</code></strong> :&ensp;<code>TableData</code></dt>
<dd>Summary table for all pulse-type fish.</dd>
<dt><strong><code>all_table</code></strong> :&ensp;<code>TableData</code></dt>
<dd>Summary table for all wave-type and pulse-type fish.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def collect_fish(files, simplify_file=False,
                 meta_data=None, meta_recordings=None, skip_recordings=False,
                 temp_col=None, q10=1.62, max_fish=0, harmonics=None,
                 peaks0=None, peaks1=None, cfg=None, verbose=0):
    &#34;&#34;&#34;Combine all *-wavefish.* and/or *-pulsefish.* files into respective summary tables.

    Data from the *-wavespectrum-*.* and the *-pulsepeaks-*.* files can be added
    as specified by `harmonics`, `peaks0`, and `peaks1`.

    Meta data of the recordings can also be added via `meta_data` and
    `meta_recordings`.  If `meta_data` contains a column with
    temperature, this column can be specified by the `temp_col`
    parameter. In this case, an &#39;T_adjust&#39; and an &#39;EODf_adjust&#39; column
    are inserted into the resulting tables containing the mean
    temperature and EOD frequencies adjusted to this temperature,
    respectively. For the temperature adjustment of EOD frequency
    a Q10 value can be supplied by the `q10` parameter.

    Parameters
    ----------
    files: list of strings
        Files to be combined.
    simplify_file: boolean
        Remove initial common directories from input files.
    meta_data: TableData or None
        Table with additional data for each of the recordings.
        The meta data are inserted into the summary table according to
        the name of the recording as specified in `meta_recordings`.
    meta_recordings: array of strings
        For each row in `meta_data` the name of the recording.
        This name is matched agains the basename of input `files`.
    skip_recordings: bool
        If True skip recordings that are not found in `meta_recordings`.
    temp_col: string or None
        A column in `meta_data` with temperatures to which EOD
        frequences should be adjusted.
    q10: float
        Q10 value describing temperature dependence of EOD
        frequencies.  The default of 1.62 is from Dunlap, Smith, Yetka
        (2000) Brain Behav Evol, measured for Apteronotus
        lepthorhynchus in the lab.
    max_fish: int
        Maximum number of fish to be taken, if 0 take all.
    harmonics: int
        Number of harmonic to be added to the wave-type fish table
        (amplitude, relampl, phase).  This data is read in from the
        corresponding *-wavespectrum-*.* files.
    peaks0: int
        Index of the first peak of a EOD pulse to be added to the
        pulse-type fish table.  This data is read in from the
        corresponding *-pulsepeaks-*.* files.
    peaks1: int
        Index of the last peak of a EOD pulse to be added to the
        pulse-type fish table.  This data is read in from the
        corresponding *-pulsepeaks-*.* files.
    cfg: ConfigFile
        Configuration parameter for EOD quality assessment and species
        assignment.
    verbose: int
        Verbose output:
        
        1: print infos on meta data coverage.
        2: print additional infos on discarded recordings.

    Returns
    -------
    wave_table: TableData
        Summary table for all wave-type fish.
    pulse_table: TableData
        Summary table for all pulse-type fish.
    all_table: TableData
        Summary table for all wave-type and pulse-type fish.

    &#34;&#34;&#34;
    def find_recording(recording, meta_recordings):
        &#34;&#34;&#34; Find row of a recording in meta data.

        Parameters
        ----------
        recording: string
            Base name of a recording.
        meta_recordings: list of string
            List of meta data recordings where to find `recording`.
        &#34;&#34;&#34;
        if meta_data is not None:
            rec = os.path.splitext(os.path.basename(recording))[0]
            for i in range(len(meta_recordings)):
                if rec == meta_recordings[i]:
                    return i
        return -1
        
    # prepare meta recodings names:
    meta_recordings_used = None
    if meta_recordings is not None:
        meta_recordings_used = np.zeros(len(meta_recordings), dtype=np.bool)
        for r in range(len(meta_recordings)):
            meta_recordings[r] = os.path.splitext(os.path.basename(meta_recordings[r]))[0]
    # prepare adjusted temperatures:
    if meta_data is not None and temp_col is not None:
        temp_idx = meta_data.index(temp_col)
        temp = meta_data[:,temp_idx]
        mean_tmp = np.round(np.nanmean(temp)/0.1)*0.1
        meta_data.insert(temp_idx+1, &#39;T_adjust&#39;, &#39;C&#39;, &#39;%.1f&#39;)
        meta_data.append_data_column([mean_tmp]*meta_data.rows(), temp_idx+1)
    # prepare species distances:
    wave_names, wave_eods, pulse_names, pulse_eods = \
      load_species_waveforms(cfg.value(&#39;speciesFile&#39;))
    wave_max_rms = cfg.value(&#39;maximumWaveSpeciesRMS&#39;)
    pulse_max_rms = cfg.value(&#39;maximumPulseSpeciesRMS&#39;)
    # load data:    
    wave_table = None
    pulse_table = None
    all_table = None
    file_pathes = []
    for file_name in files:
        # file name:
        table = None
        base_path, file_ext = os.path.splitext(file_name)[0:2]
        if base_path.endswith(&#39;-pulsefish&#39;):
            base_path = base_path[:-10]
            fish_type = &#39;pulse&#39;
        elif base_path.endswith(&#39;-wavefish&#39;):
            base_path = base_path[:-9]
            fish_type = &#39;wave&#39;
        else:
            continue
        if base_path.startswith(&#39;./&#39;):
            base_path = base_path[2:]
        recording = base_path
        # extract time:
        start_time = None
        window_time = None
        rs = recording.split(&#39;-&#39;)
        if len(rs) &gt; 0 and rs[-1][0] == &#39;t&#39;:
            start_time = float(rs[-1][1:-1])
            rs = rs[:-1]
        # extract channel:
        channel = None
        if len(rs) &gt; 0 and rs[-1][0] == &#39;c&#39;:
            channel = int(rs[-1][1:])
            rs = rs[:-1]
        recording = &#39;-&#39;.join(rs)
        file_pathes.append(os.path.normpath(recording).split(os.path.sep))
        if verbose &gt; 2:
            print(&#39;processing %s (%s):&#39; % (file_name, recording))
        # find row in meta_data:
        mr = -1
        if meta_data is not None:
            mr = find_recording(recording, meta_recordings)
            if mr &lt; 0:
                if skip_recordings:
                    if verbose &gt; 0:
                        print(&#39;skip recording %s: no metadata found&#39; % recording)
                    continue
                elif verbose &gt; 0:
                    print(&#39;no metadata found for recording %s&#39; % recording)
            else:
                meta_recordings_used[mr] = True
        # data:
        data = TableData(file_name)
        if &#39;tstart&#39; in data:
            start_time = data[0, &#39;tstart&#39;]
            window_time = data[0, &#39;twindow&#39;]
            data.remove([&#39;tstart&#39;, &#39;twindow&#39;])
        table = wave_table if fish_type == &#39;wave&#39; else pulse_table
        # prepare tables:
        if not table:
            df = TableData(data)
            df.clear_data()
            if meta_data is not None:
                if data.nsecs &gt; 0:
                    df.insert_section(0, &#39;metadata&#39;)
                for c in range(meta_data.columns()):
                    df.insert(c, *meta_data.column_head(c))
            df.insert(0, [&#39;recording&#39;]*data.nsecs + [&#39;file&#39;], &#39;&#39;, &#39;%-s&#39;)
            if window_time is not None:
                df.insert(1, &#39;window&#39;, &#39;s&#39;, &#39;%.2f&#39;)
            if start_time is not None:
                df.insert(1, &#39;time&#39;, &#39;s&#39;, &#39;%.2f&#39;)
            if channel is not None:
                df.insert(1, &#39;channel&#39;, &#39;&#39;, &#39;%d&#39;)
            if fish_type == &#39;wave&#39;:
                if harmonics is not None:
                    wave_spec = TableData(base_path + &#39;-wavespectrum-0&#39; + file_ext)
                    if data.nsecs &gt; 0:
                        df.append_section(&#39;harmonics&#39;)
                    for h in range(min(harmonics, wave_spec.rows())+1):
                        df.append(&#39;ampl%d&#39; % h, wave_spec.unit(&#39;amplitude&#39;),
                                      wave_spec.format(&#39;amplitude&#39;))
                        if h &gt; 0:
                            df.append(&#39;relampl%d&#39; % h, &#39;%&#39;, &#39;%.2f&#39;)
                            df.append(&#39;relpower%d&#39; % h, &#39;%&#39;, &#39;%.2f&#39;)
                        df.append(&#39;phase%d&#39; % h, &#39;rad&#39;, &#39;%.3f&#39;)
                if len(wave_names) &gt; 0:
                    if data.nsecs &gt; 0:
                        df.append_section(&#39;species&#39;)
                    for species in wave_names:
                        df.append(species, &#39;%&#39;, &#39;%.0f&#39;)
                    df.append(&#39;species&#39;, &#39;&#39;, &#39;%-s&#39;)
            else:
                if peaks0 is not None:
                    pulse_peaks = TableData(base_path + &#39;-pulsepeaks-0&#39; + file_ext)
                    if data.nsecs &gt; 0:
                        df.append_section(&#39;peaks&#39;)
                    for p in range(peaks0, peaks1+1):
                        if p != 1:
                            df.append(&#39;P%dtime&#39; % p, &#39;ms&#39;, &#39;%.3f&#39;)
                        df.append(&#39;P%dampl&#39; % p, pulse_peaks.unit(&#39;amplitude&#39;),
                                  pulse_peaks.format(&#39;amplitude&#39;))
                        if p != 1:
                            df.append(&#39;P%drelampl&#39; % p, &#39;%&#39;, &#39;%.2f&#39;)
                        df.append(&#39;P%dwidth&#39; % p, &#39;ms&#39;, &#39;%.3f&#39;)
                if len(pulse_names) &gt; 0:
                    if data.nsecs &gt; 0:
                        df.append_section(&#39;species&#39;)
                    for species in pulse_names:
                        df.append(species, &#39;%&#39;, &#39;%.0f&#39;)
                    df.append(&#39;species&#39;, &#39;&#39;, &#39;%-s&#39;)
            if fish_type == &#39;wave&#39;:
                wave_table = df
                table = wave_table
            else:
                pulse_table = df
                table = pulse_table
            if not all_table:
                df = TableData()
                df.append(&#39;file&#39;, &#39;&#39;, &#39;%-s&#39;)
                if start_time is not None:
                    df.append(&#39;time&#39;, &#39;s&#39;, &#39;%.1f&#39;)
                if window_time is not None:
                    df.append(&#39;window&#39;, &#39;s&#39;, &#39;%.1f&#39;)
                if channel is not None:
                    df.append(&#39;channel&#39;, &#39;&#39;, &#39;%d&#39;)
                if meta_data is not None:
                    for c in range(meta_data.columns()):
                        df.append(*meta_data.column_head(c))
                df.append(&#39;index&#39;, &#39;&#39;, &#39;%d&#39;)
                df.append(&#39;EODf&#39;, &#39;Hz&#39;, &#39;%.1f&#39;)
                df.append(&#39;type&#39;, &#39;&#39;, &#39;%-5s&#39;)
                if len(wave_names) + len(pulse_names) &gt; 0:
                    df.append(&#39;species&#39;, &#39;&#39;, &#39;%-s&#39;)
                all_table = df
        # fill tables:
        n = data.rows() if not max_fish or max_fish &gt; data.rows() else max_fish
        for r in range(n):
            # fish index:
            idx = r
            if &#39;index&#39; in data:
                idx = data[r,&#39;index&#39;]
            # check quality:
            skips = &#39;&#39;
            if fish_type == &#39;wave&#39;:
                wave_spec = TableData(base_path + &#39;-wavespectrum-%d&#39;%idx + file_ext)
                if cfg is not None:
                    spec_data = wave_spec.array()
                    props = data.row_dict(r)
                    if &#39;clipped&#39; in props:
                        props[&#39;clipped&#39;] *= 0.01 
                    if &#39;noise&#39; in props:
                        props[&#39;noise&#39;] *= 0.01 
                    if &#39;rmserror&#39; in props:
                        props[&#39;rmserror&#39;] *= 0.01 
                    if &#39;thd&#39; in props:
                        props[&#39;thd&#39;] *= 0.01 
                    _, skips, msg = wave_quality(props, 0.01*spec_data[1:,3],
                                                 **wave_quality_args(cfg))
            else:
                if cfg is not None:
                    props = data.row_dict(r)
                    if &#39;clipped&#39; in props:
                        props[&#39;clipped&#39;] *= 0.01 
                    if &#39;noise&#39; in props:
                        props[&#39;noise&#39;] *= 0.01
                    skips, msg, _ = pulse_quality(props, **pulse_quality_args(cfg))
            if len(skips) &gt; 0:
                if verbose &gt; 1:
                    print(&#39;skip fish %2d from %s: %s&#39; % (idx, recording, skips))
                continue
            # fill in data:
            data_col = 0
            table.append_data(recording, data_col)
            all_table.append_data(recording, data_col)
            data_col += 1
            if channel is not None:
                table.append_data(channel, data_col)
                all_table.append_data(channel, data_col)
                data_col += 1
            if start_time is not None:
                table.append_data(start_time, data_col)
                all_table.append_data(start_time, data_col)
                data_col += 1
            if window_time is not None:
                table.append_data(window_time, data_col)
                all_table.append_data(window_time, data_col)
                data_col += 1
            # meta data:
            if mr &gt;= 0:
                for c in range(meta_data.columns()):
                    table.append_data(meta_data[mr,c], data_col)
                    all_table.append_data(meta_data[mr,c], data_col)
                    data_col += 1
            elif meta_data is not None:
                data_col += meta_data.columns()
            table.append_data(data[r,:].array(), data_col)
            eodf = data[r,&#39;EODf&#39;]
            all_table.append_data(data[r,&#39;index&#39;], data_col)
            all_table.append_data(eodf)
            all_table.append_data(fish_type)
            species_name = &#39;unknown&#39;
            species_rms = 1.0e12
            if fish_type == &#39;wave&#39;:
                if harmonics is not None:
                    for h in range(min(harmonics, wave_spec.rows())+1):
                        table.append_data(wave_spec[h,&#39;amplitude&#39;])
                        if h &gt; 0:
                            table.append_data(wave_spec[h,&#39;relampl&#39;])
                            table.append_data(wave_spec[h,&#39;relpower&#39;])
                        table.append_data(wave_spec[h,&#39;phase&#39;])
                if len(wave_names) &gt; 0:
                    wave_eod = TableData(base_path + &#39;-eodwaveform-%d&#39;%idx + file_ext).array()
                    wave_eod[:,0] *= 0.001
                    for species, eod in zip(wave_names, wave_eods):
                        rms = wave_similarity(eod, wave_eod, 1.0, eodf)
                        if rms &lt; species_rms and rms &lt; wave_max_rms:
                            species_name = species
                            species_rms = rms
                        table.append_data(100.0*rms)
                    table.append_data(species_name)
            else:
                if peaks0 is not None:
                    pulse_peaks = TableData(base_path + &#39;-pulsepeaks-%d&#39;%idx + file_ext)
                    for p in range(peaks0, peaks1+1):
                        for pr in range(pulse_peaks.rows()):
                            if pulse_peaks[pr,&#39;P&#39;] == p:
                                break
                        else:
                            continue
                        if p != 1:
                            table.append_data(pulse_peaks[pr,&#39;time&#39;], &#39;P%dtime&#39; % p)
                        table.append_data(pulse_peaks[pr,&#39;amplitude&#39;], &#39;P%dampl&#39; % p)
                        if p != 1:
                            table.append_data(pulse_peaks[pr,&#39;relampl&#39;], &#39;P%drelampl&#39; % p)
                        table.append_data(pulse_peaks[pr,&#39;width&#39;], &#39;P%dwidth&#39; % p)
                if len(pulse_names) &gt; 0:
                    pulse_eod = TableData(base_path + &#39;-eodwaveform-%d&#39;%idx + file_ext).array()
                    pulse_eod[:,0] *= 0.001
                    for species, eod in zip(pulse_names, pulse_eods):
                        rms = pulse_similarity(eod, pulse_eod)
                        if rms &lt; species_rms and rms &lt; pulse_max_rms:
                            species_name = species
                            species_rms = rms
                        table.append_data(100.0*rms)
                    table.append_data(species_name)
            if len(wave_names) + len(pulse_names) &gt; 0:
                all_table.append_data(species_name)
            table.fill_data()
            all_table.fill_data()
    # check coverage of meta data:
    if meta_recordings_used is not None:
        if np.all(meta_recordings_used):
            if verbose &gt; 0:
                print(&#39;found recordings for all meta data&#39;)
        else:
            if verbose &gt; 0:
                print(&#39;no recordings found for:&#39;)
            for mr in range(len(meta_recordings)):
                recording = meta_recordings[mr]
                if not meta_recordings_used[mr]:
                    if verbose &gt; 0:
                        print(recording)
                    all_table.set_column(0)
                    all_table.append_data(recording)
                    for c in range(meta_data.columns()):
                        all_table.append_data(meta_data[mr,c])
                    all_table.append_data(np.nan) # index
                    all_table.append_data(np.nan) # EODf
                    all_table.append_data(&#39;none&#39;) # type
    # adjust EODf to mean temperature:
    for table in [wave_table, pulse_table, all_table]:
        if table is not None and temp_col is not None:
            eodf_idx = table.index(&#39;EODf&#39;)
            table.insert(eodf_idx+1, &#39;EODf_adjust&#39;, &#39;Hz&#39;, &#39;%.1f&#39;)
            table.fill_data()
            temp_idx = table.index(temp_col)
            tadjust_idx = table.index(&#39;T_adjust&#39;)
            for r in range(table.rows()):
                eodf = table[r,eodf_idx]
                if np.isfinite(table[r,temp_col]) and np.isfinite(table[r,tadjust_idx]):
                    eodf = adjust_eodf(eodf, table[r,temp_col], table[r,tadjust_idx], q10)
                table[r,eodf_idx+1] = eodf
    # add wavefish species (experimental):
    # simplify pathes:
    if simplify_file and len(file_pathes) &gt; 1:
        fp0 = file_pathes[0]
        for fi in range(len(fp0)):
            is_same = True
            for fp in file_pathes[1:]:
                if fi &gt;= len(fp) or fp[fi] != fp0[fi]:
                    is_same = False
                    break
            if not is_same:
                break
        for table in [wave_table, pulse_table, all_table]:
            if table is not None:
                for k in range(table.rows()):
                    idx = table.index(&#39;file&#39;)
                    fps = os.path.normpath(table[k,idx]).split(os.path.sep)
                    table[k,idx] = os.path.sep.join(fps[fi:])
    return wave_table, pulse_table, all_table</code></pre>
</details>
</dd>
<dt id="thunderfish.collectfish.main"><code class="name flex">
<span>def <span class="ident">main</span></span>(<span>cargs=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def main(cargs=None):
    # command line arguments:
    if cargs is None:
        cargs = sys.argv[1:]
    parser = argparse.ArgumentParser(add_help=True,
        description=&#39;Collect data generated by thunderfish in a wavefish and a pulsefish table.&#39;,
        epilog=&#39;version %s by Benda-Lab (2019-%s)&#39; % (__version__, __year__))
    parser.add_argument(&#39;--version&#39;, action=&#39;version&#39;, version=__version__)
    parser.add_argument(&#39;-v&#39;, action=&#39;count&#39;, dest=&#39;verbose&#39;, default=0,
                        help=&#39;verbosity level: -v for meta data coverage, -vv for additional info on discarded recordings.&#39;)
    parser.add_argument(&#39;-t&#39;, dest=&#39;table_type&#39;, default=None, choices=[&#39;wave&#39;, &#39;pulse&#39;],
                        help=&#39;wave-type or pulse-type fish&#39;)
    parser.add_argument(&#39;-c&#39;, dest=&#39;simplify_file&#39;, action=&#39;store_true&#39;,
                        help=&#39;remove initial common directories from input files&#39;)
    parser.add_argument(&#39;-m&#39;, dest=&#39;max_fish&#39;, type=int, metavar=&#39;N&#39;,
                        help=&#39;maximum number of fish to be taken from each recording&#39;)
    parser.add_argument(&#39;-p&#39;, dest=&#39;pulse_peaks&#39;, type=rangestr,
                        default=(0, 1), metavar=&#39;N:M&#39;,
                        help=&#39;add properties of peak N to M of pulse-type EODs to the table&#39;)
    parser.add_argument(&#39;-w&#39;, dest=&#39;harmonics&#39;, type=int, default=3, metavar=&#39;N&#39;,
                        help=&#39;add properties of first N harmonics of wave-type EODs to the table&#39;)
    parser.add_argument(&#39;-r&#39;, dest=&#39;remove_cols&#39;, action=&#39;append&#39;, default=[], metavar=&#39;COLUMN&#39;,
                        help=&#39;columns to be removed from output table&#39;)
    parser.add_argument(&#39;-s&#39;, dest=&#39;statistics&#39;, action=&#39;store_true&#39;,
                        help=&#39;also write table with statistics&#39;)
    parser.add_argument(&#39;-i&#39;, dest=&#39;meta_file&#39;, metavar=&#39;FILE:REC:TEMP&#39;, default=&#39;&#39;, type=str,
                        help=&#39;insert rows from metadata table in FILE matching recording in colum REC. The optional TEMP specifies a column with temperatures to which EOD frequencies should be adjusted&#39;)
    parser.add_argument(&#39;-q&#39;, dest=&#39;q10&#39;, metavar=&#39;Q10&#39;, default=1.62, type=float,
                        help=&#39;Q10 value for adjusting EOD frequencies to a common temperature&#39;)
    parser.add_argument(&#39;-S&#39;, dest=&#39;skip&#39;, action=&#39;store_true&#39;,
                        help=&#39;skip recordings that are not contained in metadata table&#39;)
    parser.add_argument(&#39;-n&#39;, dest=&#39;file_suffix&#39;, metavar=&#39;NAME&#39;, default=&#39;&#39;, type=str,
                        help=&#39;name for summary files that is appended to &#34;wavefish&#34; or &#34;pulsefish&#34;&#39;)
    parser.add_argument(&#39;-o&#39;, dest=&#39;out_path&#39;, metavar=&#39;PATH&#39;, default=&#39;.&#39;, type=str,
                        help=&#39;path where to store summary tables&#39;)
    parser.add_argument(&#39;-f&#39;, dest=&#39;format&#39;, default=&#39;auto&#39;, type=str,
                        choices=TableData.formats + [&#39;same&#39;],
                        help=&#39;file format used for saving summary tables (&#34;same&#34; uses same format as input files)&#39;)
    parser.add_argument(&#39;file&#39;, nargs=&#39;+&#39;, default=&#39;&#39;, type=str,
                        help=&#39;a *-wavefish.* or *-pulsefish.* file as generated by thunderfish&#39;)
    # fix minus sign issue:
    ca = []
    pa = False
    for a in cargs:
        if pa and a[0] == &#39;-&#39;:
            a = &#39;=&#39; + a[1:]
        pa = False
        if a == &#39;-p&#39;:
            pa = True
        ca.append(a)
    # read in command line arguments:    
    args = parser.parse_args(ca)
    verbose = args.verbose
    table_type = args.table_type
    remove_cols = args.remove_cols
    statistics = args.statistics
    meta_file = args.meta_file
    file_suffix = args.file_suffix
    out_path = args.out_path
    data_format = args.format
    
    # expand wildcard patterns:
    files = []
    if os.name == &#39;nt&#39;:
        for fn in args.file:
            files.extend(glob.glob(fn))
    else:
        files = args.file
        
    # read configuration:
    cfgfile = __package__ + &#39;.cfg&#39;
    cfg = ConfigFile()
    add_harmonic_groups_config(cfg)
    add_eod_quality_config(cfg)
    add_species_config(cfg)
    add_write_table_config(cfg, table_format=&#39;csv&#39;, unit_style=&#39;row&#39;,
                           align_columns=True, shrink_width=False)
    cfg.load_files(cfgfile, files[0], 3)
    # output format:
    if data_format == &#39;same&#39;:
        ext = os.path.splitext(files[0])[1][1:]
        if ext in TableData.ext_formats:
            data_format = TableData.ext_formats[ext]
        else:
            data_format = &#39;dat&#39;
    if data_format != &#39;auto&#39;:
        cfg.set(&#39;fileFormat&#39;, data_format)
    # create output folder:
    if not os.path.exists(out_path):
        os.makedirs(out_path)
    # read in meta file:
    md = None
    rec_data = None
    temp_col = None
    if len(meta_file) &gt; 0:
        mds = meta_file.split(&#39;:&#39;)
        meta_data = mds[0]
        if not os.path.isfile(meta_data):
            print(&#39;meta data file &#34;%s&#34; not found.&#39; % meta_data)
            exit()
        md = TableData(meta_data)
        if len(mds) &lt; 2:
            print(&#39;no recording column specified for the table in %s. Choose one of&#39; % meta_data)
            for k in md.keys():
                print(&#39; &#39;, k)
            exit()
        rec_col = mds[1]
        if rec_col not in md:
            print(&#39;%s is not a valid key for the table in %s. Choose one of&#39; % (rec_col, meta_data))
            for k in md.keys():
                print(&#39; &#39;, k)
            exit()
        else:
            rec_data = md[:,rec_col]
            del md[:,rec_col]
        if len(mds) &gt; 2:
            temp_col = mds[2]
            if temp_col not in md:
                print(&#39;%s is not a valid key for the table in %s. Choose one of&#39; % (temp_col, meta_data))
                for k in md.keys():
                    print(&#39; &#39;, k)
                exit()
    # collect files:
    wave_table, pulse_table, all_table = collect_fish(files, args.simplify_file,
                                           md, rec_data, args.skip,
                                           temp_col, args.q10,
                                           args.max_fish, args.harmonics,
                                           args.pulse_peaks[0],  args.pulse_peaks[1],
                                           cfg, verbose)
    # write tables:
    if len(file_suffix) &gt; 0 and file_suffix[0] != &#39;-&#39;:
        file_suffix = &#39;-&#39; + file_suffix
    tables = []
    table_names = []
    if pulse_table and (not table_type or table_type == &#39;pulse&#39;):
        tables.append(pulse_table)
        table_names.append(&#39;pulse&#39;)
    if wave_table and (not table_type or table_type == &#39;wave&#39;):
        tables.append(wave_table)
        table_names.append(&#39;wave&#39;)
    if all_table and not table_type:
        tables.append(all_table)
        table_names.append(&#39;all&#39;)
    for table, name in zip(tables, table_names):
        for rc in remove_cols:
            if rc in table:
                table.remove(rc)
        table.write(os.path.join(out_path, &#39;%sfish%s&#39; % (name, file_suffix)),
                    **write_table_args(cfg))
        if statistics:
            s = table.statistics()
            s.write(os.path.join(out_path, &#39;%sfish%s-statistics&#39; % (name, file_suffix)),
                    **write_table_args(cfg))</code></pre>
</details>
</dd>
<dt id="thunderfish.collectfish.rangestr"><code class="name flex">
<span>def <span class="ident">rangestr</span></span>(<span>string)</span>
</code></dt>
<dd>
<div class="desc"><p>Parse string of the form N:M .</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def rangestr(string):
    &#34;&#34;&#34;
    Parse string of the form N:M .
    &#34;&#34;&#34;
    if string[0] == &#39;=&#39;:
        string = &#39;-&#39; + string[1:]
    ss = string.split(&#39;:&#39;)
    v0 = v1 = None
    if len(ss) == 1:
        v0 = int(string)
        v1 = v0
    else:
        v0 = int(ss[0])
        v1 = int(ss[1])
    return (v0, v1)</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="thunderfish" href="index.html">thunderfish</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="thunderfish.collectfish.collect_fish" href="#thunderfish.collectfish.collect_fish">collect_fish</a></code></li>
<li><code><a title="thunderfish.collectfish.main" href="#thunderfish.collectfish.main">main</a></code></li>
<li><code><a title="thunderfish.collectfish.rangestr" href="#thunderfish.collectfish.rangestr">rangestr</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>