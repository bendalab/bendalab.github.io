<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>thunderfish.thunderfish API documentation</title>
<meta name="description" content="thunderfish â€¦" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS_CHTML" integrity="sha256-kZafAc6mZvK3W3v1pHOcUix30OHQN6pU/NO2oFkqZVw=" crossorigin></script>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>thunderfish.thunderfish</code></h1>
</header>
<section id="section-intro">
<h1 id="thunderfish">thunderfish</h1>
<p>Automatically detect and analyze all EOD waveforms in short recordings
and generated summary plots and data tables.</p>
<p>Run it from the thunderfish development directory as:</p>
<pre><code>python3 -m thunderfish.thunderfish audiofile.wav
</code></pre>
<p>Or install thunderfish</p>
<pre><code>sudo pip3 install .
</code></pre>
<p>Then you can run it directly from every directory:</p>
<pre><code>thunderfish audiofile.wav
</code></pre>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;# thunderfish

Automatically detect and analyze all EOD waveforms in short recordings
and generated summary plots and data tables.

Run it from the thunderfish development directory as:
```
python3 -m thunderfish.thunderfish audiofile.wav
```
Or install thunderfish
```
sudo pip3 install .
```
Then you can run it directly from every directory:
```
thunderfish audiofile.wav
```
&#34;&#34;&#34;

import sys
import os
import glob
import argparse
import traceback
import numpy as np
import matplotlib.pyplot as plt
import matplotlib.gridspec as gridspec
import matplotlib.ticker as ticker
import matplotlib.lines as ml
from matplotlib.transforms import Bbox
from matplotlib.backends.backend_pdf import PdfPages
from multiprocessing import Pool, freeze_support, cpu_count
from audioio.playaudio import play, fade
from .version import __version__, __year__
from .configfile import ConfigFile
from .dataloader import load_data
from .bestwindow import add_clip_config, add_best_window_config
from .bestwindow import clip_args, best_window_args
from .bestwindow import analysis_window, plot_data_window
from .checkpulse import check_pulse, add_check_pulse_config, check_pulse_args
from .pulses import extract_pulsefish
from .powerspectrum import decibel, plot_decibel_psd, multi_psd
from .powerspectrum import add_multi_psd_config, multi_psd_args
from .harmonics import add_psd_peak_detection_config, add_harmonic_groups_config
from .harmonics import harmonic_groups, harmonic_groups_args, psd_peak_detection_args
from .harmonics import colors_markers, plot_harmonic_groups
from .consistentfishes import consistent_fishes
from .eodanalysis import eod_waveform, analyze_wave, analyze_pulse
from .eodanalysis import clipped_fraction
from .eodanalysis import plot_eod_recording, plot_pulse_eods
from .eodanalysis import plot_eod_waveform, plot_eod_snippets
from .eodanalysis import plot_pulse_spectrum, plot_wave_spectrum
from .eodanalysis import add_eod_analysis_config, eod_waveform_args
from .eodanalysis import analyze_wave_args, analyze_pulse_args
from .eodanalysis import add_species_config
from .eodanalysis import wave_quality, wave_quality_args, add_eod_quality_config
from .eodanalysis import pulse_quality, pulse_quality_args
from .eodanalysis import save_eod_waveform, save_wave_eodfs, save_wave_fish, save_pulse_fish
from .eodanalysis import save_wave_spectrum, save_pulse_spectrum, save_pulse_peaks
from .fakefish import normalize_wavefish, export_wavefish
from .tabledata import TableData, add_write_table_config, write_table_args


def configuration():
    &#34;&#34;&#34;Assemble configuration parameter for thunderfish.

    Returns
    -------
    cfg: ConfigFile
        Configuration parameters.
    &#34;&#34;&#34;
    cfg = ConfigFile()
    add_multi_psd_config(cfg)
    cfg.add(&#39;frequencyThreshold&#39;, 1.0, &#39;Hz&#39;,
            &#39;The fundamental frequency of each fish needs to be detected in each power spectrum within this threshold.&#39;)
    # TODO: make this threshold dependent on frequency resolution!
    cfg.add(&#39;minPSDAverages&#39;, 3, &#39;&#39;, &#39;Minimum number of fft averages for estimating the power spectrum.&#39;)  # needed by fishfinder
    add_psd_peak_detection_config(cfg)
    add_harmonic_groups_config(cfg)
    add_clip_config(cfg)
    cfg.add(&#39;unwrapData&#39;, False, &#39;&#39;, &#39;Unwrap clipped voltage traces.&#39;)
    add_best_window_config(cfg, win_size=8.0, w_cv_ampl=10.0)
    add_check_pulse_config(cfg)
    add_eod_analysis_config(cfg, min_pulse_win=0.004)
    del cfg[&#39;eodSnippetFac&#39;]
    del cfg[&#39;eodMinSnippet&#39;]
    del cfg[&#39;eodMinSem&#39;]
    add_eod_quality_config(cfg)
    add_species_config(cfg)
    add_write_table_config(cfg, table_format=&#39;csv&#39;, unit_style=&#39;row&#39;,
                           align_columns=True, shrink_width=False)
    return cfg


def save_configuration(cfg, config_file):
    &#34;&#34;&#34;Save configuration parameter for thunderfish to a file.

    Parameters
    ----------
    cfg: ConfigFile
        Configuration parameters and their values.
    config_file: string
        Name of the configuration file to be loaded.
    &#34;&#34;&#34;
    ext = os.path.splitext(config_file)[1]
    if ext != os.extsep + &#39;cfg&#39;:
        print(&#39;configuration file name must have .cfg as extension!&#39;)
    else:
        print(&#39;write configuration to %s ...&#39; % config_file)
        del cfg[&#39;fileColumnNumbers&#39;]
        del cfg[&#39;fileShrinkColumnWidth&#39;]
        del cfg[&#39;fileMissing&#39;]
        del cfg[&#39;fileLaTeXLabelCommand&#39;]
        del cfg[&#39;fileLaTeXMergeStd&#39;]
        cfg.dump(config_file)


def detect_eods(data, samplerate, min_clip, max_clip, name, mode,
                verbose, plot_level, cfg):
    &#34;&#34;&#34;Detect EODs of all fish present in the data.

    Parameters
    ----------
    data: array of floats
        The recording in which to detect EODs.
    samplerate: float
        Sampling rate of the dataset.
    min_clip: float
        Minimum amplitude that is not clipped.
    max_clip: float
        Maximum amplitude that is not clipped.
    name: string
        Name of the recording (e.g. its filename).
    mode: string
        Characters in the string indicate what and how to analyze:
        - &#39;w&#39;: analyze wavefish
        - &#39;p&#39;: analyze pulsefish
        - &#39;P&#39;: analyze only the pulsefish with the largest amplitude (not implemented yet) 
    verbose: int
        Print out information about EOD detection if greater than zero.
    plot_level : int
        Similar to verbosity levels, but with plots. 
    cfg: ConfigFile
        Configuration parameters.

    Returns
    -------
    psd_data: list of 2D arrays
        List of power spectra (frequencies and power) of the analysed data
        for different frequency resolutions.
    wave_eodfs: list of 2D arrays
        Frequency and power of fundamental frequency/harmonics of all wave fish.
    wave_indices: array of int
        Indices of wave fish mapping from wave_eodfs to eod_props.
        If negative, then that EOD frequency has no waveform described in eod_props.
    eod_props: list of dict
        Lists of EOD properties as returned by analyze_pulse() and analyze_wave()
        for each waveform in mean_eods.
    mean_eods: list of 2-D arrays with time, mean, sem, and fit.
        Averaged EOD waveforms of pulse and wave fish.
    spec_data: list of 2_D arrays
        For each pulsefish a power spectrum of the single pulse and for
        each wavefish the relative amplitudes and phases of the harmonics.
    peak_data: list of 2_D arrays
        For each pulse fish a list of peak properties
        (index, time, and amplitude), empty array for wave fish.
    power_thresh:  2 D array or None
        Frequency (first column) and power (second column) of threshold
        derived from single pulse spectra to discard false wave fish.
        None if no pulse fish was detected.
    skip_reason: list of string
        Reasons, why an EOD was discarded.
    &#34;&#34;&#34;
    psd_data = [[]]
    wave_eodfs = []
    wave_indices = []
    if &#39;w&#39; in mode:
        # detect wave fish:
        psd_data = multi_psd(data, samplerate, **multi_psd_args(cfg))
        h_kwargs = psd_peak_detection_args(cfg)
        h_kwargs.update(harmonic_groups_args(cfg))
        wave_eodfs_list = []
        for i, psd in enumerate(psd_data):
            wave_eodfs = harmonic_groups(psd[:,0], psd[:,1], verbose-1, **h_kwargs)[0]
            if verbose &gt; 0 and len(psd_data) &gt; 1:
                numpsdresolutions = cfg.value(&#39;numberPSDResolutions&#39;)
                print(&#39;fundamental frequencies detected in power spectrum of window %d at resolution %d:&#39;
                      % (i//numpsdresolutions, i%numpsdresolutions))
                if len(wave_eodfs) &gt; 0:
                    print(&#39;  &#39; + &#39; &#39;.join([&#39;%.1f&#39; % freq[0, 0] for freq in wave_eodfs]))
                else:
                    print(&#39;  none&#39;)
            wave_eodfs_list.append(wave_eodfs)
        wave_eodfs = consistent_fishes(wave_eodfs_list,
                                       df_th=cfg.value(&#39;frequencyThreshold&#39;))
        if verbose &gt; 0:
            if len(wave_eodfs) &gt; 0:
                print(&#39;found %2d EOD frequencies consistent in all power spectra:&#39; % len(wave_eodfs))
                print(&#39;  &#39; + &#39; &#39;.join([&#39;%.1f&#39; % freq[0, 0] for freq in wave_eodfs]))
            else:
                print(&#39;no fundamental frequencies are consistent in all power spectra&#39;)

    # analysis results:
    eod_props = []
    mean_eods = []
    spec_data = []
    peak_data = []
    power_thresh = None
    skip_reason = []
    max_pulse_amplitude = 0.0
    zoom_window = []

    if &#39;p&#39; in mode:
        # detect pulse fish:
        _, eod_times, eod_peaktimes, zoom_window, _ = extract_pulsefish(data, samplerate, verbose=verbose, plot_level=plot_level, save_path=os.path.splitext(os.path.basename(name))[0])

        #eod_times = []
        #eod_peaktimes = []
        if verbose &gt; 0:
            if len(eod_times) &gt; 0:
                print(&#39;found %2d pulsefish EODs&#39; % len(eod_times))
            else:
                print(&#39;no pulsefish EODs found&#39;)

        # analyse eod waveform of pulse-fish:
        min_freq_res = cfg.value(&#39;frequencyResolution&#39;)
        for k, (eod_ts, eod_pts) in enumerate(zip(eod_times, eod_peaktimes)):
            mean_eod, eod_times0 = \
                eod_waveform(data, samplerate, eod_ts, win_fac=0.8,
                             min_win=cfg.value(&#39;eodMinPulseSnippet&#39;),
                             min_sem=False, **eod_waveform_args(cfg))
            mean_eod, props, peaks, power = analyze_pulse(mean_eod, eod_times0,
                                                          freq_resolution=min_freq_res,
                                                          **analyze_pulse_args(cfg))
            if len(peaks) == 0:
                print(&#39;error: no peaks in pulse EOD detected&#39;)
                continue
            clipped_frac = clipped_fraction(data, samplerate, eod_times0,
                                            mean_eod, min_clip, max_clip)
            props[&#39;peaktimes&#39;] = eod_pts      # XXX that should go into analyze pulse
            props[&#39;index&#39;] = len(eod_props)
            props[&#39;clipped&#39;] = clipped_frac

            # add good waveforms only:
            skips, msg, skipped_clipped = pulse_quality(props, **pulse_quality_args(cfg))

            if len(skips) == 0:
                eod_props.append(props)
                mean_eods.append(mean_eod)
                spec_data.append(power)
                peak_data.append(peaks)
                if verbose &gt; 0:
                    print(&#39;take %6.1fHz pulse fish: %s&#39; % (props[&#39;EODf&#39;], msg))
            else:
                skip_reason += [&#39;%.1fHz pulse fish %s&#39; % (props[&#39;EODf&#39;], skips)]
                if verbose &gt; 0:
                    print(&#39;skip %6.1fHz pulse fish: %s (%s)&#39; %
                          (props[&#39;EODf&#39;], skips, msg))

            # threshold for wave fish peaks based on single pulse spectra:
            if len(skips) == 0 or skipped_clipped:
                if max_pulse_amplitude &lt; props[&#39;p-p-amplitude&#39;]:
                    max_pulse_amplitude = props[&#39;p-p-amplitude&#39;]
                i0 = np.argmin(np.abs(mean_eod[:,0]))
                i1 = len(mean_eod) - i0
                pulse_data = np.zeros(len(data))
                for t in props[&#39;peaktimes&#39;]:
                    idx = int(t*samplerate)
                    ii0 = i0 if idx-i0 &gt;= 0 else idx
                    ii1 = i1 if idx+i1 &lt; len(pulse_data) else len(pulse_data)-1-idx
                    pulse_data[idx-ii0:idx+ii1] = mean_eod[i0-ii0:i0+ii1,1]
                pulse_psd = multi_psd(pulse_data, samplerate, **multi_psd_args(cfg))
                pulse_power = pulse_psd[0][:,1]
                pulse_power *= len(data)/samplerate/props[&#39;period&#39;]/len(props[&#39;peaktimes&#39;])
                pulse_power *= 5.0
                if power_thresh is None:
                    power_thresh = pulse_psd[0]
                    power_thresh[:,1] = pulse_power
                else:
                    power_thresh[:,1] += pulse_power

        # remove wavefish below pulse fish power:
        if &#39;w&#39; in mode and power_thresh is not None:
            n = len(wave_eodfs)
            maxh = 3  # XXX make parameter
            df = power_thresh[1,0] - power_thresh[0,0]
            for k, fish in enumerate(reversed(wave_eodfs)):
                idx = np.array(fish[:maxh,0]//df, dtype=int)
                for offs in range(-2, 3):
                    nbelow = np.sum(fish[:maxh,1] &lt; power_thresh[idx+offs,1])
                    if nbelow &gt; 0:
                        wave_eodfs.pop(n-1-k)
                        if verbose &gt; 0:
                            print(&#39;skip %6.1fHz wave  fish: %2d harmonics are below pulsefish threshold&#39; % (fish[0,0], nbelow))
                        break

    if &#39;w&#39; in mode:
        # analyse EOD waveform of all wavefish:
        powers = np.array([np.sum(fish[:, 1]**2) for fish in wave_eodfs])
        power_indices = np.argsort(-powers)
        wave_indices = np.zeros(len(wave_eodfs), dtype=np.int) - 3
        for k, idx in enumerate(power_indices):
            fish = wave_eodfs[idx]
            eod_times = np.arange(0.0, len(data)/samplerate, 1.0/fish[0,0])
            mean_eod, eod_times = \
                eod_waveform(data, samplerate, eod_times, win_fac=3.0, min_win=0.0,
                             min_sem=(k==0), **eod_waveform_args(cfg))
            mean_eod, props, sdata, error_str = \
                analyze_wave(mean_eod, fish, **analyze_wave_args(cfg))
            if error_str:
                print(name + &#39;: &#39; + error_str)
            clipped_frac = clipped_fraction(data, samplerate, eod_times,
                                            mean_eod, min_clip, max_clip)
            props[&#39;n&#39;] = len(eod_times)
            props[&#39;index&#39;] = len(eod_props)
            props[&#39;clipped&#39;] = clipped_frac
            # remove wave fish that are smaller than the largest pulse fish:
            if props[&#39;p-p-amplitude&#39;] &lt; 0.01*max_pulse_amplitude:
                rm_indices = power_indices[k:]
                if verbose &gt; 0:
                    print(&#39;skip %6.1fHz wave  fish: power=%5.1fdB, p-p amplitude=%5.1fdB smaller than pulse fish=%5.1dB - 20dB&#39; %
                          (props[&#39;EODf&#39;], decibel(powers[idx]),
                           decibel(props[&#39;p-p-amplitude&#39;]), decibel(max_pulse_amplitude)))
                    for idx in rm_indices[1:]:
                        print(&#39;skip %6.1fHz wave  fish: power=%5.1fdB even smaller&#39; %
                              (wave_eodfs[idx][0,0], decibel(powers[idx])))
                wave_eodfs = [eodfs for idx, eodfs in enumerate(wave_eodfs)
                              if idx not in rm_indices]
                wave_indices = np.array([idcs for idx, idcs in enumerate(wave_indices)
                                        if idx not in rm_indices], dtype=np.int)
                break
            # add good waveforms only:
            remove, skips, msg = wave_quality(props, sdata[1:,3], **wave_quality_args(cfg))
            if len(skips) == 0:
                wave_indices[idx] = props[&#39;index&#39;]
                eod_props.append(props)
                mean_eods.append(mean_eod)
                spec_data.append(sdata)
                peak_data.append([])
                if verbose &gt; 0:
                    print(&#39;take   %6.1fHz wave  fish: %s&#39; % (props[&#39;EODf&#39;], msg))
            else:
                wave_indices[idx] = -2 if remove else -1
                skip_reason += [&#39;%.1fHz wave fish %s&#39; % (props[&#39;EODf&#39;], skips)]
                if verbose &gt; 0:
                    print(&#39;%-6s %6.1fHz wave  fish: %s (%s)&#39; %
                          (&#39;remove&#39; if remove else &#39;skip&#39;, props[&#39;EODf&#39;], skips, msg))
        wave_eodfs = [eodfs for idx, eodfs in zip(wave_indices, wave_eodfs) if idx &gt; -2]
        wave_indices = np.array([idx for idx in wave_indices if idx &gt; -2], dtype=np.int)
    return (psd_data, wave_eodfs, wave_indices, eod_props, mean_eods,
            spec_data, peak_data, power_thresh, skip_reason, zoom_window)


def remove_eod_files(output_basename, verbose, cfg):
    &#34;&#34;&#34;Remove all files from previous runs of thunderfish
    &#34;&#34;&#34;
    ff = cfg.value(&#39;fileFormat&#39;)
    if ff == &#39;py&#39;:
        fext = &#39;py&#39;
    else:
        fext = TableData.extensions[cfg.value(&#39;fileFormat&#39;)]
    # remove all files from previous runs of thunderfish:
    for fn in glob.glob(&#39;%s*.%s&#39; % (output_basename, fext)):
        os.remove(fn)
        if verbose &gt; 0:
            print(&#39;removed file %s&#39; % fn)

            
def save_eods(output_basename, eod_props, mean_eods, spec_data, peak_data,
              wave_eodfs, wave_indices, unit, verbose, cfg):
    &#34;&#34;&#34;Save analysis results of all EODs to files.
    &#34;&#34;&#34;
    if write_table_args(cfg)[&#39;table_format&#39;] == &#39;py&#39;:
        with open(output_basename+&#39;.py&#39;, &#39;w&#39;) as f:
            name = os.path.basename(output_basename)
            for k, sdata in enumerate(spec_data):
                # save wave fish only:
                if len(sdata)&gt;0 and sdata.shape[1] &gt; 2:
                    fish = dict(amplitudes=sdata[:,3], phases=sdata[:,5])
                    fish = normalize_wavefish(fish)
                    export_wavefish(fish, name+&#39;-%d_harmonics&#39; % k, f)
    else:
        # all wave fish in wave_eodfs:
        if len(wave_eodfs) &gt; 0:
            fp = save_wave_eodfs(wave_eodfs, wave_indices, output_basename,
                                 **write_table_args(cfg))
            if verbose &gt; 0:
                print(&#39;wrote file %s&#39; % fp)
        # all wave and pulse fish:
        for i, (mean_eod, sdata, pdata) in enumerate(zip(mean_eods, spec_data, peak_data)):
            fp = save_eod_waveform(mean_eod, unit, i, output_basename,
                                   **write_table_args(cfg))
            if verbose &gt; 0:
                print(&#39;wrote file %s&#39; % fp)
            # power spectrum:
            if len(sdata)&gt;0:
                if sdata.shape[1] == 2:
                    fp = save_pulse_spectrum(sdata, unit, i, output_basename,
                                             **write_table_args(cfg))
                else:
                    fp = save_wave_spectrum(sdata, unit, i, output_basename,
                                            **write_table_args(cfg))
                if verbose &gt; 0:
                    print(&#39;wrote file %s&#39; % fp)
            # peaks:
            fp = save_pulse_peaks(pdata, unit, i, output_basename,
                                  **write_table_args(cfg))
            if verbose &gt; 0 and fp is not None:
                print(&#39;wrote file %s&#39; % fp)
        # wave fish properties:
        fp = save_wave_fish(eod_props, unit, output_basename,
                            **write_table_args(cfg))
        if verbose &gt; 0 and fp:
            print(&#39;wrote file %s&#39; % fp)
        # pulse fish properties:
        fp = save_pulse_fish(eod_props, unit, output_basename,
                             **write_table_args(cfg))
        if verbose &gt; 0 and fp:
            print(&#39;wrote file %s&#39; % fp)


def plot_style():
    &#34;&#34;&#34;Set style of plots.
    &#34;&#34;&#34;
    plt.rcParams[&#39;figure.facecolor&#39;] = &#39;white&#39;
    plt.rcParams[&#39;axes.facecolor&#39;] = &#39;none&#39;
    plt.rcParams[&#39;xtick.direction&#39;] = &#39;out&#39;
    plt.rcParams[&#39;ytick.direction&#39;] = &#39;out&#39;


def axes_style(ax):
    &#34;&#34;&#34;Fix style of axes.

    Parameters
    ----------
    ax: matplotlib axes
    &#34;&#34;&#34;
    ax.spines[&#39;top&#39;].set_visible(False)
    ax.spines[&#39;right&#39;].set_visible(False)
    ax.get_xaxis().tick_bottom()
    ax.get_yaxis().tick_left()

                                
def plot_eods(base_name, raw_data, samplerate, channel, idx0, idx1, clipped,
              psd_data, wave_eodfs, wave_indices, mean_eods, eod_props, peak_data, spec_data,
              indices, unit, zoom_window, n_snippets=10, power_thresh=None, label_power=True,
              all_eods=False, spec_plots=&#39;auto&#39;, log_freq=False, min_freq=0.0, max_freq=3000.0,
              interactive=True, verbose=0):
    &#34;&#34;&#34;Creates an output plot for the thunderfish program.

    This output contains the raw trace where the analysis window is
    marked, the power-spectrum of this analysis window where the
    detected fish are marked, plots of averaged EOD plots, and
    spectra of the EOD waveforms.

    Parameters
    ----------
    base_name: string
        Basename of audio_file.
    raw_data: array
        Dataset.
    samplerate: float
        Sampling rate of the dataset.
    channel: int or None
        Channel of the recording to be put into the plot title.
        If None, do not write the channel into the title.
    idx0: float
        Index of the beginning of the analysis window in the dataset.
    idx1: float
        Index of the end of the analysis window in the dataset.
    clipped: float
        Fraction of clipped amplitudes.
    psd_data: 2D array
        Power spectrum (frequencies and power) of the analysed data.
    wave_eodfs: array
        Frequency and power of fundamental frequency/harmonics of several fish.
    wave_indices: array of int
        Indices of wave fish mapping from wave_eodfs to eod_props.
        If negative, then that EOD frequency has no waveform described in eod_props.
    mean_eods: list of 2-D arrays with time, mean and std.
        Mean trace for the mean EOD plot.
    eod_props: list of dict
        Properties for each waveform in mean_eods.
    peak_data: list of 2_D arrays
        For each pulsefish a list of peak properties
        (index, time, and amplitude).
    spec_data: list of 2_D arrays
        For each pulsefish a power spectrum of the single pulse and for
        each wavefish the relative amplitudes and phases of the harmonics.
    indices: list of int or None
        Indices of the fish in eod_props to be plotted.
        If None try to plot all.
    unit: string
        Unit of the trace and the mean EOD.
    n_snippets: int
        Number of EOD waveform snippets to be plotted. If zero do not plot any.
    power_thresh:  2 D array or None
        Frequency (first column) and power (second column) of threshold
        derived from single pulse spectra to discard false wave fish.
    label_power: boolean
        If `True` put the power in decibel in addition to the frequency
        into the legend.
    all_eods: bool
        Plot all EOD waveforms.
    spec_plots: bool or &#39;auto&#39;
        Plot amplitude spectra of EOD waveforms.
        If &#39;auto&#39;, plot them if there is a singel waveform only.
    log_freq: boolean
        Logarithmic (True) or linear (False) frequency axis of power spectrum of recording.
    min_freq: float
        Limits of frequency axis of power spectrum of recording
        are set to `(min_freq, max_freq)` if `max_freq` is greater than zero
    max_freq: float
        Limits of frequency axis of power spectrum of recording
        are set to `(min_freq, max_freq)` and limits of power axis are computed
        from powers below max_freq if `max_freq` is greater than zero
    interactive: bool
        If True install some keyboard interaction.
    verbose: int
        Print out information about data to be plotted if greater than zero.

    Returns
    -------
    fig: plt.figure
        Figure with the plots.
    &#34;&#34;&#34;

    def keypress(event):
        if event.key in &#39;pP&#39;:
            if idx1 &gt; idx0:
                playdata = 1.0 * raw_data[idx0:idx1]
            else:
                playdata = 1.0 * raw_data[:]
            fade(playdata, samplerate, 0.1)
            play(playdata, samplerate, blocking=False)

    def recording_format_coord(x, y):
        return &#39;full recording: x=%.3f s, y=%.3f&#39; % (x, y)

    def recordingzoom_format_coord(x, y):
        return &#39;recording zoom-in: x=%.3f s, y=%.3f&#39; % (x, y)
            
    def psd_format_coord(x, y):
        return &#39;power spectrum: x=%.1f Hz, y=%.1f dB&#39; % (x, y)

    def meaneod_format_coord(x, y):
        return &#39;mean EOD waveform: x=%.2f ms, y=%.3f&#39; % (x, y)

    def ampl_format_coord(x, y):
        return u&#39;amplitude spectrum: x=%.0f, y=%.2f&#39; % (x, y)

    def phase_format_coord(x, y):
        return u&#39;phase spectrum: x=%.0f, y=%.2f \u03c0&#39; % (x, y/np.pi)
            
    def pulsepsd_format_coord(x, y):
        return &#39;single pulse power spectrum: x=%.1f Hz, y=%.1f dB&#39; % (x, y)

    # count number of fish types to be plotted:
    if indices is None:
        indices = list(range(len(eod_props)))
    indices = np.array(indices, dtype=np.int)
    nwave = 0
    npulse = 0
    for idx in indices:
        if eod_props[idx][&#39;type&#39;] == &#39;pulse&#39;:
            npulse += 1
        elif eod_props[idx][&#39;type&#39;] == &#39;wave&#39;:
            nwave += 1
    neods = nwave + npulse

    if verbose &gt; 0:
        print(&#39;plot: %2d waveforms: %2d wave fish, %2d pulse fish and %2d EOD frequencies.&#39;
              % (len(indices), nwave, npulse, len(wave_eodfs)))

    # size and positions:
    if spec_plots == &#39;auto&#39;:
        spec_plots = len(indices) == 1
    large_plots = spec_plots or len(indices) &lt;= 2
    width = 14.0
    height = 10.0
    if all_eods and len(indices) &gt; 0:
        nrows = len(indices) if spec_plots else (len(indices)+1)//2
        if large_plots:
            height = 6.0 + 4.0*nrows
        else:
            height = 6.4 + 1.9*nrows
    leftx = 1.0/width
    midx = 0.5 + leftx
    fullwidth = 1.0-1.4/width
    halfwidth = 0.5-1.4/width
    pheight = 3.0/height
    
    # figure:
    plot_style()
    fig = plt.figure(figsize=(width, height))
    if interactive:
        fig.canvas.mpl_connect(&#39;key_press_event&#39;, keypress)
    
    # plot title:
    title = base_name
    if channel is not None:
        title += &#39; c%d&#39; % channel
    ax = fig.add_axes([0.2/width, 1.0-0.6/height, 1.0-0.4/width, 0.55/height])
    ax.text(0.0, 1.0, title, fontsize=22, va=&#39;top&#39;)
    ax.text(1.0, 1.0, &#39;thunderfish by Benda-Lab&#39;, fontsize=16, ha=&#39;right&#39;, va=&#39;top&#39;)
    ax.text(1.0, 0.0, &#39;version %s&#39; % __version__, fontsize=16, ha=&#39;right&#39;, va=&#39;bottom&#39;)
    ax.set_frame_on(False)
    ax.set_axis_off()
    ax.set_navigate(False)

    # layout of recording and psd plots:
    #force_both = True                    # set to True for debugging pulse and wave detection
    force_both = False
    posy = 1.0 - 4.0/height
    axr = None
    axp = None
    legend_inside = True
    legendwidth = 3.2/width if label_power else 2.2/width
    if neods == 0:
        axr = fig.add_axes([leftx, posy, fullwidth, pheight])                    # top, wide
        if len(psd_data) &gt; 0:
            axp = fig.add_axes([leftx, 2.0/height, fullwidth, pheight])              # bottom, wide
    else:
        if npulse == 0 and nwave &gt; 2 and len(psd_data) &gt; 0 and not force_both:
            axp = fig.add_axes([leftx, posy, fullwidth-legendwidth, pheight])    # top, wide
            legend_inside = False
        elif (npulse &gt; 0 or len(psd_data) == 0) and len(wave_eodfs) == 0 and not force_both:
            axr = fig.add_axes([leftx, posy, fullwidth, pheight])                # top, wide
        else:
            axr = fig.add_axes([leftx, posy, halfwidth, pheight])                # top left
            label_power = False
            legendwidth = 2.2/width
            axp = fig.add_axes([midx, posy, halfwidth, pheight])                 # top, right
        
    # best window data:
    data = raw_data[idx0:idx1] if idx1 &gt; idx0 else raw_data

    # plot recording
    pulse_colors, pulse_markers = colors_markers()
    pulse_colors = pulse_colors[3:]
    pulse_markers = pulse_markers[3:]
    if axr is not None:
        axes_style(axr)
        twidth = 0.1
        if len(indices) &gt; 0:
            if eod_props[indices[0]][&#39;type&#39;] == &#39;wave&#39;:
                twidth = 5.0/eod_props[indices[0]][&#39;EODf&#39;]
            else:
                if len(wave_eodfs) &gt; 0:
                    twidth = 3.0/eod_props[indices[0]][&#39;EODf&#39;]
                else:
                    twidth = 10.0/eod_props[indices[0]][&#39;EODf&#39;]
            twidth = (1+twidth//0.005)*0.005
        plot_eod_recording(axr, data, samplerate, twidth, unit, idx0/samplerate)
        plot_pulse_eods(axr, data, samplerate, zoom_window, twidth, eod_props, idx0/samplerate,
                        colors=pulse_colors, markers=pulse_markers, frameon=True, loc=&#39;upper right&#39;)
        if axr.get_legend() is not None:
            axr.get_legend().get_frame().set_color(&#39;white&#39;)
        axr.set_title(&#39;Recording&#39;, fontsize=14, y=1.05)
        axr.format_coord = recordingzoom_format_coord
    
    # plot psd
    wave_colors, wave_markers = colors_markers()
    if axp is not None:
        axes_style(axp)
        if power_thresh is not None:
            axp.plot(power_thresh[:,0], decibel(power_thresh[:,1]), &#39;#CCCCCC&#39;, lw=1)
        if len(wave_eodfs) &gt; 0:
            kwargs = {}
            if len(wave_eodfs) &gt; 1:
                title = &#39;%d EOD frequencies&#39; % len(wave_eodfs)
                kwargs = {&#39;title&#39;: title if len(wave_eodfs) &gt; 2 else None }
                if legend_inside:
                    kwargs.update({&#39;bbox_to_anchor&#39;: (1.05, 1.1),
                                   &#39;loc&#39;: &#39;upper right&#39;, &#39;legend_rows&#39;: 10,
                                   &#39;frameon&#39;: True})
                else:
                    kwargs.update({&#39;bbox_to_anchor&#39;: (1.0, 1.1), &#39;frameon&#39;: False,
                                   &#39;loc&#39;: &#39;upper left&#39;, &#39;legend_rows&#39;: 12})
            plot_harmonic_groups(axp, wave_eodfs, wave_indices, max_groups=0,
                                 sort_by_freq=True, label_power=label_power,
                                 colors=wave_colors, markers=wave_markers,
                                 **kwargs)
            if legend_inside:
                axp.get_legend().get_frame().set_color(&#39;white&#39;)
        plot_decibel_psd(axp, psd_data[:,0], psd_data[:,1], log_freq=log_freq,
                         min_freq=min_freq, max_freq=max_freq, ymarg=5.0, color=&#39;blue&#39;)
        axp.yaxis.set_major_locator(ticker.MaxNLocator(6))
        if len(wave_eodfs) == 1:
            axp.get_legend().set_visible(False)
            label = &#39;%6.1f Hz&#39; % wave_eodfs[0][0, 0]
            axp.set_title(&#39;Powerspectrum: %s&#39; % label, y=1.05, fontsize=14)
        else:
            axp.set_title(&#39;Powerspectrum&#39;, y=1.05, fontsize=14)
        axp.format_coord = psd_format_coord

    # get fish labels from legends:
    if axp is not None:
        w, _ = axp.get_legend_handles_labels()
        eodf_labels = [wi.get_label().split()[0] for wi in w]
        legend_wave_eodfs = np.array([float(f) if f[0] != &#39;(&#39; else np.nan for f in eodf_labels])
    if axr is not None:
        p, _ = axr.get_legend_handles_labels()
        eodf_labels = [pi.get_label().split()[0] for pi in p]
        legend_pulse_eodfs = np.array([float(f) if f[0] != &#39;(&#39; else np.nan for f in eodf_labels])

    # layout:
    sheight = 1.4/height
    sstep = 1.6/height
    max_plots = len(indices)
    if not all_eods:
        if large_plots:
            max_plots = 1 if spec_plots else 2
        else:
            max_plots = 4
    if large_plots:
        pstep = pheight + 1.0/height
        ty = 1.08
        my = 1.10
        ny = 6
    else:
        posy -= 0.2/height
        pheight = 1.3/height
        pstep = 1.9/height
        ty = 1.10
        my = 1.16
        ny = 4
    posy -= pstep
            
    # sort indices by p-p amplitude:
    pp_ampls = [eod_props[idx][&#39;p-p-amplitude&#39;] for idx in indices]
    pp_indices = np.argsort(pp_ampls)[::-1]
        
    # plot EOD waveform and spectra:
    for k, idx in enumerate(indices[pp_indices]):
        if k &gt;= max_plots:
            break
        # plot EOD waveform:
        mean_eod = mean_eods[idx]
        props = eod_props[idx]
        peaks = peak_data[idx]
        lx = leftx if spec_plots or k%2 == 0 else midx
        ax = fig.add_axes([lx, posy, halfwidth, pheight])
        axes_style(ax)
        ax.yaxis.set_major_locator(ticker.MaxNLocator(ny))
        if len(indices) &gt; 1:
            ax.text(0.3, ty, &#39;{EODf:.1f} Hz {type} fish&#39;.format(**props),
                       transform=ax.transAxes, fontsize=14)
            mx = 0.25
        else:
            ax.text(-0.1, ty, &#39;{EODf:.1f} Hz {type} fish&#39;.format(**props),
                       transform=ax.transAxes, fontsize=14)
            ax.text(0.5, ty, &#39;Averaged EOD&#39;,
                       transform=ax.transAxes, fontsize=14, ha=&#39;center&#39;)
            mx = -0.14
        eodf = props[&#39;EODf&#39;]
        if props[&#39;type&#39;] == &#39;wave&#39;:
            if axp is not None:
                wk = np.nanargmin(np.abs(legend_wave_eodfs - eodf))
                ma = ml.Line2D([mx], [my], color=w[wk].get_color(), marker=w[wk].get_marker(),
                               markersize=w[wk].get_markersize(), mec=&#39;none&#39;, clip_on=False,
                               label=w[wk].get_label(), transform=ax.transAxes)
                ax.add_line(ma)
        else:
            if axr is not None:
                pk = np.argmin(np.abs(legend_pulse_eodfs - eodf))
                ma = ml.Line2D([mx], [my], color=p[pk].get_color(), marker=p[pk].get_marker(),
                               markersize=p[pk].get_markersize(), mec=&#39;none&#39;, clip_on=False,
                               label=p[pk].get_label(), transform=ax.transAxes)
                ax.add_line(ma)
        plot_eod_waveform(ax, mean_eod, props, peaks, unit)
        if props[&#39;type&#39;] == &#39;pulse&#39;:
            plot_eod_snippets(ax, data, samplerate, mean_eod[0,0], mean_eod[-1,0],
                              props[&#39;times&#39;], n_snippets, props[&#39;flipped&#39;])
        if not large_plots and k &lt; max_plots-2:
            ax.set_xlabel(&#39;&#39;)
        ax.format_coord = meaneod_format_coord

        # plot spectra:
        if spec_plots:
            spec = spec_data[idx]
            if  props[&#39;type&#39;] == &#39;pulse&#39;:
                ax = fig.add_axes([midx, posy, halfwidth, pheight])
                axes_style(ax)
                plot_pulse_spectrum(ax, spec, props)
                ax.set_title(&#39;Single pulse spectrum&#39;, fontsize=14, y=1.05)
                ax.format_coord = pulsepsd_format_coord
            else:
                axa = fig.add_axes([midx, posy+sstep, halfwidth, sheight])
                axes_style(axa)
                axp = fig.add_axes([midx, posy, halfwidth, sheight])
                axes_style(axp)
                plot_wave_spectrum(axa, axp, spec, props, unit)
                axa.set_title(&#39;Amplitude and phase spectrum&#39;, fontsize=14, y=1.05)
                axa.set_xticklabels([])
                axa.yaxis.set_major_locator(ticker.MaxNLocator(4))
                axa.format_coord = ampl_format_coord
                axp.format_coord = phase_format_coord

        if spec_plots or k%2 == 1:
            posy -= pstep

    # whole trace:
    ax = fig.add_axes([leftx, 0.6/height, fullwidth, 0.9/height])
    axes_style(ax)
    plot_data_window(ax, raw_data, samplerate, unit, idx0, idx1, clipped)
    ax.format_coord = recording_format_coord

    return fig

                            
def plot_eod_subplots(base_name, subplots, raw_data, samplerate, idx0, idx1, clipped,
                      psd_data, wave_eodfs, wave_indices, mean_eods, eod_props, peak_data,
                      spec_data, unit, zoom_window, n_snippets=10, power_thresh=None,
                      label_power=True, log_freq=False, min_freq=0.0, max_freq=3000.0):
    &#34;&#34;&#34;Plot time traces and spectra into separate files.

    Parameters
    ----------
    base_name: string
        Basename of audio_file.
    subplots: string
        Specifies which subplots to plot:
        r) recording with best window, t) data trace with detected pulse fish,
        p) power spectrum with detected wave fish, w/W) mean EOD waveform,
        s/S) EOD spectrum, e/E) EOD waveform and spectra. With capital letters
        all fish are saved into a single pdf filem with small letters each fish
        is saved into a separate file.
    raw_data: array
        Dataset.
    samplerate: float
        Sampling rate of the dataset.
    idx0: float
        Index of the beginning of the analysis window in the dataset.
    idx1: float
        Index of the end of the analysis window in the dataset.
    clipped: float
        Fraction of clipped amplitudes.
    psd_data: 2D array
        Power spectrum (frequencies and power) of the analysed data.
    wave_eodfs: array
        Frequency and power of fundamental frequency/harmonics of several fish.
    wave_indices: array of int
        Indices of wave fish mapping from wave_eodfs to eod_props.
        If negative, then that EOD frequency has no waveform described in eod_props.
    mean_eods: list of 2-D arrays with time, mean and std.
        Mean trace for the mean EOD plot.
    eod_props: list of dict
        Properties for each waveform in mean_eods.
    peak_data: list of 2_D arrays
        For each pulsefish a list of peak properties
        (index, time, and amplitude).
    spec_data: list of 2_D arrays
        For each pulsefish a power spectrum of the single pulse and for
        each wavefish the relative amplitudes and phases of the harmonics.
    unit: string
        Unit of the trace and the mean EOD.
    n_snippets: int
        Number of EOD waveform snippets to be plotted. If zero do not plot any.
    power_thresh:  2 D array or None
        Frequency (first column) and power (second column) of threshold
        derived from single pulse spectra to discard false wave fish.
    label_power: boolean
        If `True` put the power in decibel in addition to the frequency
        into the legend.
    log_freq: boolean
        Logarithmic (True) or linear (False) frequency axis of power spectrum of recording.
    min_freq: float
        Limits of frequency axis of power spectrum of recording
        are set to `(min_freq, max_freq)` if `max_freq` is greater than zero
    max_freq: float
        Limits of frequency axis of power spectrum of recording
        are set to `(min_freq, max_freq)` and limits of power axis are computed
        from powers below max_freq if `max_freq` is greater than zero
    &#34;&#34;&#34;
    plot_style()
    if &#39;r&#39; in subplots:
        fig, ax = plt.subplots(figsize=(10, 2))
        fig.subplots_adjust(left=0.07, right=0.99, bottom=0.22, top=0.95)
        plot_data_window(ax, raw_data, samplerate, unit, idx0, idx1, clipped)
        ax.yaxis.set_major_locator(ticker.MaxNLocator(5))
        axes_style(ax)
        fig.savefig(base_name + &#39;-recording.pdf&#39;)
    if &#39;t&#39; in subplots:
        fig, ax = plt.subplots(figsize=(10, 6))
        ax.text(0.5, 0.5, &#39;not implemented yet&#39;,
                transform=ax.transAxes, ha=&#39;center&#39;, va=&#39;center&#39;)
        axes_style(ax)
        fig.savefig(base_name + &#39;-trace.pdf&#39;)
    if &#39;p&#39; in subplots:
        fig, ax = plt.subplots(figsize=(10, 5))
        fig.subplots_adjust(left=0.08, right=0.975, bottom=0.11, top=0.9)
        axes_style(ax)
        if power_thresh is not None:
            ax.plot(power_thresh[:,0], decibel(power_thresh[:,1]), &#39;#CCCCCC&#39;, lw=1)
        if len(wave_eodfs) &gt; 0:
            kwargs = {}
            if len(wave_eodfs) &gt; 1:
                title = &#39;%d EOD frequencies&#39; % len(wave_eodfs)
                kwargs = {&#39;title&#39;: title if len(wave_eodfs) &gt; 2 else None }
                if len(wave_eodfs) &gt; 2:
                    fig.subplots_adjust(left=0.08, right=0.72, bottom=0.11, top=0.9)
                    kwargs.update({&#39;bbox_to_anchor&#39;: (1.0, 1.1),
                                   &#39;loc&#39;: &#39;upper left&#39;, &#39;legend_rows&#39;: 12})
                else:
                    kwargs.update({&#39;bbox_to_anchor&#39;: (1.05, 1.1),
                                   &#39;loc&#39;: &#39;upper right&#39;, &#39;legend_rows&#39;: 10})
            wave_colors, wave_markers = colors_markers()
            plot_harmonic_groups(ax, wave_eodfs, wave_indices, max_groups=0,
                                 sort_by_freq=True, label_power=label_power,
                                 colors=wave_colors, markers=wave_markers,
                                 frameon=False, **kwargs)
        plot_decibel_psd(ax, psd_data[:,0], psd_data[:,1], log_freq=log_freq,
                         min_freq=min_freq, max_freq=max_freq, ymarg=5.0, color=&#39;blue&#39;)
        ax.yaxis.set_major_locator(ticker.MaxNLocator(6))
        if len(wave_eodfs) == 1:
            ax.get_legend().set_visible(False)
            label = &#39;%6.1f Hz&#39; % wave_eodfs[0][0, 0]
            ax.set_title(&#39;Powerspectrum: %s&#39; % label, y=1.05)
        else:
            ax.set_title(&#39;Powerspectrum&#39;, y=1.05)
        fig.savefig(base_name + &#39;-psd.pdf&#39;)
    if &#39;w&#39; in subplots or &#39;W&#39; in subplots:
        mpdf = None
        if &#39;W&#39; in subplots:
            mpdf = PdfPages(base_name + &#39;-waveforms.pdf&#39;)
        for meod, props, peaks in zip(mean_eods, eod_props, peak_data):
            fig, ax = plt.subplots(figsize=(5, 3))
            fig.subplots_adjust(left=0.18, right=0.98, bottom=0.15, top=0.9)
            ax.set_title(&#39;{index:d}: {EODf:.1f} Hz {type} fish&#39;.format(**props))
            plot_eod_waveform(ax, meod, props, peaks, unit)
            data = raw_data[idx0:idx1] if idx1 &gt; idx0 else raw_data
            if props[&#39;type&#39;] == &#39;pulse&#39;:
                plot_eod_snippets(ax, data, samplerate, meod[0,0], meod[-1,0],
                                  props[&#39;times&#39;], n_snippets)
            ax.yaxis.set_major_locator(ticker.MaxNLocator(6))
            axes_style(ax)
            if mpdf is None:
                fig.savefig(base_name + &#39;-waveform-%d.pdf&#39; % props[&#39;index&#39;])
            else:
                mpdf.savefig(fig)
        if mpdf is not None:
            mpdf.close()
    if &#39;s&#39; in subplots or &#39;S&#39; in subplots:
        mpdf = None
        if &#39;S&#39; in subplots:
            mpdf = PdfPages(base_name + &#39;-spectrum.pdf&#39;)
        for props, peaks, spec in zip(eod_props, peak_data, spec_data):
            if props[&#39;type&#39;] == &#39;pulse&#39;:
                fig, ax = plt.subplots(figsize=(5, 3.5))
                fig.subplots_adjust(left=0.15, right=0.967, bottom=0.16, top=0.88)
                axes_style(ax)
                ax.set_title(&#39;{index:d}: {EODf:.1f} Hz {type} fish&#39;.format(**props), y=1.07)
                plot_pulse_spectrum(ax, spec, props)
            else:
                fig, (ax1, ax2) = plt.subplots(2, 1, figsize=(5, 3.5))
                fig.subplots_adjust(left=0.15, right=0.97, bottom=0.16, top=0.88, hspace=0.4)
                axes_style(ax1)
                axes_style(ax2)
                ax1.set_title(&#39;{index:d}: {EODf:.1f} Hz {type} fish&#39;.format(**props), y=1.15)
                plot_wave_spectrum(ax1, ax2, spec, props, unit)
                ax1.set_xticklabels([])
                ax1.yaxis.set_major_locator(ticker.MaxNLocator(4))
            if mpdf is None:
                fig.savefig(base_name + &#39;-spectrum-%d.pdf&#39; % props[&#39;index&#39;])
            else:
                mpdf.savefig(fig)
        if mpdf is not None:
            mpdf.close()
    if &#39;e&#39; in subplots or &#39;E&#39; in subplots:
        mpdf = None
        if &#39;E&#39; in subplots:
            mpdf = PdfPages(base_name + &#39;-eods.pdf&#39;)
        for meod, props, peaks, spec in zip(mean_eods, eod_props, peak_data, spec_data):
            fig = plt.figure(figsize=(10, 3.5))
            gs = gridspec.GridSpec(nrows=2, ncols=2, left=0.09, right=0.98,
                                   bottom=0.16, top=0.88, wspace=0.4, hspace=0.4)
            ax1 = fig.add_subplot(gs[:,0])
            ax1.set_title(&#39;{index:d}: {EODf:.1f} Hz {type} fish&#39;.format(**props), y=1.07)
            plot_eod_waveform(ax1, meod, props, peaks, unit)
            data = raw_data[idx0:idx1] if idx1 &gt; idx0 else raw_data
            if props[&#39;type&#39;] == &#39;pulse&#39;:
                plot_eod_snippets(ax1, data, samplerate, meod[0,0], meod[-1,0],
                                  props[&#39;times&#39;], n_snippets)
            ax1.yaxis.set_major_locator(ticker.MaxNLocator(6))
            axes_style(ax1)
            if props[&#39;type&#39;] == &#39;pulse&#39;:
                ax2 = fig.add_subplot(gs[:,1])
                axes_style(ax2)
                plot_pulse_spectrum(ax2, spec, props)
                ax2.set_title(&#39;Single pulse spectrum&#39;, y=1.07)
            else:
                ax2 = fig.add_subplot(gs[0,1])
                ax3 = fig.add_subplot(gs[1,1])
                axes_style(ax2)
                axes_style(ax3)
                plot_wave_spectrum(ax2, ax3, spec, props, unit)
                ax2.set_title(&#39;Amplitude and phase spectrum&#39;, y=1.15)
                ax2.set_xticklabels([])
                ax2.yaxis.set_major_locator(ticker.MaxNLocator(4))
            if mpdf is None:
                fig.savefig(base_name + &#39;-eod-%d.pdf&#39; % props[&#39;index&#39;])
            else:
                mpdf.savefig(fig)
        if mpdf is not None:
            mpdf.close()
    plt.close()


def thunderfish(filename, load_kwargs, cfg, channel=0,
                time=None, time_file=False,
                mode=&#39;wp&#39;, log_freq=0.0, save_data=False,
                all_eods=False, spec_plots=&#39;auto&#39;, save_plot=False,
                multi_pdf=None, save_subplots=&#39;&#39;,
                output_folder=&#39;.&#39;, keep_path=False, show_bestwindow=False,
                verbose=0, plot_level=0):
    &#34;&#34;&#34;Automatically detect and analyze all EOD waveforms in a short recording.

    Parameters
    ----------
    filename: string
        Path of the data file to be analyzed.
    load_kwargs: dict
        Key-word arguments for the `load_data()` function.
    cfg: dict
    channel: int
        Channel to be analyzed.
    time: string, float, or None
        Start time of analysis window: &#34;beginning&#34;, &#34;center&#34;, &#34;end&#34;,
        &#34;best&#34;, or time in seconds (as float or string). If not None
        overwrites &#34;windowPosition&#34; in cofiguration file.
    time_file: bool
        If `True` add time of analysis window to output file names.
    mode: &#39;w&#39;, &#39;p&#39;, &#39;P&#39;, &#39;wp&#39;, or &#39;wP&#39;
        Analyze wavefish (&#39;w&#39;), all pulse fish (&#39;p&#39;), or largest pulse
        fish only (&#39;P&#39;).
    log_freq: float
        If not 0 plot spectra with logarithmic frequency axis.
        Minimum frequency for the logarithmic spectra.
    save_data: bool
        If True save analysis results in files. If False, just plot the data.
    all_eods: bool
        If True, plot all EOD waveforms.
    spec_plots: bool or &#39;auto&#39;
        Plot amplitude spectra of EOD waveforms.
        If &#39;auto&#39;, plot them if there is a singel waveform only.
    save_plot: bool
        If True, save plots as pdf file.
    multi_pdf: matplotlib.PdfPages or None
        PdfPages instance in which to save plots.
    save_subplots: string
        If not empty, specifies subplots to be saved as separate pdf
        files: r) recording with best window, t) data trace with
        detected pulse fish, p) power spectrum with detected wave
        fish, w/W) mean EOD waveform, s/S) EOD spectrum, e/E) EOD
        waveform and spectra. Capital letters produce a single
        multipage pdf containing plots of all detected fish.
    output_folder: string
        Folder where to save results.
    keep_path: bool
        Add relative path of data files to output path.
    show_bestwindow: bool
        Just show how the best window is determined and exit.
    verbose: int
       Verbosity level (for debugging).
    plot_level: int
       Plot intermediate results.

    Returns
    -------
    msg: string or None
        In case of errors, an error message.
    &#34;&#34;&#34;
    # check data file:
    if len(filename) == 0:
        return &#39;you need to specify a file containing some data&#39;

    # file names:
    fn = filename if keep_path else os.path.basename(filename)
    outfilename = os.path.splitext(fn)[0]

    # load data:
    try:
        all_data, samplerate, unit = load_data(filename, -1,
                                               verbose=verbose, **load_kwargs)
    except IOError as e:
        return &#39;%s: failed to open file: %s&#39; % (filename, str(e))
    # select channel:
    channels = all_data.shape[1]
    chan_list = [channel]
    if channel &lt; 0:
        chan_list = range(channels)
    elif channel &gt;= channels:
        return &#39;%s: invalid channel %d (%d channels)&#39; % (filename, channel, channels)
    # process all channels:
    for chan in chan_list:
        raw_data = all_data[:,chan]
        if len(raw_data) &lt;= 1:
            return &#39;%s: empty data file&#39; % filename
        if verbose &gt;= 0 and len(chan_list) &gt; 1:
            print(&#39;  channel %d&#39; % chan)

        # analysis window:
        win_pos = cfg.value(&#39;windowPosition&#39;)
        if time is not None:
            win_pos = time
        data, idx0, idx1, clipped, min_clip, max_clip = analysis_window(raw_data, samplerate, win_pos,
                                                                        cfg, show_bestwindow)
        if show_bestwindow:
            return None
        found_bestwindow = idx1 &gt; 0
        if not found_bestwindow:
            return &#39;%s: not enough data for requested window length. You may want to adjust the windowSize parameter in the configuration file.&#39; % filename

        # detect EODs in the data:
        psd_data, wave_eodfs, wave_indices, eod_props, \
        mean_eods, spec_data, peak_data, power_thresh, skip_reason, zoom_window = \
          detect_eods(data, samplerate, min_clip, max_clip, filename,
                      mode, verbose, plot_level, cfg)
        if not found_bestwindow:
            wave_eodfs = []
            wave_indices = []
            eod_props = []
            mean_eods = []

        # add analysis window to EOD properties:
        for props in eod_props:
            props[&#39;tstart&#39;] = idx0/samplerate
            props[&#39;twindow&#39;] = (idx1 - idx0)/samplerate

        # warning message in case no fish has been found:
        if found_bestwindow and not eod_props :
            msg = &#39;, &#39;.join(skip_reason)
            if msg:
                print(filename + &#39;: no fish found: %s&#39; % msg)
            else:
                print(filename + &#39;: no fish found.&#39;)

        # save results to files:
        output_basename = os.path.join(output_folder, outfilename)
        if channels &gt; 1:
            if channels &gt; 100:
                output_basename += &#39;-c%03d&#39; % chan
            elif channels &gt; 10:
                output_basename += &#39;-c%02d&#39; % chan
            else:
                output_basename += &#39;-c%d&#39; % chan
        if time_file:
            output_basename += &#39;-t%.0fs&#39; % (idx0/samplerate)
        if save_data:
            remove_eod_files(output_basename, verbose, cfg)
            if found_bestwindow:
                if keep_path:
                    outpath = os.path.dirname(output_basename)
                    if not os.path.exists(outpath):
                        if verbose &gt; 0:
                            print(&#39;mkdir %s&#39; % outpath)
                        os.makedirs(outpath)
                save_eods(output_basename, eod_props, mean_eods, spec_data, peak_data,
                          wave_eodfs, wave_indices, unit, verbose, cfg)

        if save_plot or not save_data:
            min_freq = 0.0
            max_freq = 3000.0
            if log_freq &gt; 0.0:
                min_freq = log_freq
                max_freq = min_freq*20
                if max_freq &lt; 2000:
                    max_freq = 2000
                log_freq = True
            else:
                log_freq = False
            n_snippets = 10
            chl = chan if channels &gt; 1 else None
            fig = plot_eods(outfilename, raw_data, samplerate, chl, idx0, idx1, clipped,
                            psd_data[0], wave_eodfs, wave_indices, mean_eods, eod_props,
                            peak_data, spec_data, None, unit, zoom_window, n_snippets,
                            power_thresh, True, all_eods, spec_plots, log_freq, min_freq, max_freq,
                            interactive=not save_data, verbose=verbose)
            if save_plot:
                if multi_pdf is not None:
                    multi_pdf.savefig(fig)
                else:
                    # save figure as pdf:
                    fig.savefig(output_basename + &#39;.pdf&#39;)
                    plt.close(&#39;all&#39;)
                if len(save_subplots) &gt; 0:
                    plot_eod_subplots(output_basename, save_subplots,
                                      raw_data, samplerate, idx0, idx1, clipped, psd_data[0],
                                      wave_eodfs, wave_indices, mean_eods, eod_props,
                                      peak_data, spec_data, unit, zoom_window, n_snippets,
                                      power_thresh, True, log_freq, min_freq, max_freq)
            elif not save_data:
                fig.canvas.set_window_title(&#39;thunderfish&#39;)
                plt.show()
    return None


def run_thunderfish(file_args):
    &#34;&#34;&#34;Helper function for mutlithreading Pool().map().
    &#34;&#34;&#34;
    verbose = file_args[1][-2]+1
    if verbose &gt; 0:
        if verbose &gt; 1:
            print(&#39;=&#39;*70)
        print(&#39;analyze recording %s ...&#39; % file_args[0])
    try:
        msg = thunderfish(file_args[0], *file_args[1])
        if msg:
            print(msg)
    except (KeyboardInterrupt, SystemExit):
        print(&#39;\nthunderfish interrupted by user... exit now.&#39;)
        sys.exit(0)
    except:
        print(traceback.format_exc())


def main(cargs=None):
    # config file name:
    cfgfile = __package__ + &#39;.cfg&#39;

    # command line arguments:
    if cargs is None:
        cargs = sys.argv[1:]
    parser = argparse.ArgumentParser(add_help=False,
        description=&#39;Analyze EOD waveforms of weakly electric fish.&#39;,
        epilog=&#39;version %s by Benda-Lab (2015-%s)&#39; % (__version__, __year__))
    parser.add_argument(&#39;-h&#39;, &#39;--help&#39;, action=&#39;store_true&#39;,
                        help=&#39;show this help message and exit&#39;)
    parser.add_argument(&#39;--version&#39;, action=&#39;version&#39;, version=__version__)
    parser.add_argument(&#39;-v&#39;, action=&#39;count&#39;, dest=&#39;verbose&#39;, default=0,
                        help=&#39;verbosity level. Increase by specifying -v multiple times, or like -vvv&#39;)
    parser.add_argument(&#39;-V&#39;, action=&#39;count&#39;, dest=&#39;plot_level&#39;, default=0,
                        help=&#39;level for debugging plots. Increase by specifying -V multiple times, or like -VVV&#39;)
    parser.add_argument(&#39;-c&#39;, dest=&#39;save_config&#39;, action=&#39;store_true&#39;,
                        help=&#39;save configuration to file {0} after reading all configuration files&#39;.format(cfgfile))
    parser.add_argument(&#39;--channel&#39;, default=0, type=int,
                        help=&#39;channel to be analyzed (defaults to first channel, negative channel selects all channels)&#39;)
    parser.add_argument(&#39;-t&#39;, dest=&#39;time&#39;, default=None, type=str, metavar=&#39;TIME&#39;,
                        help=&#39;start time of analysis window in recording: &#34;beginning&#34;, &#34;center&#34;, &#34;end&#34;, &#34;best&#34;, or time in seconds (overwrites &#34;windowPosition&#34; in cofiguration file)&#39;)
    parser.add_argument(&#39;-T&#39;, dest=&#39;time_file&#39;, action=&#39;store_true&#39;,
                        help=&#39;add start time of analysis file to output file names&#39;)
    parser.add_argument(&#39;-m&#39;, dest=&#39;mode&#39;, default=&#39;wp&#39;, type=str,
                        choices=[&#39;w&#39;, &#39;p&#39;, &#39;wp&#39;],
                        help=&#39;extract wave &#34;w&#34; and/or pulse &#34;p&#34; fish EODs&#39;)
    parser.add_argument(&#39;-a&#39;, dest=&#39;all_eods&#39;, action=&#39;store_true&#39;,
                        help=&#39;plot all EOD waveforms&#39;)
    parser.add_argument(&#39;-S&#39;, dest=&#39;spec_plots&#39;, action=&#39;store_true&#39;,
                        help=&#39;plot spectra for all EOD waveforms&#39;)
    parser.add_argument(&#39;-j&#39;, dest=&#39;jobs&#39;, nargs=&#39;?&#39;, type=int, default=None, const=0,
                        help=&#39;number of jobs run in parallel. Without argument use all CPU cores.&#39;)
    parser.add_argument(&#39;-s&#39;, dest=&#39;save_data&#39;, action=&#39;store_true&#39;,
                        help=&#39;save analysis results to files&#39;)
    parser.add_argument(&#39;-f&#39;, dest=&#39;format&#39;, default=&#39;auto&#39;, type=str,
                        choices=TableData.formats + [&#39;py&#39;],
                        help=&#39;file format used for saving analysis results, defaults to the format specified in the configuration file or &#34;csv&#34;&#39;)
    parser.add_argument(&#39;-p&#39;, dest=&#39;save_plot&#39;, action=&#39;store_true&#39;,
                        help=&#39;save output plot of each recording as pdf file&#39;)
    parser.add_argument(&#39;-P&#39;, dest=&#39;save_subplots&#39;, default=&#39;&#39;, type=str, metavar=&#39;rtpwse&#39;,
                        help=&#39;save subplots as separate pdf files: r) recording with best window, t) data trace with detected pulse fish, p) power spectrum with detected wave fish, w/W) mean EOD waveform, s/S) EOD spectrum, e/E) EOD waveform and spectra. Capital letters produce a single multipage pdf containing plots of all detected fish&#39;)
    parser.add_argument(&#39;-M&#39;, dest=&#39;multi_pdf&#39;, default=&#39;&#39;, type=str, metavar=&#39;PDFFILE&#39;,
                        help=&#39;save all plots of all recordings in a multi pages pdf file. Disables parallel jobs.&#39;)
    parser.add_argument(&#39;-l&#39;, dest=&#39;log_freq&#39;, type=float, metavar=&#39;MINFREQ&#39;,
                        nargs=&#39;?&#39;, const=100.0, default=0.0,
                        help=&#39;logarithmic frequency axis in  power spectrum with optional minimum frequency (defaults to 100 Hz)&#39;)
    parser.add_argument(&#39;-o&#39;, dest=&#39;outpath&#39;, default=&#39;.&#39;, type=str,
                        help=&#39;path where to store results and figures (defaults to current working directory)&#39;)
    parser.add_argument(&#39;-k&#39;, dest=&#39;keep_path&#39;, action=&#39;store_true&#39;,
                        help=&#39;keep path of input file when saving analysis files, i.e. append path of input file to OUTPATH&#39;)
    parser.add_argument(&#39;-i&#39;, dest=&#39;load_kwargs&#39;, default=[],
                        action=&#39;append&#39;, metavar=&#39;KWARGS&#39;,
                        help=&#39;key-word arguments for the data loader function&#39;)
    parser.add_argument(&#39;-b&#39;, dest=&#39;show_bestwindow&#39;, action=&#39;store_true&#39;,
                        help=&#39;show the cost function of the best window algorithm&#39;)
    parser.add_argument(&#39;file&#39;, nargs=&#39;*&#39;, default=&#39;&#39;, type=str,
                        help=&#39;name of a file with time series data of an EOD recording, may include wildcards&#39;)
    args = parser.parse_args(cargs)

    # help:
    if args.help:
        parser.print_help()
        print(&#39;&#39;)
        print(&#39;examples:&#39;)
        print(&#39;- analyze the single file data.wav interactively:&#39;)
        print(&#39;  &gt; thunderfish data.wav&#39;)
        print(&#39;- extract wavefish only:&#39;)
        print(&#39;  &gt; thunderfish -m w data.wav&#39;)
        print(&#39;- automatically analyze all wav files in the current working directory and save analysis results and plot to files:&#39;)
        print(&#39;  &gt; thunderfish -s -p *.wav&#39;)
        print(&#39;- analyze all wav files in the river1/ directory, use all CPUs, and write files directly to &#34;results/&#34;:&#39;)
        print(&#39;  &gt; thunderfish -j -s -p -o results/ river1/*.wav&#39;)
        print(&#39;- analyze all wav files in the river1/ directory and write files to &#34;results/river1/&#34;:&#39;)
        print(&#39;  &gt; thunderfish -s -p -o results/ -k river1/*.wav&#39;)
        print(&#39;- write configuration file:&#39;)
        print(&#39;  &gt; thunderfish -c&#39;)
        parser.exit()

    # set verbosity level from command line:
    verbose = args.verbose
    plot_level = args.plot_level
    if verbose &lt; plot_level+1:
        verbose = plot_level+1

    # interactive plot:
    plt.rcParams[&#39;keymap.quit&#39;] = &#39;ctrl+w, alt+q, q&#39;
    plt.ioff()

    # expand wildcard patterns:
    files = []
    if os.name == &#39;nt&#39;:
        for fn in args.file:
            files.extend(glob.glob(fn))
    else:
        files = args.file

    if args.save_config:
        # save configuration:
        file_name = files[0] if len(files) else &#39;&#39;
        cfg = configuration()
        cfg.load_files(cfgfile, file_name, 4, verbose)
        save_configuration(cfg, cfgfile)
        exit()
    elif len(files) == 0:
        parser.error(&#39;you need to specify at least one file for the analysis&#39;)

    # configure:
    cfg = configuration()
    cfg.load_files(cfgfile, files[0], 4, verbose)
    if args.format != &#39;auto&#39;:
        cfg.set(&#39;fileFormat&#39;, args.format)
        
    # save plots:
    spec_plots = &#39;auto&#39;
    if args.spec_plots:
        spec_plots = True
    if len(args.save_subplots) &gt; 0:
        args.save_plot = True
    multi_pdf = None
    if len(args.multi_pdf) &gt; 0:
        args.save_plot = True
        args.jobs = None  # PdfPages does not work yet with mutliprocessing
        ext = os.path.splitext(args.multi_pdf)[1]
        if ext != os.extsep + &#39;pdf&#39;:
            args.multi_pdf += os.extsep + &#39;pdf&#39;
        multi_pdf = PdfPages(args.multi_pdf)
        
    # create output folder:
    if args.save_data or args.save_plot:
        if not os.path.exists(args.outpath):
            if verbose &gt; 1:
                print(&#39;mkdir %s&#39; % args.outpath)
            os.makedirs(args.outpath)

    # kwargs fro data loader:
    load_kwargs = {}
    for s in args.load_kwargs:
        for kw in s.split(&#39;,&#39;):
            kws = kw.split(&#39;:&#39;)
            if len(kws) == 2:
                load_kwargs[kws[0].strip()] = kws[1].strip()
            
    # run on pool:
    pool_args = (load_kwargs, cfg, args.channel, args.time, args.time_file,
                 args.mode, args.log_freq, args.save_data,
                 args.all_eods, spec_plots, args.save_plot, multi_pdf,
                 args.save_subplots, args.outpath, args.keep_path,
                 args.show_bestwindow, verbose-1, plot_level)
    if args.jobs is not None and (args.save_data or args.save_plot) and len(files) &gt; 1:
        cpus = cpu_count() if args.jobs == 0 else args.jobs
        if verbose &gt; 1:
            print(&#39;run on %d cpus&#39; % cpus)
        p = Pool(cpus)
        p.map(run_thunderfish, zip(files, [pool_args]*len(files)))
    else:
        list(map(run_thunderfish, zip(files, [pool_args]*len(files))))
    if multi_pdf is not None:
        multi_pdf.close()


if __name__ == &#39;__main__&#39;:
    freeze_support()  # needed by multiprocessing for some weired windows stuff
    main()</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="thunderfish.thunderfish.axes_style"><code class="name flex">
<span>def <span class="ident">axes_style</span></span>(<span>ax)</span>
</code></dt>
<dd>
<div class="desc"><p>Fix style of axes.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>ax</code></strong> :&ensp;<code>matplotlib axes</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def axes_style(ax):
    &#34;&#34;&#34;Fix style of axes.

    Parameters
    ----------
    ax: matplotlib axes
    &#34;&#34;&#34;
    ax.spines[&#39;top&#39;].set_visible(False)
    ax.spines[&#39;right&#39;].set_visible(False)
    ax.get_xaxis().tick_bottom()
    ax.get_yaxis().tick_left()</code></pre>
</details>
</dd>
<dt id="thunderfish.thunderfish.configuration"><code class="name flex">
<span>def <span class="ident">configuration</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>Assemble configuration parameter for thunderfish.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>cfg</code></strong> :&ensp;<code>ConfigFile</code></dt>
<dd>Configuration parameters.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def configuration():
    &#34;&#34;&#34;Assemble configuration parameter for thunderfish.

    Returns
    -------
    cfg: ConfigFile
        Configuration parameters.
    &#34;&#34;&#34;
    cfg = ConfigFile()
    add_multi_psd_config(cfg)
    cfg.add(&#39;frequencyThreshold&#39;, 1.0, &#39;Hz&#39;,
            &#39;The fundamental frequency of each fish needs to be detected in each power spectrum within this threshold.&#39;)
    # TODO: make this threshold dependent on frequency resolution!
    cfg.add(&#39;minPSDAverages&#39;, 3, &#39;&#39;, &#39;Minimum number of fft averages for estimating the power spectrum.&#39;)  # needed by fishfinder
    add_psd_peak_detection_config(cfg)
    add_harmonic_groups_config(cfg)
    add_clip_config(cfg)
    cfg.add(&#39;unwrapData&#39;, False, &#39;&#39;, &#39;Unwrap clipped voltage traces.&#39;)
    add_best_window_config(cfg, win_size=8.0, w_cv_ampl=10.0)
    add_check_pulse_config(cfg)
    add_eod_analysis_config(cfg, min_pulse_win=0.004)
    del cfg[&#39;eodSnippetFac&#39;]
    del cfg[&#39;eodMinSnippet&#39;]
    del cfg[&#39;eodMinSem&#39;]
    add_eod_quality_config(cfg)
    add_species_config(cfg)
    add_write_table_config(cfg, table_format=&#39;csv&#39;, unit_style=&#39;row&#39;,
                           align_columns=True, shrink_width=False)
    return cfg</code></pre>
</details>
</dd>
<dt id="thunderfish.thunderfish.detect_eods"><code class="name flex">
<span>def <span class="ident">detect_eods</span></span>(<span>data, samplerate, min_clip, max_clip, name, mode, verbose, plot_level, cfg)</span>
</code></dt>
<dd>
<div class="desc"><p>Detect EODs of all fish present in the data.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>data</code></strong> :&ensp;<code>array</code> of <code>floats</code></dt>
<dd>The recording in which to detect EODs.</dd>
<dt><strong><code>samplerate</code></strong> :&ensp;<code>float</code></dt>
<dd>Sampling rate of the dataset.</dd>
<dt><strong><code>min_clip</code></strong> :&ensp;<code>float</code></dt>
<dd>Minimum amplitude that is not clipped.</dd>
<dt><strong><code>max_clip</code></strong> :&ensp;<code>float</code></dt>
<dd>Maximum amplitude that is not clipped.</dd>
<dt><strong><code>name</code></strong> :&ensp;<code>string</code></dt>
<dd>Name of the recording (e.g. its filename).</dd>
<dt><strong><code>mode</code></strong> :&ensp;<code>string</code></dt>
<dd>Characters in the string indicate what and how to analyze:
- 'w': analyze wavefish
- 'p': analyze pulsefish
- 'P': analyze only the pulsefish with the largest amplitude (not implemented yet)</dd>
<dt><strong><code>verbose</code></strong> :&ensp;<code>int</code></dt>
<dd>Print out information about EOD detection if greater than zero.</dd>
<dt><strong><code>plot_level</code></strong> :&ensp;<code>int</code></dt>
<dd>Similar to verbosity levels, but with plots.</dd>
<dt><strong><code>cfg</code></strong> :&ensp;<code>ConfigFile</code></dt>
<dd>Configuration parameters.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>psd_data</code></strong> :&ensp;<code>list</code> of <code>2D arrays</code></dt>
<dd>List of power spectra (frequencies and power) of the analysed data
for different frequency resolutions.</dd>
<dt><strong><code>wave_eodfs</code></strong> :&ensp;<code>list</code> of <code>2D arrays</code></dt>
<dd>Frequency and power of fundamental frequency/harmonics of all wave fish.</dd>
<dt><strong><code>wave_indices</code></strong> :&ensp;<code>array</code> of <code>int</code></dt>
<dd>Indices of wave fish mapping from wave_eodfs to eod_props.
If negative, then that EOD frequency has no waveform described in eod_props.</dd>
<dt><strong><code>eod_props</code></strong> :&ensp;<code>list</code> of <code>dict</code></dt>
<dd>Lists of EOD properties as returned by analyze_pulse() and analyze_wave()
for each waveform in mean_eods.</dd>
<dt>mean_eods: list of 2-D arrays with time, mean, sem, and fit.</dt>
<dt>Averaged EOD waveforms of pulse and wave fish.</dt>
<dt><strong><code>spec_data</code></strong> :&ensp;<code>list</code> of <code>2_D arrays</code></dt>
<dd>For each pulsefish a power spectrum of the single pulse and for
each wavefish the relative amplitudes and phases of the harmonics.</dd>
<dt><strong><code>peak_data</code></strong> :&ensp;<code>list</code> of <code>2_D arrays</code></dt>
<dd>For each pulse fish a list of peak properties
(index, time, and amplitude), empty array for wave fish.</dd>
<dt><strong><code>power_thresh</code></strong> :&ensp;<code> 2 D array</code> or <code>None</code></dt>
<dd>Frequency (first column) and power (second column) of threshold
derived from single pulse spectra to discard false wave fish.
None if no pulse fish was detected.</dd>
<dt><strong><code>skip_reason</code></strong> :&ensp;<code>list</code> of <code>string</code></dt>
<dd>Reasons, why an EOD was discarded.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def detect_eods(data, samplerate, min_clip, max_clip, name, mode,
                verbose, plot_level, cfg):
    &#34;&#34;&#34;Detect EODs of all fish present in the data.

    Parameters
    ----------
    data: array of floats
        The recording in which to detect EODs.
    samplerate: float
        Sampling rate of the dataset.
    min_clip: float
        Minimum amplitude that is not clipped.
    max_clip: float
        Maximum amplitude that is not clipped.
    name: string
        Name of the recording (e.g. its filename).
    mode: string
        Characters in the string indicate what and how to analyze:
        - &#39;w&#39;: analyze wavefish
        - &#39;p&#39;: analyze pulsefish
        - &#39;P&#39;: analyze only the pulsefish with the largest amplitude (not implemented yet) 
    verbose: int
        Print out information about EOD detection if greater than zero.
    plot_level : int
        Similar to verbosity levels, but with plots. 
    cfg: ConfigFile
        Configuration parameters.

    Returns
    -------
    psd_data: list of 2D arrays
        List of power spectra (frequencies and power) of the analysed data
        for different frequency resolutions.
    wave_eodfs: list of 2D arrays
        Frequency and power of fundamental frequency/harmonics of all wave fish.
    wave_indices: array of int
        Indices of wave fish mapping from wave_eodfs to eod_props.
        If negative, then that EOD frequency has no waveform described in eod_props.
    eod_props: list of dict
        Lists of EOD properties as returned by analyze_pulse() and analyze_wave()
        for each waveform in mean_eods.
    mean_eods: list of 2-D arrays with time, mean, sem, and fit.
        Averaged EOD waveforms of pulse and wave fish.
    spec_data: list of 2_D arrays
        For each pulsefish a power spectrum of the single pulse and for
        each wavefish the relative amplitudes and phases of the harmonics.
    peak_data: list of 2_D arrays
        For each pulse fish a list of peak properties
        (index, time, and amplitude), empty array for wave fish.
    power_thresh:  2 D array or None
        Frequency (first column) and power (second column) of threshold
        derived from single pulse spectra to discard false wave fish.
        None if no pulse fish was detected.
    skip_reason: list of string
        Reasons, why an EOD was discarded.
    &#34;&#34;&#34;
    psd_data = [[]]
    wave_eodfs = []
    wave_indices = []
    if &#39;w&#39; in mode:
        # detect wave fish:
        psd_data = multi_psd(data, samplerate, **multi_psd_args(cfg))
        h_kwargs = psd_peak_detection_args(cfg)
        h_kwargs.update(harmonic_groups_args(cfg))
        wave_eodfs_list = []
        for i, psd in enumerate(psd_data):
            wave_eodfs = harmonic_groups(psd[:,0], psd[:,1], verbose-1, **h_kwargs)[0]
            if verbose &gt; 0 and len(psd_data) &gt; 1:
                numpsdresolutions = cfg.value(&#39;numberPSDResolutions&#39;)
                print(&#39;fundamental frequencies detected in power spectrum of window %d at resolution %d:&#39;
                      % (i//numpsdresolutions, i%numpsdresolutions))
                if len(wave_eodfs) &gt; 0:
                    print(&#39;  &#39; + &#39; &#39;.join([&#39;%.1f&#39; % freq[0, 0] for freq in wave_eodfs]))
                else:
                    print(&#39;  none&#39;)
            wave_eodfs_list.append(wave_eodfs)
        wave_eodfs = consistent_fishes(wave_eodfs_list,
                                       df_th=cfg.value(&#39;frequencyThreshold&#39;))
        if verbose &gt; 0:
            if len(wave_eodfs) &gt; 0:
                print(&#39;found %2d EOD frequencies consistent in all power spectra:&#39; % len(wave_eodfs))
                print(&#39;  &#39; + &#39; &#39;.join([&#39;%.1f&#39; % freq[0, 0] for freq in wave_eodfs]))
            else:
                print(&#39;no fundamental frequencies are consistent in all power spectra&#39;)

    # analysis results:
    eod_props = []
    mean_eods = []
    spec_data = []
    peak_data = []
    power_thresh = None
    skip_reason = []
    max_pulse_amplitude = 0.0
    zoom_window = []

    if &#39;p&#39; in mode:
        # detect pulse fish:
        _, eod_times, eod_peaktimes, zoom_window, _ = extract_pulsefish(data, samplerate, verbose=verbose, plot_level=plot_level, save_path=os.path.splitext(os.path.basename(name))[0])

        #eod_times = []
        #eod_peaktimes = []
        if verbose &gt; 0:
            if len(eod_times) &gt; 0:
                print(&#39;found %2d pulsefish EODs&#39; % len(eod_times))
            else:
                print(&#39;no pulsefish EODs found&#39;)

        # analyse eod waveform of pulse-fish:
        min_freq_res = cfg.value(&#39;frequencyResolution&#39;)
        for k, (eod_ts, eod_pts) in enumerate(zip(eod_times, eod_peaktimes)):
            mean_eod, eod_times0 = \
                eod_waveform(data, samplerate, eod_ts, win_fac=0.8,
                             min_win=cfg.value(&#39;eodMinPulseSnippet&#39;),
                             min_sem=False, **eod_waveform_args(cfg))
            mean_eod, props, peaks, power = analyze_pulse(mean_eod, eod_times0,
                                                          freq_resolution=min_freq_res,
                                                          **analyze_pulse_args(cfg))
            if len(peaks) == 0:
                print(&#39;error: no peaks in pulse EOD detected&#39;)
                continue
            clipped_frac = clipped_fraction(data, samplerate, eod_times0,
                                            mean_eod, min_clip, max_clip)
            props[&#39;peaktimes&#39;] = eod_pts      # XXX that should go into analyze pulse
            props[&#39;index&#39;] = len(eod_props)
            props[&#39;clipped&#39;] = clipped_frac

            # add good waveforms only:
            skips, msg, skipped_clipped = pulse_quality(props, **pulse_quality_args(cfg))

            if len(skips) == 0:
                eod_props.append(props)
                mean_eods.append(mean_eod)
                spec_data.append(power)
                peak_data.append(peaks)
                if verbose &gt; 0:
                    print(&#39;take %6.1fHz pulse fish: %s&#39; % (props[&#39;EODf&#39;], msg))
            else:
                skip_reason += [&#39;%.1fHz pulse fish %s&#39; % (props[&#39;EODf&#39;], skips)]
                if verbose &gt; 0:
                    print(&#39;skip %6.1fHz pulse fish: %s (%s)&#39; %
                          (props[&#39;EODf&#39;], skips, msg))

            # threshold for wave fish peaks based on single pulse spectra:
            if len(skips) == 0 or skipped_clipped:
                if max_pulse_amplitude &lt; props[&#39;p-p-amplitude&#39;]:
                    max_pulse_amplitude = props[&#39;p-p-amplitude&#39;]
                i0 = np.argmin(np.abs(mean_eod[:,0]))
                i1 = len(mean_eod) - i0
                pulse_data = np.zeros(len(data))
                for t in props[&#39;peaktimes&#39;]:
                    idx = int(t*samplerate)
                    ii0 = i0 if idx-i0 &gt;= 0 else idx
                    ii1 = i1 if idx+i1 &lt; len(pulse_data) else len(pulse_data)-1-idx
                    pulse_data[idx-ii0:idx+ii1] = mean_eod[i0-ii0:i0+ii1,1]
                pulse_psd = multi_psd(pulse_data, samplerate, **multi_psd_args(cfg))
                pulse_power = pulse_psd[0][:,1]
                pulse_power *= len(data)/samplerate/props[&#39;period&#39;]/len(props[&#39;peaktimes&#39;])
                pulse_power *= 5.0
                if power_thresh is None:
                    power_thresh = pulse_psd[0]
                    power_thresh[:,1] = pulse_power
                else:
                    power_thresh[:,1] += pulse_power

        # remove wavefish below pulse fish power:
        if &#39;w&#39; in mode and power_thresh is not None:
            n = len(wave_eodfs)
            maxh = 3  # XXX make parameter
            df = power_thresh[1,0] - power_thresh[0,0]
            for k, fish in enumerate(reversed(wave_eodfs)):
                idx = np.array(fish[:maxh,0]//df, dtype=int)
                for offs in range(-2, 3):
                    nbelow = np.sum(fish[:maxh,1] &lt; power_thresh[idx+offs,1])
                    if nbelow &gt; 0:
                        wave_eodfs.pop(n-1-k)
                        if verbose &gt; 0:
                            print(&#39;skip %6.1fHz wave  fish: %2d harmonics are below pulsefish threshold&#39; % (fish[0,0], nbelow))
                        break

    if &#39;w&#39; in mode:
        # analyse EOD waveform of all wavefish:
        powers = np.array([np.sum(fish[:, 1]**2) for fish in wave_eodfs])
        power_indices = np.argsort(-powers)
        wave_indices = np.zeros(len(wave_eodfs), dtype=np.int) - 3
        for k, idx in enumerate(power_indices):
            fish = wave_eodfs[idx]
            eod_times = np.arange(0.0, len(data)/samplerate, 1.0/fish[0,0])
            mean_eod, eod_times = \
                eod_waveform(data, samplerate, eod_times, win_fac=3.0, min_win=0.0,
                             min_sem=(k==0), **eod_waveform_args(cfg))
            mean_eod, props, sdata, error_str = \
                analyze_wave(mean_eod, fish, **analyze_wave_args(cfg))
            if error_str:
                print(name + &#39;: &#39; + error_str)
            clipped_frac = clipped_fraction(data, samplerate, eod_times,
                                            mean_eod, min_clip, max_clip)
            props[&#39;n&#39;] = len(eod_times)
            props[&#39;index&#39;] = len(eod_props)
            props[&#39;clipped&#39;] = clipped_frac
            # remove wave fish that are smaller than the largest pulse fish:
            if props[&#39;p-p-amplitude&#39;] &lt; 0.01*max_pulse_amplitude:
                rm_indices = power_indices[k:]
                if verbose &gt; 0:
                    print(&#39;skip %6.1fHz wave  fish: power=%5.1fdB, p-p amplitude=%5.1fdB smaller than pulse fish=%5.1dB - 20dB&#39; %
                          (props[&#39;EODf&#39;], decibel(powers[idx]),
                           decibel(props[&#39;p-p-amplitude&#39;]), decibel(max_pulse_amplitude)))
                    for idx in rm_indices[1:]:
                        print(&#39;skip %6.1fHz wave  fish: power=%5.1fdB even smaller&#39; %
                              (wave_eodfs[idx][0,0], decibel(powers[idx])))
                wave_eodfs = [eodfs for idx, eodfs in enumerate(wave_eodfs)
                              if idx not in rm_indices]
                wave_indices = np.array([idcs for idx, idcs in enumerate(wave_indices)
                                        if idx not in rm_indices], dtype=np.int)
                break
            # add good waveforms only:
            remove, skips, msg = wave_quality(props, sdata[1:,3], **wave_quality_args(cfg))
            if len(skips) == 0:
                wave_indices[idx] = props[&#39;index&#39;]
                eod_props.append(props)
                mean_eods.append(mean_eod)
                spec_data.append(sdata)
                peak_data.append([])
                if verbose &gt; 0:
                    print(&#39;take   %6.1fHz wave  fish: %s&#39; % (props[&#39;EODf&#39;], msg))
            else:
                wave_indices[idx] = -2 if remove else -1
                skip_reason += [&#39;%.1fHz wave fish %s&#39; % (props[&#39;EODf&#39;], skips)]
                if verbose &gt; 0:
                    print(&#39;%-6s %6.1fHz wave  fish: %s (%s)&#39; %
                          (&#39;remove&#39; if remove else &#39;skip&#39;, props[&#39;EODf&#39;], skips, msg))
        wave_eodfs = [eodfs for idx, eodfs in zip(wave_indices, wave_eodfs) if idx &gt; -2]
        wave_indices = np.array([idx for idx in wave_indices if idx &gt; -2], dtype=np.int)
    return (psd_data, wave_eodfs, wave_indices, eod_props, mean_eods,
            spec_data, peak_data, power_thresh, skip_reason, zoom_window)</code></pre>
</details>
</dd>
<dt id="thunderfish.thunderfish.main"><code class="name flex">
<span>def <span class="ident">main</span></span>(<span>cargs=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def main(cargs=None):
    # config file name:
    cfgfile = __package__ + &#39;.cfg&#39;

    # command line arguments:
    if cargs is None:
        cargs = sys.argv[1:]
    parser = argparse.ArgumentParser(add_help=False,
        description=&#39;Analyze EOD waveforms of weakly electric fish.&#39;,
        epilog=&#39;version %s by Benda-Lab (2015-%s)&#39; % (__version__, __year__))
    parser.add_argument(&#39;-h&#39;, &#39;--help&#39;, action=&#39;store_true&#39;,
                        help=&#39;show this help message and exit&#39;)
    parser.add_argument(&#39;--version&#39;, action=&#39;version&#39;, version=__version__)
    parser.add_argument(&#39;-v&#39;, action=&#39;count&#39;, dest=&#39;verbose&#39;, default=0,
                        help=&#39;verbosity level. Increase by specifying -v multiple times, or like -vvv&#39;)
    parser.add_argument(&#39;-V&#39;, action=&#39;count&#39;, dest=&#39;plot_level&#39;, default=0,
                        help=&#39;level for debugging plots. Increase by specifying -V multiple times, or like -VVV&#39;)
    parser.add_argument(&#39;-c&#39;, dest=&#39;save_config&#39;, action=&#39;store_true&#39;,
                        help=&#39;save configuration to file {0} after reading all configuration files&#39;.format(cfgfile))
    parser.add_argument(&#39;--channel&#39;, default=0, type=int,
                        help=&#39;channel to be analyzed (defaults to first channel, negative channel selects all channels)&#39;)
    parser.add_argument(&#39;-t&#39;, dest=&#39;time&#39;, default=None, type=str, metavar=&#39;TIME&#39;,
                        help=&#39;start time of analysis window in recording: &#34;beginning&#34;, &#34;center&#34;, &#34;end&#34;, &#34;best&#34;, or time in seconds (overwrites &#34;windowPosition&#34; in cofiguration file)&#39;)
    parser.add_argument(&#39;-T&#39;, dest=&#39;time_file&#39;, action=&#39;store_true&#39;,
                        help=&#39;add start time of analysis file to output file names&#39;)
    parser.add_argument(&#39;-m&#39;, dest=&#39;mode&#39;, default=&#39;wp&#39;, type=str,
                        choices=[&#39;w&#39;, &#39;p&#39;, &#39;wp&#39;],
                        help=&#39;extract wave &#34;w&#34; and/or pulse &#34;p&#34; fish EODs&#39;)
    parser.add_argument(&#39;-a&#39;, dest=&#39;all_eods&#39;, action=&#39;store_true&#39;,
                        help=&#39;plot all EOD waveforms&#39;)
    parser.add_argument(&#39;-S&#39;, dest=&#39;spec_plots&#39;, action=&#39;store_true&#39;,
                        help=&#39;plot spectra for all EOD waveforms&#39;)
    parser.add_argument(&#39;-j&#39;, dest=&#39;jobs&#39;, nargs=&#39;?&#39;, type=int, default=None, const=0,
                        help=&#39;number of jobs run in parallel. Without argument use all CPU cores.&#39;)
    parser.add_argument(&#39;-s&#39;, dest=&#39;save_data&#39;, action=&#39;store_true&#39;,
                        help=&#39;save analysis results to files&#39;)
    parser.add_argument(&#39;-f&#39;, dest=&#39;format&#39;, default=&#39;auto&#39;, type=str,
                        choices=TableData.formats + [&#39;py&#39;],
                        help=&#39;file format used for saving analysis results, defaults to the format specified in the configuration file or &#34;csv&#34;&#39;)
    parser.add_argument(&#39;-p&#39;, dest=&#39;save_plot&#39;, action=&#39;store_true&#39;,
                        help=&#39;save output plot of each recording as pdf file&#39;)
    parser.add_argument(&#39;-P&#39;, dest=&#39;save_subplots&#39;, default=&#39;&#39;, type=str, metavar=&#39;rtpwse&#39;,
                        help=&#39;save subplots as separate pdf files: r) recording with best window, t) data trace with detected pulse fish, p) power spectrum with detected wave fish, w/W) mean EOD waveform, s/S) EOD spectrum, e/E) EOD waveform and spectra. Capital letters produce a single multipage pdf containing plots of all detected fish&#39;)
    parser.add_argument(&#39;-M&#39;, dest=&#39;multi_pdf&#39;, default=&#39;&#39;, type=str, metavar=&#39;PDFFILE&#39;,
                        help=&#39;save all plots of all recordings in a multi pages pdf file. Disables parallel jobs.&#39;)
    parser.add_argument(&#39;-l&#39;, dest=&#39;log_freq&#39;, type=float, metavar=&#39;MINFREQ&#39;,
                        nargs=&#39;?&#39;, const=100.0, default=0.0,
                        help=&#39;logarithmic frequency axis in  power spectrum with optional minimum frequency (defaults to 100 Hz)&#39;)
    parser.add_argument(&#39;-o&#39;, dest=&#39;outpath&#39;, default=&#39;.&#39;, type=str,
                        help=&#39;path where to store results and figures (defaults to current working directory)&#39;)
    parser.add_argument(&#39;-k&#39;, dest=&#39;keep_path&#39;, action=&#39;store_true&#39;,
                        help=&#39;keep path of input file when saving analysis files, i.e. append path of input file to OUTPATH&#39;)
    parser.add_argument(&#39;-i&#39;, dest=&#39;load_kwargs&#39;, default=[],
                        action=&#39;append&#39;, metavar=&#39;KWARGS&#39;,
                        help=&#39;key-word arguments for the data loader function&#39;)
    parser.add_argument(&#39;-b&#39;, dest=&#39;show_bestwindow&#39;, action=&#39;store_true&#39;,
                        help=&#39;show the cost function of the best window algorithm&#39;)
    parser.add_argument(&#39;file&#39;, nargs=&#39;*&#39;, default=&#39;&#39;, type=str,
                        help=&#39;name of a file with time series data of an EOD recording, may include wildcards&#39;)
    args = parser.parse_args(cargs)

    # help:
    if args.help:
        parser.print_help()
        print(&#39;&#39;)
        print(&#39;examples:&#39;)
        print(&#39;- analyze the single file data.wav interactively:&#39;)
        print(&#39;  &gt; thunderfish data.wav&#39;)
        print(&#39;- extract wavefish only:&#39;)
        print(&#39;  &gt; thunderfish -m w data.wav&#39;)
        print(&#39;- automatically analyze all wav files in the current working directory and save analysis results and plot to files:&#39;)
        print(&#39;  &gt; thunderfish -s -p *.wav&#39;)
        print(&#39;- analyze all wav files in the river1/ directory, use all CPUs, and write files directly to &#34;results/&#34;:&#39;)
        print(&#39;  &gt; thunderfish -j -s -p -o results/ river1/*.wav&#39;)
        print(&#39;- analyze all wav files in the river1/ directory and write files to &#34;results/river1/&#34;:&#39;)
        print(&#39;  &gt; thunderfish -s -p -o results/ -k river1/*.wav&#39;)
        print(&#39;- write configuration file:&#39;)
        print(&#39;  &gt; thunderfish -c&#39;)
        parser.exit()

    # set verbosity level from command line:
    verbose = args.verbose
    plot_level = args.plot_level
    if verbose &lt; plot_level+1:
        verbose = plot_level+1

    # interactive plot:
    plt.rcParams[&#39;keymap.quit&#39;] = &#39;ctrl+w, alt+q, q&#39;
    plt.ioff()

    # expand wildcard patterns:
    files = []
    if os.name == &#39;nt&#39;:
        for fn in args.file:
            files.extend(glob.glob(fn))
    else:
        files = args.file

    if args.save_config:
        # save configuration:
        file_name = files[0] if len(files) else &#39;&#39;
        cfg = configuration()
        cfg.load_files(cfgfile, file_name, 4, verbose)
        save_configuration(cfg, cfgfile)
        exit()
    elif len(files) == 0:
        parser.error(&#39;you need to specify at least one file for the analysis&#39;)

    # configure:
    cfg = configuration()
    cfg.load_files(cfgfile, files[0], 4, verbose)
    if args.format != &#39;auto&#39;:
        cfg.set(&#39;fileFormat&#39;, args.format)
        
    # save plots:
    spec_plots = &#39;auto&#39;
    if args.spec_plots:
        spec_plots = True
    if len(args.save_subplots) &gt; 0:
        args.save_plot = True
    multi_pdf = None
    if len(args.multi_pdf) &gt; 0:
        args.save_plot = True
        args.jobs = None  # PdfPages does not work yet with mutliprocessing
        ext = os.path.splitext(args.multi_pdf)[1]
        if ext != os.extsep + &#39;pdf&#39;:
            args.multi_pdf += os.extsep + &#39;pdf&#39;
        multi_pdf = PdfPages(args.multi_pdf)
        
    # create output folder:
    if args.save_data or args.save_plot:
        if not os.path.exists(args.outpath):
            if verbose &gt; 1:
                print(&#39;mkdir %s&#39; % args.outpath)
            os.makedirs(args.outpath)

    # kwargs fro data loader:
    load_kwargs = {}
    for s in args.load_kwargs:
        for kw in s.split(&#39;,&#39;):
            kws = kw.split(&#39;:&#39;)
            if len(kws) == 2:
                load_kwargs[kws[0].strip()] = kws[1].strip()
            
    # run on pool:
    pool_args = (load_kwargs, cfg, args.channel, args.time, args.time_file,
                 args.mode, args.log_freq, args.save_data,
                 args.all_eods, spec_plots, args.save_plot, multi_pdf,
                 args.save_subplots, args.outpath, args.keep_path,
                 args.show_bestwindow, verbose-1, plot_level)
    if args.jobs is not None and (args.save_data or args.save_plot) and len(files) &gt; 1:
        cpus = cpu_count() if args.jobs == 0 else args.jobs
        if verbose &gt; 1:
            print(&#39;run on %d cpus&#39; % cpus)
        p = Pool(cpus)
        p.map(run_thunderfish, zip(files, [pool_args]*len(files)))
    else:
        list(map(run_thunderfish, zip(files, [pool_args]*len(files))))
    if multi_pdf is not None:
        multi_pdf.close()</code></pre>
</details>
</dd>
<dt id="thunderfish.thunderfish.plot_eod_subplots"><code class="name flex">
<span>def <span class="ident">plot_eod_subplots</span></span>(<span>base_name, subplots, raw_data, samplerate, idx0, idx1, clipped, psd_data, wave_eodfs, wave_indices, mean_eods, eod_props, peak_data, spec_data, unit, zoom_window, n_snippets=10, power_thresh=None, label_power=True, log_freq=False, min_freq=0.0, max_freq=3000.0)</span>
</code></dt>
<dd>
<div class="desc"><p>Plot time traces and spectra into separate files.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>base_name</code></strong> :&ensp;<code>string</code></dt>
<dd>Basename of audio_file.</dd>
<dt><strong><code>subplots</code></strong> :&ensp;<code>string</code></dt>
<dd>Specifies which subplots to plot:
r) recording with best window, t) data trace with detected pulse fish,
p) power spectrum with detected wave fish, w/W) mean EOD waveform,
s/S) EOD spectrum, e/E) EOD waveform and spectra. With capital letters
all fish are saved into a single pdf filem with small letters each fish
is saved into a separate file.</dd>
<dt><strong><code>raw_data</code></strong> :&ensp;<code>array</code></dt>
<dd>Dataset.</dd>
<dt><strong><code>samplerate</code></strong> :&ensp;<code>float</code></dt>
<dd>Sampling rate of the dataset.</dd>
<dt><strong><code>idx0</code></strong> :&ensp;<code>float</code></dt>
<dd>Index of the beginning of the analysis window in the dataset.</dd>
<dt><strong><code>idx1</code></strong> :&ensp;<code>float</code></dt>
<dd>Index of the end of the analysis window in the dataset.</dd>
<dt><strong><code>clipped</code></strong> :&ensp;<code>float</code></dt>
<dd>Fraction of clipped amplitudes.</dd>
<dt><strong><code>psd_data</code></strong> :&ensp;<code>2D array</code></dt>
<dd>Power spectrum (frequencies and power) of the analysed data.</dd>
<dt><strong><code>wave_eodfs</code></strong> :&ensp;<code>array</code></dt>
<dd>Frequency and power of fundamental frequency/harmonics of several fish.</dd>
<dt><strong><code>wave_indices</code></strong> :&ensp;<code>array</code> of <code>int</code></dt>
<dd>Indices of wave fish mapping from wave_eodfs to eod_props.
If negative, then that EOD frequency has no waveform described in eod_props.</dd>
<dt>mean_eods: list of 2-D arrays with time, mean and std.</dt>
<dt>Mean trace for the mean EOD plot.</dt>
<dt><strong><code>eod_props</code></strong> :&ensp;<code>list</code> of <code>dict</code></dt>
<dd>Properties for each waveform in mean_eods.</dd>
<dt><strong><code>peak_data</code></strong> :&ensp;<code>list</code> of <code>2_D arrays</code></dt>
<dd>For each pulsefish a list of peak properties
(index, time, and amplitude).</dd>
<dt><strong><code>spec_data</code></strong> :&ensp;<code>list</code> of <code>2_D arrays</code></dt>
<dd>For each pulsefish a power spectrum of the single pulse and for
each wavefish the relative amplitudes and phases of the harmonics.</dd>
<dt><strong><code>unit</code></strong> :&ensp;<code>string</code></dt>
<dd>Unit of the trace and the mean EOD.</dd>
<dt><strong><code>n_snippets</code></strong> :&ensp;<code>int</code></dt>
<dd>Number of EOD waveform snippets to be plotted. If zero do not plot any.</dd>
<dt><strong><code>power_thresh</code></strong> :&ensp;<code> 2 D array</code> or <code>None</code></dt>
<dd>Frequency (first column) and power (second column) of threshold
derived from single pulse spectra to discard false wave fish.</dd>
<dt><strong><code>label_power</code></strong> :&ensp;<code>boolean</code></dt>
<dd>If <code>True</code> put the power in decibel in addition to the frequency
into the legend.</dd>
<dt><strong><code>log_freq</code></strong> :&ensp;<code>boolean</code></dt>
<dd>Logarithmic (True) or linear (False) frequency axis of power spectrum of recording.</dd>
<dt><strong><code>min_freq</code></strong> :&ensp;<code>float</code></dt>
<dd>Limits of frequency axis of power spectrum of recording
are set to <code>(min_freq, max_freq)</code> if <code>max_freq</code> is greater than zero</dd>
<dt><strong><code>max_freq</code></strong> :&ensp;<code>float</code></dt>
<dd>Limits of frequency axis of power spectrum of recording
are set to <code>(min_freq, max_freq)</code> and limits of power axis are computed
from powers below max_freq if <code>max_freq</code> is greater than zero</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot_eod_subplots(base_name, subplots, raw_data, samplerate, idx0, idx1, clipped,
                      psd_data, wave_eodfs, wave_indices, mean_eods, eod_props, peak_data,
                      spec_data, unit, zoom_window, n_snippets=10, power_thresh=None,
                      label_power=True, log_freq=False, min_freq=0.0, max_freq=3000.0):
    &#34;&#34;&#34;Plot time traces and spectra into separate files.

    Parameters
    ----------
    base_name: string
        Basename of audio_file.
    subplots: string
        Specifies which subplots to plot:
        r) recording with best window, t) data trace with detected pulse fish,
        p) power spectrum with detected wave fish, w/W) mean EOD waveform,
        s/S) EOD spectrum, e/E) EOD waveform and spectra. With capital letters
        all fish are saved into a single pdf filem with small letters each fish
        is saved into a separate file.
    raw_data: array
        Dataset.
    samplerate: float
        Sampling rate of the dataset.
    idx0: float
        Index of the beginning of the analysis window in the dataset.
    idx1: float
        Index of the end of the analysis window in the dataset.
    clipped: float
        Fraction of clipped amplitudes.
    psd_data: 2D array
        Power spectrum (frequencies and power) of the analysed data.
    wave_eodfs: array
        Frequency and power of fundamental frequency/harmonics of several fish.
    wave_indices: array of int
        Indices of wave fish mapping from wave_eodfs to eod_props.
        If negative, then that EOD frequency has no waveform described in eod_props.
    mean_eods: list of 2-D arrays with time, mean and std.
        Mean trace for the mean EOD plot.
    eod_props: list of dict
        Properties for each waveform in mean_eods.
    peak_data: list of 2_D arrays
        For each pulsefish a list of peak properties
        (index, time, and amplitude).
    spec_data: list of 2_D arrays
        For each pulsefish a power spectrum of the single pulse and for
        each wavefish the relative amplitudes and phases of the harmonics.
    unit: string
        Unit of the trace and the mean EOD.
    n_snippets: int
        Number of EOD waveform snippets to be plotted. If zero do not plot any.
    power_thresh:  2 D array or None
        Frequency (first column) and power (second column) of threshold
        derived from single pulse spectra to discard false wave fish.
    label_power: boolean
        If `True` put the power in decibel in addition to the frequency
        into the legend.
    log_freq: boolean
        Logarithmic (True) or linear (False) frequency axis of power spectrum of recording.
    min_freq: float
        Limits of frequency axis of power spectrum of recording
        are set to `(min_freq, max_freq)` if `max_freq` is greater than zero
    max_freq: float
        Limits of frequency axis of power spectrum of recording
        are set to `(min_freq, max_freq)` and limits of power axis are computed
        from powers below max_freq if `max_freq` is greater than zero
    &#34;&#34;&#34;
    plot_style()
    if &#39;r&#39; in subplots:
        fig, ax = plt.subplots(figsize=(10, 2))
        fig.subplots_adjust(left=0.07, right=0.99, bottom=0.22, top=0.95)
        plot_data_window(ax, raw_data, samplerate, unit, idx0, idx1, clipped)
        ax.yaxis.set_major_locator(ticker.MaxNLocator(5))
        axes_style(ax)
        fig.savefig(base_name + &#39;-recording.pdf&#39;)
    if &#39;t&#39; in subplots:
        fig, ax = plt.subplots(figsize=(10, 6))
        ax.text(0.5, 0.5, &#39;not implemented yet&#39;,
                transform=ax.transAxes, ha=&#39;center&#39;, va=&#39;center&#39;)
        axes_style(ax)
        fig.savefig(base_name + &#39;-trace.pdf&#39;)
    if &#39;p&#39; in subplots:
        fig, ax = plt.subplots(figsize=(10, 5))
        fig.subplots_adjust(left=0.08, right=0.975, bottom=0.11, top=0.9)
        axes_style(ax)
        if power_thresh is not None:
            ax.plot(power_thresh[:,0], decibel(power_thresh[:,1]), &#39;#CCCCCC&#39;, lw=1)
        if len(wave_eodfs) &gt; 0:
            kwargs = {}
            if len(wave_eodfs) &gt; 1:
                title = &#39;%d EOD frequencies&#39; % len(wave_eodfs)
                kwargs = {&#39;title&#39;: title if len(wave_eodfs) &gt; 2 else None }
                if len(wave_eodfs) &gt; 2:
                    fig.subplots_adjust(left=0.08, right=0.72, bottom=0.11, top=0.9)
                    kwargs.update({&#39;bbox_to_anchor&#39;: (1.0, 1.1),
                                   &#39;loc&#39;: &#39;upper left&#39;, &#39;legend_rows&#39;: 12})
                else:
                    kwargs.update({&#39;bbox_to_anchor&#39;: (1.05, 1.1),
                                   &#39;loc&#39;: &#39;upper right&#39;, &#39;legend_rows&#39;: 10})
            wave_colors, wave_markers = colors_markers()
            plot_harmonic_groups(ax, wave_eodfs, wave_indices, max_groups=0,
                                 sort_by_freq=True, label_power=label_power,
                                 colors=wave_colors, markers=wave_markers,
                                 frameon=False, **kwargs)
        plot_decibel_psd(ax, psd_data[:,0], psd_data[:,1], log_freq=log_freq,
                         min_freq=min_freq, max_freq=max_freq, ymarg=5.0, color=&#39;blue&#39;)
        ax.yaxis.set_major_locator(ticker.MaxNLocator(6))
        if len(wave_eodfs) == 1:
            ax.get_legend().set_visible(False)
            label = &#39;%6.1f Hz&#39; % wave_eodfs[0][0, 0]
            ax.set_title(&#39;Powerspectrum: %s&#39; % label, y=1.05)
        else:
            ax.set_title(&#39;Powerspectrum&#39;, y=1.05)
        fig.savefig(base_name + &#39;-psd.pdf&#39;)
    if &#39;w&#39; in subplots or &#39;W&#39; in subplots:
        mpdf = None
        if &#39;W&#39; in subplots:
            mpdf = PdfPages(base_name + &#39;-waveforms.pdf&#39;)
        for meod, props, peaks in zip(mean_eods, eod_props, peak_data):
            fig, ax = plt.subplots(figsize=(5, 3))
            fig.subplots_adjust(left=0.18, right=0.98, bottom=0.15, top=0.9)
            ax.set_title(&#39;{index:d}: {EODf:.1f} Hz {type} fish&#39;.format(**props))
            plot_eod_waveform(ax, meod, props, peaks, unit)
            data = raw_data[idx0:idx1] if idx1 &gt; idx0 else raw_data
            if props[&#39;type&#39;] == &#39;pulse&#39;:
                plot_eod_snippets(ax, data, samplerate, meod[0,0], meod[-1,0],
                                  props[&#39;times&#39;], n_snippets)
            ax.yaxis.set_major_locator(ticker.MaxNLocator(6))
            axes_style(ax)
            if mpdf is None:
                fig.savefig(base_name + &#39;-waveform-%d.pdf&#39; % props[&#39;index&#39;])
            else:
                mpdf.savefig(fig)
        if mpdf is not None:
            mpdf.close()
    if &#39;s&#39; in subplots or &#39;S&#39; in subplots:
        mpdf = None
        if &#39;S&#39; in subplots:
            mpdf = PdfPages(base_name + &#39;-spectrum.pdf&#39;)
        for props, peaks, spec in zip(eod_props, peak_data, spec_data):
            if props[&#39;type&#39;] == &#39;pulse&#39;:
                fig, ax = plt.subplots(figsize=(5, 3.5))
                fig.subplots_adjust(left=0.15, right=0.967, bottom=0.16, top=0.88)
                axes_style(ax)
                ax.set_title(&#39;{index:d}: {EODf:.1f} Hz {type} fish&#39;.format(**props), y=1.07)
                plot_pulse_spectrum(ax, spec, props)
            else:
                fig, (ax1, ax2) = plt.subplots(2, 1, figsize=(5, 3.5))
                fig.subplots_adjust(left=0.15, right=0.97, bottom=0.16, top=0.88, hspace=0.4)
                axes_style(ax1)
                axes_style(ax2)
                ax1.set_title(&#39;{index:d}: {EODf:.1f} Hz {type} fish&#39;.format(**props), y=1.15)
                plot_wave_spectrum(ax1, ax2, spec, props, unit)
                ax1.set_xticklabels([])
                ax1.yaxis.set_major_locator(ticker.MaxNLocator(4))
            if mpdf is None:
                fig.savefig(base_name + &#39;-spectrum-%d.pdf&#39; % props[&#39;index&#39;])
            else:
                mpdf.savefig(fig)
        if mpdf is not None:
            mpdf.close()
    if &#39;e&#39; in subplots or &#39;E&#39; in subplots:
        mpdf = None
        if &#39;E&#39; in subplots:
            mpdf = PdfPages(base_name + &#39;-eods.pdf&#39;)
        for meod, props, peaks, spec in zip(mean_eods, eod_props, peak_data, spec_data):
            fig = plt.figure(figsize=(10, 3.5))
            gs = gridspec.GridSpec(nrows=2, ncols=2, left=0.09, right=0.98,
                                   bottom=0.16, top=0.88, wspace=0.4, hspace=0.4)
            ax1 = fig.add_subplot(gs[:,0])
            ax1.set_title(&#39;{index:d}: {EODf:.1f} Hz {type} fish&#39;.format(**props), y=1.07)
            plot_eod_waveform(ax1, meod, props, peaks, unit)
            data = raw_data[idx0:idx1] if idx1 &gt; idx0 else raw_data
            if props[&#39;type&#39;] == &#39;pulse&#39;:
                plot_eod_snippets(ax1, data, samplerate, meod[0,0], meod[-1,0],
                                  props[&#39;times&#39;], n_snippets)
            ax1.yaxis.set_major_locator(ticker.MaxNLocator(6))
            axes_style(ax1)
            if props[&#39;type&#39;] == &#39;pulse&#39;:
                ax2 = fig.add_subplot(gs[:,1])
                axes_style(ax2)
                plot_pulse_spectrum(ax2, spec, props)
                ax2.set_title(&#39;Single pulse spectrum&#39;, y=1.07)
            else:
                ax2 = fig.add_subplot(gs[0,1])
                ax3 = fig.add_subplot(gs[1,1])
                axes_style(ax2)
                axes_style(ax3)
                plot_wave_spectrum(ax2, ax3, spec, props, unit)
                ax2.set_title(&#39;Amplitude and phase spectrum&#39;, y=1.15)
                ax2.set_xticklabels([])
                ax2.yaxis.set_major_locator(ticker.MaxNLocator(4))
            if mpdf is None:
                fig.savefig(base_name + &#39;-eod-%d.pdf&#39; % props[&#39;index&#39;])
            else:
                mpdf.savefig(fig)
        if mpdf is not None:
            mpdf.close()
    plt.close()</code></pre>
</details>
</dd>
<dt id="thunderfish.thunderfish.plot_eods"><code class="name flex">
<span>def <span class="ident">plot_eods</span></span>(<span>base_name, raw_data, samplerate, channel, idx0, idx1, clipped, psd_data, wave_eodfs, wave_indices, mean_eods, eod_props, peak_data, spec_data, indices, unit, zoom_window, n_snippets=10, power_thresh=None, label_power=True, all_eods=False, spec_plots='auto', log_freq=False, min_freq=0.0, max_freq=3000.0, interactive=True, verbose=0)</span>
</code></dt>
<dd>
<div class="desc"><p>Creates an output plot for the thunderfish program.</p>
<p>This output contains the raw trace where the analysis window is
marked, the power-spectrum of this analysis window where the
detected fish are marked, plots of averaged EOD plots, and
spectra of the EOD waveforms.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>base_name</code></strong> :&ensp;<code>string</code></dt>
<dd>Basename of audio_file.</dd>
<dt><strong><code>raw_data</code></strong> :&ensp;<code>array</code></dt>
<dd>Dataset.</dd>
<dt><strong><code>samplerate</code></strong> :&ensp;<code>float</code></dt>
<dd>Sampling rate of the dataset.</dd>
<dt><strong><code>channel</code></strong> :&ensp;<code>int</code> or <code>None</code></dt>
<dd>Channel of the recording to be put into the plot title.
If None, do not write the channel into the title.</dd>
<dt><strong><code>idx0</code></strong> :&ensp;<code>float</code></dt>
<dd>Index of the beginning of the analysis window in the dataset.</dd>
<dt><strong><code>idx1</code></strong> :&ensp;<code>float</code></dt>
<dd>Index of the end of the analysis window in the dataset.</dd>
<dt><strong><code>clipped</code></strong> :&ensp;<code>float</code></dt>
<dd>Fraction of clipped amplitudes.</dd>
<dt><strong><code>psd_data</code></strong> :&ensp;<code>2D array</code></dt>
<dd>Power spectrum (frequencies and power) of the analysed data.</dd>
<dt><strong><code>wave_eodfs</code></strong> :&ensp;<code>array</code></dt>
<dd>Frequency and power of fundamental frequency/harmonics of several fish.</dd>
<dt><strong><code>wave_indices</code></strong> :&ensp;<code>array</code> of <code>int</code></dt>
<dd>Indices of wave fish mapping from wave_eodfs to eod_props.
If negative, then that EOD frequency has no waveform described in eod_props.</dd>
<dt>mean_eods: list of 2-D arrays with time, mean and std.</dt>
<dt>Mean trace for the mean EOD plot.</dt>
<dt><strong><code>eod_props</code></strong> :&ensp;<code>list</code> of <code>dict</code></dt>
<dd>Properties for each waveform in mean_eods.</dd>
<dt><strong><code>peak_data</code></strong> :&ensp;<code>list</code> of <code>2_D arrays</code></dt>
<dd>For each pulsefish a list of peak properties
(index, time, and amplitude).</dd>
<dt><strong><code>spec_data</code></strong> :&ensp;<code>list</code> of <code>2_D arrays</code></dt>
<dd>For each pulsefish a power spectrum of the single pulse and for
each wavefish the relative amplitudes and phases of the harmonics.</dd>
<dt><strong><code>indices</code></strong> :&ensp;<code>list</code> of <code>int</code> or <code>None</code></dt>
<dd>Indices of the fish in eod_props to be plotted.
If None try to plot all.</dd>
<dt><strong><code>unit</code></strong> :&ensp;<code>string</code></dt>
<dd>Unit of the trace and the mean EOD.</dd>
<dt><strong><code>n_snippets</code></strong> :&ensp;<code>int</code></dt>
<dd>Number of EOD waveform snippets to be plotted. If zero do not plot any.</dd>
<dt><strong><code>power_thresh</code></strong> :&ensp;<code> 2 D array</code> or <code>None</code></dt>
<dd>Frequency (first column) and power (second column) of threshold
derived from single pulse spectra to discard false wave fish.</dd>
<dt><strong><code>label_power</code></strong> :&ensp;<code>boolean</code></dt>
<dd>If <code>True</code> put the power in decibel in addition to the frequency
into the legend.</dd>
<dt><strong><code>all_eods</code></strong> :&ensp;<code>bool</code></dt>
<dd>Plot all EOD waveforms.</dd>
<dt><strong><code>spec_plots</code></strong> :&ensp;<code>bool</code> or <code>'auto'</code></dt>
<dd>Plot amplitude spectra of EOD waveforms.
If 'auto', plot them if there is a singel waveform only.</dd>
<dt><strong><code>log_freq</code></strong> :&ensp;<code>boolean</code></dt>
<dd>Logarithmic (True) or linear (False) frequency axis of power spectrum of recording.</dd>
<dt><strong><code>min_freq</code></strong> :&ensp;<code>float</code></dt>
<dd>Limits of frequency axis of power spectrum of recording
are set to <code>(min_freq, max_freq)</code> if <code>max_freq</code> is greater than zero</dd>
<dt><strong><code>max_freq</code></strong> :&ensp;<code>float</code></dt>
<dd>Limits of frequency axis of power spectrum of recording
are set to <code>(min_freq, max_freq)</code> and limits of power axis are computed
from powers below max_freq if <code>max_freq</code> is greater than zero</dd>
<dt><strong><code>interactive</code></strong> :&ensp;<code>bool</code></dt>
<dd>If True install some keyboard interaction.</dd>
<dt><strong><code>verbose</code></strong> :&ensp;<code>int</code></dt>
<dd>Print out information about data to be plotted if greater than zero.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>fig</code></strong> :&ensp;<code>plt.figure</code></dt>
<dd>Figure with the plots.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot_eods(base_name, raw_data, samplerate, channel, idx0, idx1, clipped,
              psd_data, wave_eodfs, wave_indices, mean_eods, eod_props, peak_data, spec_data,
              indices, unit, zoom_window, n_snippets=10, power_thresh=None, label_power=True,
              all_eods=False, spec_plots=&#39;auto&#39;, log_freq=False, min_freq=0.0, max_freq=3000.0,
              interactive=True, verbose=0):
    &#34;&#34;&#34;Creates an output plot for the thunderfish program.

    This output contains the raw trace where the analysis window is
    marked, the power-spectrum of this analysis window where the
    detected fish are marked, plots of averaged EOD plots, and
    spectra of the EOD waveforms.

    Parameters
    ----------
    base_name: string
        Basename of audio_file.
    raw_data: array
        Dataset.
    samplerate: float
        Sampling rate of the dataset.
    channel: int or None
        Channel of the recording to be put into the plot title.
        If None, do not write the channel into the title.
    idx0: float
        Index of the beginning of the analysis window in the dataset.
    idx1: float
        Index of the end of the analysis window in the dataset.
    clipped: float
        Fraction of clipped amplitudes.
    psd_data: 2D array
        Power spectrum (frequencies and power) of the analysed data.
    wave_eodfs: array
        Frequency and power of fundamental frequency/harmonics of several fish.
    wave_indices: array of int
        Indices of wave fish mapping from wave_eodfs to eod_props.
        If negative, then that EOD frequency has no waveform described in eod_props.
    mean_eods: list of 2-D arrays with time, mean and std.
        Mean trace for the mean EOD plot.
    eod_props: list of dict
        Properties for each waveform in mean_eods.
    peak_data: list of 2_D arrays
        For each pulsefish a list of peak properties
        (index, time, and amplitude).
    spec_data: list of 2_D arrays
        For each pulsefish a power spectrum of the single pulse and for
        each wavefish the relative amplitudes and phases of the harmonics.
    indices: list of int or None
        Indices of the fish in eod_props to be plotted.
        If None try to plot all.
    unit: string
        Unit of the trace and the mean EOD.
    n_snippets: int
        Number of EOD waveform snippets to be plotted. If zero do not plot any.
    power_thresh:  2 D array or None
        Frequency (first column) and power (second column) of threshold
        derived from single pulse spectra to discard false wave fish.
    label_power: boolean
        If `True` put the power in decibel in addition to the frequency
        into the legend.
    all_eods: bool
        Plot all EOD waveforms.
    spec_plots: bool or &#39;auto&#39;
        Plot amplitude spectra of EOD waveforms.
        If &#39;auto&#39;, plot them if there is a singel waveform only.
    log_freq: boolean
        Logarithmic (True) or linear (False) frequency axis of power spectrum of recording.
    min_freq: float
        Limits of frequency axis of power spectrum of recording
        are set to `(min_freq, max_freq)` if `max_freq` is greater than zero
    max_freq: float
        Limits of frequency axis of power spectrum of recording
        are set to `(min_freq, max_freq)` and limits of power axis are computed
        from powers below max_freq if `max_freq` is greater than zero
    interactive: bool
        If True install some keyboard interaction.
    verbose: int
        Print out information about data to be plotted if greater than zero.

    Returns
    -------
    fig: plt.figure
        Figure with the plots.
    &#34;&#34;&#34;

    def keypress(event):
        if event.key in &#39;pP&#39;:
            if idx1 &gt; idx0:
                playdata = 1.0 * raw_data[idx0:idx1]
            else:
                playdata = 1.0 * raw_data[:]
            fade(playdata, samplerate, 0.1)
            play(playdata, samplerate, blocking=False)

    def recording_format_coord(x, y):
        return &#39;full recording: x=%.3f s, y=%.3f&#39; % (x, y)

    def recordingzoom_format_coord(x, y):
        return &#39;recording zoom-in: x=%.3f s, y=%.3f&#39; % (x, y)
            
    def psd_format_coord(x, y):
        return &#39;power spectrum: x=%.1f Hz, y=%.1f dB&#39; % (x, y)

    def meaneod_format_coord(x, y):
        return &#39;mean EOD waveform: x=%.2f ms, y=%.3f&#39; % (x, y)

    def ampl_format_coord(x, y):
        return u&#39;amplitude spectrum: x=%.0f, y=%.2f&#39; % (x, y)

    def phase_format_coord(x, y):
        return u&#39;phase spectrum: x=%.0f, y=%.2f \u03c0&#39; % (x, y/np.pi)
            
    def pulsepsd_format_coord(x, y):
        return &#39;single pulse power spectrum: x=%.1f Hz, y=%.1f dB&#39; % (x, y)

    # count number of fish types to be plotted:
    if indices is None:
        indices = list(range(len(eod_props)))
    indices = np.array(indices, dtype=np.int)
    nwave = 0
    npulse = 0
    for idx in indices:
        if eod_props[idx][&#39;type&#39;] == &#39;pulse&#39;:
            npulse += 1
        elif eod_props[idx][&#39;type&#39;] == &#39;wave&#39;:
            nwave += 1
    neods = nwave + npulse

    if verbose &gt; 0:
        print(&#39;plot: %2d waveforms: %2d wave fish, %2d pulse fish and %2d EOD frequencies.&#39;
              % (len(indices), nwave, npulse, len(wave_eodfs)))

    # size and positions:
    if spec_plots == &#39;auto&#39;:
        spec_plots = len(indices) == 1
    large_plots = spec_plots or len(indices) &lt;= 2
    width = 14.0
    height = 10.0
    if all_eods and len(indices) &gt; 0:
        nrows = len(indices) if spec_plots else (len(indices)+1)//2
        if large_plots:
            height = 6.0 + 4.0*nrows
        else:
            height = 6.4 + 1.9*nrows
    leftx = 1.0/width
    midx = 0.5 + leftx
    fullwidth = 1.0-1.4/width
    halfwidth = 0.5-1.4/width
    pheight = 3.0/height
    
    # figure:
    plot_style()
    fig = plt.figure(figsize=(width, height))
    if interactive:
        fig.canvas.mpl_connect(&#39;key_press_event&#39;, keypress)
    
    # plot title:
    title = base_name
    if channel is not None:
        title += &#39; c%d&#39; % channel
    ax = fig.add_axes([0.2/width, 1.0-0.6/height, 1.0-0.4/width, 0.55/height])
    ax.text(0.0, 1.0, title, fontsize=22, va=&#39;top&#39;)
    ax.text(1.0, 1.0, &#39;thunderfish by Benda-Lab&#39;, fontsize=16, ha=&#39;right&#39;, va=&#39;top&#39;)
    ax.text(1.0, 0.0, &#39;version %s&#39; % __version__, fontsize=16, ha=&#39;right&#39;, va=&#39;bottom&#39;)
    ax.set_frame_on(False)
    ax.set_axis_off()
    ax.set_navigate(False)

    # layout of recording and psd plots:
    #force_both = True                    # set to True for debugging pulse and wave detection
    force_both = False
    posy = 1.0 - 4.0/height
    axr = None
    axp = None
    legend_inside = True
    legendwidth = 3.2/width if label_power else 2.2/width
    if neods == 0:
        axr = fig.add_axes([leftx, posy, fullwidth, pheight])                    # top, wide
        if len(psd_data) &gt; 0:
            axp = fig.add_axes([leftx, 2.0/height, fullwidth, pheight])              # bottom, wide
    else:
        if npulse == 0 and nwave &gt; 2 and len(psd_data) &gt; 0 and not force_both:
            axp = fig.add_axes([leftx, posy, fullwidth-legendwidth, pheight])    # top, wide
            legend_inside = False
        elif (npulse &gt; 0 or len(psd_data) == 0) and len(wave_eodfs) == 0 and not force_both:
            axr = fig.add_axes([leftx, posy, fullwidth, pheight])                # top, wide
        else:
            axr = fig.add_axes([leftx, posy, halfwidth, pheight])                # top left
            label_power = False
            legendwidth = 2.2/width
            axp = fig.add_axes([midx, posy, halfwidth, pheight])                 # top, right
        
    # best window data:
    data = raw_data[idx0:idx1] if idx1 &gt; idx0 else raw_data

    # plot recording
    pulse_colors, pulse_markers = colors_markers()
    pulse_colors = pulse_colors[3:]
    pulse_markers = pulse_markers[3:]
    if axr is not None:
        axes_style(axr)
        twidth = 0.1
        if len(indices) &gt; 0:
            if eod_props[indices[0]][&#39;type&#39;] == &#39;wave&#39;:
                twidth = 5.0/eod_props[indices[0]][&#39;EODf&#39;]
            else:
                if len(wave_eodfs) &gt; 0:
                    twidth = 3.0/eod_props[indices[0]][&#39;EODf&#39;]
                else:
                    twidth = 10.0/eod_props[indices[0]][&#39;EODf&#39;]
            twidth = (1+twidth//0.005)*0.005
        plot_eod_recording(axr, data, samplerate, twidth, unit, idx0/samplerate)
        plot_pulse_eods(axr, data, samplerate, zoom_window, twidth, eod_props, idx0/samplerate,
                        colors=pulse_colors, markers=pulse_markers, frameon=True, loc=&#39;upper right&#39;)
        if axr.get_legend() is not None:
            axr.get_legend().get_frame().set_color(&#39;white&#39;)
        axr.set_title(&#39;Recording&#39;, fontsize=14, y=1.05)
        axr.format_coord = recordingzoom_format_coord
    
    # plot psd
    wave_colors, wave_markers = colors_markers()
    if axp is not None:
        axes_style(axp)
        if power_thresh is not None:
            axp.plot(power_thresh[:,0], decibel(power_thresh[:,1]), &#39;#CCCCCC&#39;, lw=1)
        if len(wave_eodfs) &gt; 0:
            kwargs = {}
            if len(wave_eodfs) &gt; 1:
                title = &#39;%d EOD frequencies&#39; % len(wave_eodfs)
                kwargs = {&#39;title&#39;: title if len(wave_eodfs) &gt; 2 else None }
                if legend_inside:
                    kwargs.update({&#39;bbox_to_anchor&#39;: (1.05, 1.1),
                                   &#39;loc&#39;: &#39;upper right&#39;, &#39;legend_rows&#39;: 10,
                                   &#39;frameon&#39;: True})
                else:
                    kwargs.update({&#39;bbox_to_anchor&#39;: (1.0, 1.1), &#39;frameon&#39;: False,
                                   &#39;loc&#39;: &#39;upper left&#39;, &#39;legend_rows&#39;: 12})
            plot_harmonic_groups(axp, wave_eodfs, wave_indices, max_groups=0,
                                 sort_by_freq=True, label_power=label_power,
                                 colors=wave_colors, markers=wave_markers,
                                 **kwargs)
            if legend_inside:
                axp.get_legend().get_frame().set_color(&#39;white&#39;)
        plot_decibel_psd(axp, psd_data[:,0], psd_data[:,1], log_freq=log_freq,
                         min_freq=min_freq, max_freq=max_freq, ymarg=5.0, color=&#39;blue&#39;)
        axp.yaxis.set_major_locator(ticker.MaxNLocator(6))
        if len(wave_eodfs) == 1:
            axp.get_legend().set_visible(False)
            label = &#39;%6.1f Hz&#39; % wave_eodfs[0][0, 0]
            axp.set_title(&#39;Powerspectrum: %s&#39; % label, y=1.05, fontsize=14)
        else:
            axp.set_title(&#39;Powerspectrum&#39;, y=1.05, fontsize=14)
        axp.format_coord = psd_format_coord

    # get fish labels from legends:
    if axp is not None:
        w, _ = axp.get_legend_handles_labels()
        eodf_labels = [wi.get_label().split()[0] for wi in w]
        legend_wave_eodfs = np.array([float(f) if f[0] != &#39;(&#39; else np.nan for f in eodf_labels])
    if axr is not None:
        p, _ = axr.get_legend_handles_labels()
        eodf_labels = [pi.get_label().split()[0] for pi in p]
        legend_pulse_eodfs = np.array([float(f) if f[0] != &#39;(&#39; else np.nan for f in eodf_labels])

    # layout:
    sheight = 1.4/height
    sstep = 1.6/height
    max_plots = len(indices)
    if not all_eods:
        if large_plots:
            max_plots = 1 if spec_plots else 2
        else:
            max_plots = 4
    if large_plots:
        pstep = pheight + 1.0/height
        ty = 1.08
        my = 1.10
        ny = 6
    else:
        posy -= 0.2/height
        pheight = 1.3/height
        pstep = 1.9/height
        ty = 1.10
        my = 1.16
        ny = 4
    posy -= pstep
            
    # sort indices by p-p amplitude:
    pp_ampls = [eod_props[idx][&#39;p-p-amplitude&#39;] for idx in indices]
    pp_indices = np.argsort(pp_ampls)[::-1]
        
    # plot EOD waveform and spectra:
    for k, idx in enumerate(indices[pp_indices]):
        if k &gt;= max_plots:
            break
        # plot EOD waveform:
        mean_eod = mean_eods[idx]
        props = eod_props[idx]
        peaks = peak_data[idx]
        lx = leftx if spec_plots or k%2 == 0 else midx
        ax = fig.add_axes([lx, posy, halfwidth, pheight])
        axes_style(ax)
        ax.yaxis.set_major_locator(ticker.MaxNLocator(ny))
        if len(indices) &gt; 1:
            ax.text(0.3, ty, &#39;{EODf:.1f} Hz {type} fish&#39;.format(**props),
                       transform=ax.transAxes, fontsize=14)
            mx = 0.25
        else:
            ax.text(-0.1, ty, &#39;{EODf:.1f} Hz {type} fish&#39;.format(**props),
                       transform=ax.transAxes, fontsize=14)
            ax.text(0.5, ty, &#39;Averaged EOD&#39;,
                       transform=ax.transAxes, fontsize=14, ha=&#39;center&#39;)
            mx = -0.14
        eodf = props[&#39;EODf&#39;]
        if props[&#39;type&#39;] == &#39;wave&#39;:
            if axp is not None:
                wk = np.nanargmin(np.abs(legend_wave_eodfs - eodf))
                ma = ml.Line2D([mx], [my], color=w[wk].get_color(), marker=w[wk].get_marker(),
                               markersize=w[wk].get_markersize(), mec=&#39;none&#39;, clip_on=False,
                               label=w[wk].get_label(), transform=ax.transAxes)
                ax.add_line(ma)
        else:
            if axr is not None:
                pk = np.argmin(np.abs(legend_pulse_eodfs - eodf))
                ma = ml.Line2D([mx], [my], color=p[pk].get_color(), marker=p[pk].get_marker(),
                               markersize=p[pk].get_markersize(), mec=&#39;none&#39;, clip_on=False,
                               label=p[pk].get_label(), transform=ax.transAxes)
                ax.add_line(ma)
        plot_eod_waveform(ax, mean_eod, props, peaks, unit)
        if props[&#39;type&#39;] == &#39;pulse&#39;:
            plot_eod_snippets(ax, data, samplerate, mean_eod[0,0], mean_eod[-1,0],
                              props[&#39;times&#39;], n_snippets, props[&#39;flipped&#39;])
        if not large_plots and k &lt; max_plots-2:
            ax.set_xlabel(&#39;&#39;)
        ax.format_coord = meaneod_format_coord

        # plot spectra:
        if spec_plots:
            spec = spec_data[idx]
            if  props[&#39;type&#39;] == &#39;pulse&#39;:
                ax = fig.add_axes([midx, posy, halfwidth, pheight])
                axes_style(ax)
                plot_pulse_spectrum(ax, spec, props)
                ax.set_title(&#39;Single pulse spectrum&#39;, fontsize=14, y=1.05)
                ax.format_coord = pulsepsd_format_coord
            else:
                axa = fig.add_axes([midx, posy+sstep, halfwidth, sheight])
                axes_style(axa)
                axp = fig.add_axes([midx, posy, halfwidth, sheight])
                axes_style(axp)
                plot_wave_spectrum(axa, axp, spec, props, unit)
                axa.set_title(&#39;Amplitude and phase spectrum&#39;, fontsize=14, y=1.05)
                axa.set_xticklabels([])
                axa.yaxis.set_major_locator(ticker.MaxNLocator(4))
                axa.format_coord = ampl_format_coord
                axp.format_coord = phase_format_coord

        if spec_plots or k%2 == 1:
            posy -= pstep

    # whole trace:
    ax = fig.add_axes([leftx, 0.6/height, fullwidth, 0.9/height])
    axes_style(ax)
    plot_data_window(ax, raw_data, samplerate, unit, idx0, idx1, clipped)
    ax.format_coord = recording_format_coord

    return fig</code></pre>
</details>
</dd>
<dt id="thunderfish.thunderfish.plot_style"><code class="name flex">
<span>def <span class="ident">plot_style</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>Set style of plots.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot_style():
    &#34;&#34;&#34;Set style of plots.
    &#34;&#34;&#34;
    plt.rcParams[&#39;figure.facecolor&#39;] = &#39;white&#39;
    plt.rcParams[&#39;axes.facecolor&#39;] = &#39;none&#39;
    plt.rcParams[&#39;xtick.direction&#39;] = &#39;out&#39;
    plt.rcParams[&#39;ytick.direction&#39;] = &#39;out&#39;</code></pre>
</details>
</dd>
<dt id="thunderfish.thunderfish.remove_eod_files"><code class="name flex">
<span>def <span class="ident">remove_eod_files</span></span>(<span>output_basename, verbose, cfg)</span>
</code></dt>
<dd>
<div class="desc"><p>Remove all files from previous runs of thunderfish</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def remove_eod_files(output_basename, verbose, cfg):
    &#34;&#34;&#34;Remove all files from previous runs of thunderfish
    &#34;&#34;&#34;
    ff = cfg.value(&#39;fileFormat&#39;)
    if ff == &#39;py&#39;:
        fext = &#39;py&#39;
    else:
        fext = TableData.extensions[cfg.value(&#39;fileFormat&#39;)]
    # remove all files from previous runs of thunderfish:
    for fn in glob.glob(&#39;%s*.%s&#39; % (output_basename, fext)):
        os.remove(fn)
        if verbose &gt; 0:
            print(&#39;removed file %s&#39; % fn)</code></pre>
</details>
</dd>
<dt id="thunderfish.thunderfish.run_thunderfish"><code class="name flex">
<span>def <span class="ident">run_thunderfish</span></span>(<span>file_args)</span>
</code></dt>
<dd>
<div class="desc"><p>Helper function for mutlithreading Pool().map().</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def run_thunderfish(file_args):
    &#34;&#34;&#34;Helper function for mutlithreading Pool().map().
    &#34;&#34;&#34;
    verbose = file_args[1][-2]+1
    if verbose &gt; 0:
        if verbose &gt; 1:
            print(&#39;=&#39;*70)
        print(&#39;analyze recording %s ...&#39; % file_args[0])
    try:
        msg = thunderfish(file_args[0], *file_args[1])
        if msg:
            print(msg)
    except (KeyboardInterrupt, SystemExit):
        print(&#39;\nthunderfish interrupted by user... exit now.&#39;)
        sys.exit(0)
    except:
        print(traceback.format_exc())</code></pre>
</details>
</dd>
<dt id="thunderfish.thunderfish.save_configuration"><code class="name flex">
<span>def <span class="ident">save_configuration</span></span>(<span>cfg, config_file)</span>
</code></dt>
<dd>
<div class="desc"><p>Save configuration parameter for thunderfish to a file.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>cfg</code></strong> :&ensp;<code>ConfigFile</code></dt>
<dd>Configuration parameters and their values.</dd>
<dt><strong><code>config_file</code></strong> :&ensp;<code>string</code></dt>
<dd>Name of the configuration file to be loaded.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def save_configuration(cfg, config_file):
    &#34;&#34;&#34;Save configuration parameter for thunderfish to a file.

    Parameters
    ----------
    cfg: ConfigFile
        Configuration parameters and their values.
    config_file: string
        Name of the configuration file to be loaded.
    &#34;&#34;&#34;
    ext = os.path.splitext(config_file)[1]
    if ext != os.extsep + &#39;cfg&#39;:
        print(&#39;configuration file name must have .cfg as extension!&#39;)
    else:
        print(&#39;write configuration to %s ...&#39; % config_file)
        del cfg[&#39;fileColumnNumbers&#39;]
        del cfg[&#39;fileShrinkColumnWidth&#39;]
        del cfg[&#39;fileMissing&#39;]
        del cfg[&#39;fileLaTeXLabelCommand&#39;]
        del cfg[&#39;fileLaTeXMergeStd&#39;]
        cfg.dump(config_file)</code></pre>
</details>
</dd>
<dt id="thunderfish.thunderfish.save_eods"><code class="name flex">
<span>def <span class="ident">save_eods</span></span>(<span>output_basename, eod_props, mean_eods, spec_data, peak_data, wave_eodfs, wave_indices, unit, verbose, cfg)</span>
</code></dt>
<dd>
<div class="desc"><p>Save analysis results of all EODs to files.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def save_eods(output_basename, eod_props, mean_eods, spec_data, peak_data,
              wave_eodfs, wave_indices, unit, verbose, cfg):
    &#34;&#34;&#34;Save analysis results of all EODs to files.
    &#34;&#34;&#34;
    if write_table_args(cfg)[&#39;table_format&#39;] == &#39;py&#39;:
        with open(output_basename+&#39;.py&#39;, &#39;w&#39;) as f:
            name = os.path.basename(output_basename)
            for k, sdata in enumerate(spec_data):
                # save wave fish only:
                if len(sdata)&gt;0 and sdata.shape[1] &gt; 2:
                    fish = dict(amplitudes=sdata[:,3], phases=sdata[:,5])
                    fish = normalize_wavefish(fish)
                    export_wavefish(fish, name+&#39;-%d_harmonics&#39; % k, f)
    else:
        # all wave fish in wave_eodfs:
        if len(wave_eodfs) &gt; 0:
            fp = save_wave_eodfs(wave_eodfs, wave_indices, output_basename,
                                 **write_table_args(cfg))
            if verbose &gt; 0:
                print(&#39;wrote file %s&#39; % fp)
        # all wave and pulse fish:
        for i, (mean_eod, sdata, pdata) in enumerate(zip(mean_eods, spec_data, peak_data)):
            fp = save_eod_waveform(mean_eod, unit, i, output_basename,
                                   **write_table_args(cfg))
            if verbose &gt; 0:
                print(&#39;wrote file %s&#39; % fp)
            # power spectrum:
            if len(sdata)&gt;0:
                if sdata.shape[1] == 2:
                    fp = save_pulse_spectrum(sdata, unit, i, output_basename,
                                             **write_table_args(cfg))
                else:
                    fp = save_wave_spectrum(sdata, unit, i, output_basename,
                                            **write_table_args(cfg))
                if verbose &gt; 0:
                    print(&#39;wrote file %s&#39; % fp)
            # peaks:
            fp = save_pulse_peaks(pdata, unit, i, output_basename,
                                  **write_table_args(cfg))
            if verbose &gt; 0 and fp is not None:
                print(&#39;wrote file %s&#39; % fp)
        # wave fish properties:
        fp = save_wave_fish(eod_props, unit, output_basename,
                            **write_table_args(cfg))
        if verbose &gt; 0 and fp:
            print(&#39;wrote file %s&#39; % fp)
        # pulse fish properties:
        fp = save_pulse_fish(eod_props, unit, output_basename,
                             **write_table_args(cfg))
        if verbose &gt; 0 and fp:
            print(&#39;wrote file %s&#39; % fp)</code></pre>
</details>
</dd>
<dt id="thunderfish.thunderfish.thunderfish"><code class="name flex">
<span>def <span class="ident">thunderfish</span></span>(<span>filename, load_kwargs, cfg, channel=0, time=None, time_file=False, mode='wp', log_freq=0.0, save_data=False, all_eods=False, spec_plots='auto', save_plot=False, multi_pdf=None, save_subplots='', output_folder='.', keep_path=False, show_bestwindow=False, verbose=0, plot_level=0)</span>
</code></dt>
<dd>
<div class="desc"><p>Automatically detect and analyze all EOD waveforms in a short recording.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>filename</code></strong> :&ensp;<code>string</code></dt>
<dd>Path of the data file to be analyzed.</dd>
<dt><strong><code>load_kwargs</code></strong> :&ensp;<code>dict</code></dt>
<dd>Key-word arguments for the <code>load_data()</code> function.</dd>
<dt><strong><code>cfg</code></strong> :&ensp;<code>dict</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>channel</code></strong> :&ensp;<code>int</code></dt>
<dd>Channel to be analyzed.</dd>
<dt><strong><code>time</code></strong> :&ensp;<code>string, float,</code> or <code>None</code></dt>
<dd>Start time of analysis window: "beginning", "center", "end",
"best", or time in seconds (as float or string). If not None
overwrites "windowPosition" in cofiguration file.</dd>
<dt><strong><code>time_file</code></strong> :&ensp;<code>bool</code></dt>
<dd>If <code>True</code> add time of analysis window to output file names.</dd>
<dt><strong><code>mode</code></strong> :&ensp;<code>'w', 'p', 'P', 'wp',</code> or <code>'wP'</code></dt>
<dd>Analyze wavefish ('w'), all pulse fish ('p'), or largest pulse
fish only ('P').</dd>
<dt><strong><code>log_freq</code></strong> :&ensp;<code>float</code></dt>
<dd>If not 0 plot spectra with logarithmic frequency axis.
Minimum frequency for the logarithmic spectra.</dd>
<dt><strong><code>save_data</code></strong> :&ensp;<code>bool</code></dt>
<dd>If True save analysis results in files. If False, just plot the data.</dd>
<dt><strong><code>all_eods</code></strong> :&ensp;<code>bool</code></dt>
<dd>If True, plot all EOD waveforms.</dd>
<dt><strong><code>spec_plots</code></strong> :&ensp;<code>bool</code> or <code>'auto'</code></dt>
<dd>Plot amplitude spectra of EOD waveforms.
If 'auto', plot them if there is a singel waveform only.</dd>
<dt><strong><code>save_plot</code></strong> :&ensp;<code>bool</code></dt>
<dd>If True, save plots as pdf file.</dd>
<dt><strong><code>multi_pdf</code></strong> :&ensp;<code>matplotlib.PdfPages</code> or <code>None</code></dt>
<dd>PdfPages instance in which to save plots.</dd>
<dt><strong><code>save_subplots</code></strong> :&ensp;<code>string</code></dt>
<dd>If not empty, specifies subplots to be saved as separate pdf
files: r) recording with best window, t) data trace with
detected pulse fish, p) power spectrum with detected wave
fish, w/W) mean EOD waveform, s/S) EOD spectrum, e/E) EOD
waveform and spectra. Capital letters produce a single
multipage pdf containing plots of all detected fish.</dd>
<dt><strong><code>output_folder</code></strong> :&ensp;<code>string</code></dt>
<dd>Folder where to save results.</dd>
<dt><strong><code>keep_path</code></strong> :&ensp;<code>bool</code></dt>
<dd>Add relative path of data files to output path.</dd>
<dt><strong><code>show_bestwindow</code></strong> :&ensp;<code>bool</code></dt>
<dd>Just show how the best window is determined and exit.</dd>
<dt><strong><code>verbose</code></strong> :&ensp;<code>int</code></dt>
<dd>&nbsp;</dd>
<dt>Verbosity level (for debugging).</dt>
<dt><strong><code>plot_level</code></strong> :&ensp;<code>int</code></dt>
<dd>&nbsp;</dd>
</dl>
<p>Plot intermediate results.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>msg</code></strong> :&ensp;<code>string</code> or <code>None</code></dt>
<dd>In case of errors, an error message.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def thunderfish(filename, load_kwargs, cfg, channel=0,
                time=None, time_file=False,
                mode=&#39;wp&#39;, log_freq=0.0, save_data=False,
                all_eods=False, spec_plots=&#39;auto&#39;, save_plot=False,
                multi_pdf=None, save_subplots=&#39;&#39;,
                output_folder=&#39;.&#39;, keep_path=False, show_bestwindow=False,
                verbose=0, plot_level=0):
    &#34;&#34;&#34;Automatically detect and analyze all EOD waveforms in a short recording.

    Parameters
    ----------
    filename: string
        Path of the data file to be analyzed.
    load_kwargs: dict
        Key-word arguments for the `load_data()` function.
    cfg: dict
    channel: int
        Channel to be analyzed.
    time: string, float, or None
        Start time of analysis window: &#34;beginning&#34;, &#34;center&#34;, &#34;end&#34;,
        &#34;best&#34;, or time in seconds (as float or string). If not None
        overwrites &#34;windowPosition&#34; in cofiguration file.
    time_file: bool
        If `True` add time of analysis window to output file names.
    mode: &#39;w&#39;, &#39;p&#39;, &#39;P&#39;, &#39;wp&#39;, or &#39;wP&#39;
        Analyze wavefish (&#39;w&#39;), all pulse fish (&#39;p&#39;), or largest pulse
        fish only (&#39;P&#39;).
    log_freq: float
        If not 0 plot spectra with logarithmic frequency axis.
        Minimum frequency for the logarithmic spectra.
    save_data: bool
        If True save analysis results in files. If False, just plot the data.
    all_eods: bool
        If True, plot all EOD waveforms.
    spec_plots: bool or &#39;auto&#39;
        Plot amplitude spectra of EOD waveforms.
        If &#39;auto&#39;, plot them if there is a singel waveform only.
    save_plot: bool
        If True, save plots as pdf file.
    multi_pdf: matplotlib.PdfPages or None
        PdfPages instance in which to save plots.
    save_subplots: string
        If not empty, specifies subplots to be saved as separate pdf
        files: r) recording with best window, t) data trace with
        detected pulse fish, p) power spectrum with detected wave
        fish, w/W) mean EOD waveform, s/S) EOD spectrum, e/E) EOD
        waveform and spectra. Capital letters produce a single
        multipage pdf containing plots of all detected fish.
    output_folder: string
        Folder where to save results.
    keep_path: bool
        Add relative path of data files to output path.
    show_bestwindow: bool
        Just show how the best window is determined and exit.
    verbose: int
       Verbosity level (for debugging).
    plot_level: int
       Plot intermediate results.

    Returns
    -------
    msg: string or None
        In case of errors, an error message.
    &#34;&#34;&#34;
    # check data file:
    if len(filename) == 0:
        return &#39;you need to specify a file containing some data&#39;

    # file names:
    fn = filename if keep_path else os.path.basename(filename)
    outfilename = os.path.splitext(fn)[0]

    # load data:
    try:
        all_data, samplerate, unit = load_data(filename, -1,
                                               verbose=verbose, **load_kwargs)
    except IOError as e:
        return &#39;%s: failed to open file: %s&#39; % (filename, str(e))
    # select channel:
    channels = all_data.shape[1]
    chan_list = [channel]
    if channel &lt; 0:
        chan_list = range(channels)
    elif channel &gt;= channels:
        return &#39;%s: invalid channel %d (%d channels)&#39; % (filename, channel, channels)
    # process all channels:
    for chan in chan_list:
        raw_data = all_data[:,chan]
        if len(raw_data) &lt;= 1:
            return &#39;%s: empty data file&#39; % filename
        if verbose &gt;= 0 and len(chan_list) &gt; 1:
            print(&#39;  channel %d&#39; % chan)

        # analysis window:
        win_pos = cfg.value(&#39;windowPosition&#39;)
        if time is not None:
            win_pos = time
        data, idx0, idx1, clipped, min_clip, max_clip = analysis_window(raw_data, samplerate, win_pos,
                                                                        cfg, show_bestwindow)
        if show_bestwindow:
            return None
        found_bestwindow = idx1 &gt; 0
        if not found_bestwindow:
            return &#39;%s: not enough data for requested window length. You may want to adjust the windowSize parameter in the configuration file.&#39; % filename

        # detect EODs in the data:
        psd_data, wave_eodfs, wave_indices, eod_props, \
        mean_eods, spec_data, peak_data, power_thresh, skip_reason, zoom_window = \
          detect_eods(data, samplerate, min_clip, max_clip, filename,
                      mode, verbose, plot_level, cfg)
        if not found_bestwindow:
            wave_eodfs = []
            wave_indices = []
            eod_props = []
            mean_eods = []

        # add analysis window to EOD properties:
        for props in eod_props:
            props[&#39;tstart&#39;] = idx0/samplerate
            props[&#39;twindow&#39;] = (idx1 - idx0)/samplerate

        # warning message in case no fish has been found:
        if found_bestwindow and not eod_props :
            msg = &#39;, &#39;.join(skip_reason)
            if msg:
                print(filename + &#39;: no fish found: %s&#39; % msg)
            else:
                print(filename + &#39;: no fish found.&#39;)

        # save results to files:
        output_basename = os.path.join(output_folder, outfilename)
        if channels &gt; 1:
            if channels &gt; 100:
                output_basename += &#39;-c%03d&#39; % chan
            elif channels &gt; 10:
                output_basename += &#39;-c%02d&#39; % chan
            else:
                output_basename += &#39;-c%d&#39; % chan
        if time_file:
            output_basename += &#39;-t%.0fs&#39; % (idx0/samplerate)
        if save_data:
            remove_eod_files(output_basename, verbose, cfg)
            if found_bestwindow:
                if keep_path:
                    outpath = os.path.dirname(output_basename)
                    if not os.path.exists(outpath):
                        if verbose &gt; 0:
                            print(&#39;mkdir %s&#39; % outpath)
                        os.makedirs(outpath)
                save_eods(output_basename, eod_props, mean_eods, spec_data, peak_data,
                          wave_eodfs, wave_indices, unit, verbose, cfg)

        if save_plot or not save_data:
            min_freq = 0.0
            max_freq = 3000.0
            if log_freq &gt; 0.0:
                min_freq = log_freq
                max_freq = min_freq*20
                if max_freq &lt; 2000:
                    max_freq = 2000
                log_freq = True
            else:
                log_freq = False
            n_snippets = 10
            chl = chan if channels &gt; 1 else None
            fig = plot_eods(outfilename, raw_data, samplerate, chl, idx0, idx1, clipped,
                            psd_data[0], wave_eodfs, wave_indices, mean_eods, eod_props,
                            peak_data, spec_data, None, unit, zoom_window, n_snippets,
                            power_thresh, True, all_eods, spec_plots, log_freq, min_freq, max_freq,
                            interactive=not save_data, verbose=verbose)
            if save_plot:
                if multi_pdf is not None:
                    multi_pdf.savefig(fig)
                else:
                    # save figure as pdf:
                    fig.savefig(output_basename + &#39;.pdf&#39;)
                    plt.close(&#39;all&#39;)
                if len(save_subplots) &gt; 0:
                    plot_eod_subplots(output_basename, save_subplots,
                                      raw_data, samplerate, idx0, idx1, clipped, psd_data[0],
                                      wave_eodfs, wave_indices, mean_eods, eod_props,
                                      peak_data, spec_data, unit, zoom_window, n_snippets,
                                      power_thresh, True, log_freq, min_freq, max_freq)
            elif not save_data:
                fig.canvas.set_window_title(&#39;thunderfish&#39;)
                plt.show()
    return None</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul>
<li><a href="#thunderfish">thunderfish</a></li>
</ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="thunderfish" href="index.html">thunderfish</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="two-column">
<li><code><a title="thunderfish.thunderfish.axes_style" href="#thunderfish.thunderfish.axes_style">axes_style</a></code></li>
<li><code><a title="thunderfish.thunderfish.configuration" href="#thunderfish.thunderfish.configuration">configuration</a></code></li>
<li><code><a title="thunderfish.thunderfish.detect_eods" href="#thunderfish.thunderfish.detect_eods">detect_eods</a></code></li>
<li><code><a title="thunderfish.thunderfish.main" href="#thunderfish.thunderfish.main">main</a></code></li>
<li><code><a title="thunderfish.thunderfish.plot_eod_subplots" href="#thunderfish.thunderfish.plot_eod_subplots">plot_eod_subplots</a></code></li>
<li><code><a title="thunderfish.thunderfish.plot_eods" href="#thunderfish.thunderfish.plot_eods">plot_eods</a></code></li>
<li><code><a title="thunderfish.thunderfish.plot_style" href="#thunderfish.thunderfish.plot_style">plot_style</a></code></li>
<li><code><a title="thunderfish.thunderfish.remove_eod_files" href="#thunderfish.thunderfish.remove_eod_files">remove_eod_files</a></code></li>
<li><code><a title="thunderfish.thunderfish.run_thunderfish" href="#thunderfish.thunderfish.run_thunderfish">run_thunderfish</a></code></li>
<li><code><a title="thunderfish.thunderfish.save_configuration" href="#thunderfish.thunderfish.save_configuration">save_configuration</a></code></li>
<li><code><a title="thunderfish.thunderfish.save_eods" href="#thunderfish.thunderfish.save_eods">save_eods</a></code></li>
<li><code><a title="thunderfish.thunderfish.thunderfish" href="#thunderfish.thunderfish.thunderfish">thunderfish</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>